# Course Description

**Course Title:** Building Clocks and Watches with MicroPython<br/>
**Duration:** 14 Weeks<br/>
**Target Audience:** High School Students Learning Computational Thinking

**Course Description:**
In this 14-week, hands-on course, high school students will learn to design and program functional timekeeping devices---from simple LED clocks to sophisticated stopwatches and web-connected displays---using MicroPython on the Raspberry Pi Pico W. Throughout the course, students will be guided by hands on labs, moving from foundational knowledge to creative invention.  Our goal is to create fun projects that teach [computational thinking](glossary.md#computational-thinking).

1.  **Remember:** Students begin by identifying essential electronic components---breadboards, microcontrollers, buttons, knobs, real-time clocks, and displays---and recalling the fundamental concepts of MicroPython programming.
2.  **Understand:** Through teacher-led demonstrations, students explore how timing functions, input/output operations, and hardware connections work together to create a basic LED clock. They deepen their grasp of computational thinking by examining concepts like abstraction (focusing on relevant details) and decomposition (breaking large problems into smaller parts).  They proceed to use these concepts to customize clock and watch faces using graphic displays.
3.  **Apply:** As their skills grow, students practice wiring and programming a 128Ã—64 OLED display, interfacing with web services to fetch real-time data. They also implement stopwatches and timers, applying algorithms and pattern-matching techniques to manage user inputs and display outputs accurately.
4.  **Analyze:** Learners diagnose and troubleshoot various clock behaviors, studying how code efficiency and hardware choices influence device performance. They dissect timing errors, lag issues, and integration problems, refining both their programming and problem-solving skills.
5.  **Evaluate:** Working in teams, students test multiple clock designs to compare accuracy, power consumption, and user experience. They assess trade-offs---such as display readability vs. complexity---and refine solutions based on feedback, cost, and practicality.  They
can also work with AI to design new clocks.
6.  **Create:** Ultimately, students design and assemble their own custom timekeeping projects, combining LEDs, OLED displays, push buttons, and encoders. This final challenge showcases their ability to unify hardware and code into a polished, functioning prototype.

By the end of the course, students will have built a diverse collection of digital clocks, stopwatches, and timers while gaining a rich understanding of electronics, computational thinking, and MicroPython. They will leave empowered to continue exploring the world of embedded systems and creative hardware projects that blend into the AI-powered home.

## Computational Thinking

A structured problem-solving approach that uses computer science principles to formulate solutions by breaking down complex tasks into logical, repeatable steps that can be understood by both humans and machines **Example:** Breaking down the task of making a peanut butter sandwich into discrete steps: "open jar", "grasp knife", "scoop peanut butter".

The main concepts of computational thinking are:

### Decomposition

The process of breaking a complex problem into smaller, more manageable parts.

**Example:** Dividing a clock program into separate functions for displaying time, handling buttons, and managing alarms.

### Pattern Recognition

The ability to identify similarities, trends, and regularities in data or problems.

**Example:** Noticing that both analog and digital clocks need similar time calculation functions despite different display methods.

### Abstraction

Focusing on essential details while filtering out irrelevant information to create a generalized solution 

**Example:** Creating a `display_time()` function that works with any type of display by hiding the specific implementation details.

### Algorithmic Thinking

Creating a set of ordered steps that will solve a problem or achieve a goal.

**Example:** Developing a sequence of steps to synchronize a clock with an internet time server.

These concepts work together:

1.  First, decompose the problem
2.  Look for patterns in the smaller pieces
3.  Abstract away unnecessary details
4.  Create step-by-step solutions with algorithms