{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Designing and Building Clocks and Watches with MicroPython and AI","text":"<p>Welcome to the Clocks and Watches website!</p> <p>This website is a resource for teachers, mentors and students who want to have fun hands-on ways to learn computational thinking using the popular Python language. This course gives junior high and high school students the tools to design and build their own digital clocks and smart watches using low-cost components. </p> <p>This website contains detailed instructions for finding low-cost parts  (many under $20/student) and customizing your custom clock and watch displays using MicroPython.</p> <p>These projects have only recently been possible due to the following developments:</p> <ol> <li>The 2021 release of the powerful $4 Raspberry Pi Pico microcontroller. It had almost 100x the power of the Arduino Uno and sold for 1/8th the price.</li> <li>The availability of low-cost high-contrast OLED and TFT displays for as low as $7 each.  When we use the $4 Raspberry Pi Pico our classrooms can create a development system for under $15.</li> <li>The support of highly-optimized drawing of complex ellipse and polygon shapes into the frame buffer by the MicroPython runtime. This only became available in version 20 of the standard MicroPython runtime released in April of 2023.  Before this every clock and watch project used custom math functions that slowed drawing times.</li> <li>The ability of WiFi-enabled microcontrollers that can synchronize with centralized time services using standard WiFi networks. We use the $5 Raspberry Pi Pico W in many of our projects.</li> <li>The availability of low-cost yet ultra-precise real-time clock chips like the DS3231.</li> </ol> <p>Our goal is to provide fun ways to teach computational thinking to a wide variety of students from 6th to 12th grades.  If you can type, we have fun lesson plans from drawing simple shapes to complex clock and watch face designs.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>I want to thank everyone in the MicroPython community for sharing their code.  Each of the displays requires MicroPython drivers that have special features to keep drawing fast.  We could not have high-quality lesson plans without your contributions.  If I have not referenced the cool features of your drivers, please let me know!</p>"},{"location":"#feedback-and-comments","title":"Feedback and Comments","text":"<p>If you have any comments or feedback, please feel free to post these to our GitHub Issues.  I don't check these issues every day, so please be patient and connect with others in the MicroPython community if you have urgent questions for a classroom.</p> <p>Good Luck! - Dan McCreary on LinkedIn</p>"},{"location":"about/","title":"About the MicroPython Clocks and Watches Site","text":"<p>Innovation often occurs at the seams of specialties.  This book fits at the intersection of timekeeping, art and teaching computational thinking.</p> <p>This book can serve as a hands-on guide to introducing students to the fun world of building your own customized clocks and watches with low-cost parts and some MicroPython code to make it all work together.</p>"},{"location":"about/#why-we-created-this-book","title":"Why We Created This Book","text":"<p>My STEM students often hold a special facination with timekeeping. I don't know exactly what it is that gets them so excited about these projects.  But the bottom line is they quickly become motivated to learn Python to create their own timekeeping devices that are customized to their interests.  Owning their own devices and showing off these projects to their friends is also a big plus.</p> <p>At the core of  Project Based Learning (PBL)  is the desire to allow students to pick their own projects.  My role  as a mentor is to have a rich set of projects they can get  started on.  They may not understand all the components, but  to fix and modify the projects they end up learning  faster than if I gave them a dozen lectures with PowerPoint.</p>"},{"location":"about/#the-timeless-allure-of-timekeeping-sparking-a-passion-for-coding-with-micropython-clocks-and-watches","title":"The Timeless Allure of Timekeeping: Sparking a Passion for Coding with MicroPython Clocks and Watches","text":"<p>In a world driven by digital innovation, the essence of time remains universally compelling. From the ancient sundials to the modern-day smartwatches, humans have always been fascinated by the pursuit of measuring time. This intrigue, particularly among the younger generation, is why a library of fun MicroPython Clocks and Watches serves as an exceptional entry point into the universe of coding and computational thinking.</p>"},{"location":"about/#tapping-into-the-childs-natural-curiosity","title":"Tapping into the Child's Natural Curiosity","text":"<p>Children possess an innate sense of wonder. The ticking of a clock or the changing digits on a digital watch captivates their imagination. They question how it works, what makes it tick, and how they can possibly create one of their own. By introducing them to a collection of engaging MicroPython timekeeping projects, we are not only answering their questions but also kindling a flame of creativity and innovation.</p>"},{"location":"about/#from-boring-lectures-to-tangible-results","title":"From Boring Lectures to Tangible Results","text":"<p>Traditional pedagogical methods, characterized by long hours of lectures, often fail to hold the attention of young learners. However, project-based learning flips this paradigm. When a child is given the tools and guidance to create their very own digital clock or watch, the learning process transforms. They're no longer passive recipients of information but active creators, brimming with ideas and enthusiasm.</p> <p>A MicroPython Clock project, for instance, isn\u2019t just a coding endeavor; it's a journey. From understanding the concept, drafting the design, writing the first line of code, to finally witnessing their creation come to life \u2013 every step is a lesson in problem-solving, critical thinking, and perseverance.</p>"},{"location":"about/#building-blocks-of-computational-thinking","title":"Building Blocks of Computational Thinking","text":"<p>Computational thinking is a cornerstone of modern education. It\u2019s not just about writing code, but a way of approaching problems logically, breaking them down into smaller tasks, and finding efficient solutions. By creating a timekeeping device, children undergo a practical exercise in computational thinking. They decide the features they want, debug issues, and constantly refine their work, all while having fun!</p>"},{"location":"about/#social-construction-the-joy-of-shared-creation","title":"Social Construction: The Joy of Shared Creation","text":"<p>Imagine a part of every school library or a display case where clocks and watches are on display.   Each devices can tell its unique story, representing a young coder's journey. Sharing these creations allows children to learn from each other, celebrate their achievements, and draw inspiration. Such a collaborative environment fosters not just coding skills but also empathy, teamwork, and a sense of community.  Technically, we call group building projects Social constructivism.  And there is ample research to show that students that learn in groups have higer participation rates and can usually develop better outcomes.</p>"},{"location":"about/#engineered-for-user-experience","title":"Engineered for User Experience","text":"<p>Great STEM projects don't just fall off a shelf into our laps.  They need to be designed and tested carefully using the same agile processes that we use in software development.  User Experience (UX) professionals need to help us observe our students using and learning from our lessons.</p>"},{"location":"about/#the-evolution-of-learning","title":"The Evolution of Learning","text":"<p>The above image was my attempt in 2014 to use a breadboard and the original ATmega328P microcontroller to build a clock.  This required deep knowledge of the ATmega328P microcontroller and programming in raw low-level C code. Just setting up the integrated development environment could take days. The code needed to be complied and the entire program downloaded into the memory just to run a simple test.  You were limited to just 2K or RAM and the clock ran at a slow 16MhZ.</p> <p>Today the Raspberry Pi has enough RAM to run a full Python interpreter and 264K of RAM just for program memory.  It can run up to 150MhZ and has multiple cores that can be working on different tasks such as reading sensors and updating displays.</p> <p>In short, this power translates into fun projects that are easy to write.  Combining these powerful microcontrollers with AI assistants means even novice programmers can quickly achieve great things!  Building DIY projects has never been so fun!</p>"},{"location":"about/#great-way-to-teach-prompt-engineering","title":"Great Way to Teach Prompt Engineering","text":"<p>This course has hundreds of sample prompts you can use with generative AI tools to create custom code or to generate your own intelligent textbook.  You are strongly encouraged to load your config.py file into the projects area of these tool or include the config.py file as part of your prompt.</p> <p>We hope that you use this course as a proactive way to teach prompt engineering to your students.</p> <p>Make sure you use the search tool in the page header with the word \"prompt\" to help you get the best prompt for your task.</p> <p>For example:</p> <p>Prompt</p> <p>I have a csv file of birthdays for my family and friends. Please add birthday reminders to the clock display.</p>"},{"location":"about/#in-conclusion","title":"In Conclusion","text":"<p>A library of MicroPython Clocks and Watches isn't just a collection of projects; it\u2019s a treasure trove of experiences, learnings, and memories. By introducing children to the magic of timekeeping in the digital age, we are equipping them with skills for the future, fostering a love for coding, and most importantly, reminding them that learning can be both fun and profoundly meaningful. The timeless allure of time, coupled with the dynamic world of coding, creates a perfect blend to mold the innovators and thinkers of tomorrow.</p>"},{"location":"contact/","title":"Contact","text":"<p>Dan McCreary on LinkedIn</p>"},{"location":"course-description/","title":"Course Description","text":"<p>Course Title: Building Clocks and Watches with MicroPython Duration: 14 Weeks Target Audience: High School Students Learning Computational Thinking</p> <p>Course Description: In this 14-week, hands-on course, high school students will learn to design and program functional timekeeping devices---from simple LED clocks to sophisticated stopwatches and web-connected displays---using MicroPython on the Raspberry Pi Pico W. Throughout the course, students will be guided by hands on labs, moving from foundational knowledge to creative invention.  Our goal is to create fun projects that teach computational thinking.</p> <ol> <li>Remember: Students begin by identifying essential electronic components---breadboards, microcontrollers, buttons, knobs, real-time clocks, and displays---and recalling the fundamental concepts of MicroPython programming.</li> <li>Understand: Through teacher-led demonstrations, students explore how timing functions, input/output operations, and hardware connections work together to create a basic LED clock. They deepen their grasp of computational thinking by examining concepts like abstraction (focusing on relevant details) and decomposition (breaking large problems into smaller parts).  They proceed to use these concepts to customize clock and watch faces using graphic displays.</li> <li>Apply: As their skills grow, students practice wiring and programming a 128\u00d764 OLED display, interfacing with web services to fetch real-time data. They also implement stopwatches and timers, applying algorithms and pattern-matching techniques to manage user inputs and display outputs accurately.</li> <li>Analyze: Learners diagnose and troubleshoot various clock behaviors, studying how code efficiency and hardware choices influence device performance. They dissect timing errors, lag issues, and integration problems, refining both their programming and problem-solving skills.</li> <li>Evaluate: Working in teams, students test multiple clock designs to compare accuracy, power consumption, and user experience. They assess trade-offs---such as display readability vs. complexity---and refine solutions based on feedback, cost, and practicality.  They can also work with AI to design new clocks.</li> <li>Create: Ultimately, students design and assemble their own custom timekeeping projects, combining LEDs, OLED displays, push buttons, and encoders. This final challenge showcases their ability to unify hardware and code into a polished, functioning prototype.</li> </ol> <p>By the end of the course, students will have built a diverse collection of digital clocks, stopwatches, and timers while gaining a rich understanding of electronics, computational thinking, and MicroPython. They will leave empowered to continue exploring the world of embedded systems and creative hardware projects that blend into the AI-powered home.</p>"},{"location":"course-description/#computational-thinking","title":"Computational Thinking","text":"<p>A structured problem-solving approach that uses computer science principles to formulate solutions by breaking down complex tasks into logical, repeatable steps that can be understood by both humans and machines Example: Breaking down the task of making a peanut butter sandwich into discrete steps: \"open jar\", \"grasp knife\", \"scoop peanut butter\".</p> <p>The main concepts of computational thinking are:</p>"},{"location":"course-description/#decomposition","title":"Decomposition","text":"<p>The process of breaking a complex problem into smaller, more manageable parts.</p> <p>Example: Dividing a clock program into separate functions for displaying time, handling buttons, and managing alarms.</p>"},{"location":"course-description/#pattern-recognition","title":"Pattern Recognition","text":"<p>The ability to identify similarities, trends, and regularities in data or problems.</p> <p>Example: Noticing that both analog and digital clocks need similar time calculation functions despite different display methods.</p>"},{"location":"course-description/#abstraction","title":"Abstraction","text":"<p>Focusing on essential details while filtering out irrelevant information to create a generalized solution </p> <p>Example: Creating a <code>display_time()</code> function that works with any type of display by hiding the specific implementation details.</p>"},{"location":"course-description/#algorithmic-thinking","title":"Algorithmic Thinking","text":"<p>Creating a set of ordered steps that will solve a problem or achieve a goal.</p> <p>Example: Developing a sequence of steps to synchronize a clock with an internet time server.</p> <p>These concepts work together:</p> <ol> <li>First, decompose the problem</li> <li>Look for patterns in the smaller pieces</li> <li>Abstract away unnecessary details</li> <li>Create step-by-step solutions with algorithms</li> </ol>"},{"location":"faq/","title":"Building Clocks and Watches with MicroPython - Frequently Asked Questions","text":""},{"location":"faq/#general-course-information","title":"General Course Information","text":""},{"location":"faq/#what-prior-knowledge-do-i-need-for-this-course","title":"What prior knowledge do I need for this course?","text":"<p>No specific electronics or programming experience is required. However, basic computer literacy and comfort with mathematics at a high school level will be helpful. The course starts with fundamentals and builds up gradually.</p>"},{"location":"faq/#how-long-is-each-class-session","title":"How long is each class session?","text":"<p>While the course runs for 14 weeks, specific class session lengths are determined by your school's schedule. Contact your instructor for the exact timing of your sessions.</p>"},{"location":"faq/#do-i-need-to-purchase-my-own-equipment","title":"Do I need to purchase my own equipment?","text":"<p>Check with your instructor about equipment policies. Generally, core components like the Raspberry Pi Pico W and basic electronics will be provided, but you may want to purchase additional components for your final project.</p>"},{"location":"faq/#what-software-do-i-need-to-install","title":"What software do I need to install?","text":"<p>You'll need the Thonny IDE (a Python editor designed for MicroPython), which is free and works on Windows, Mac, and Linux. Your instructor will guide you through the installation process during the first week.</p>"},{"location":"faq/#technical-questions","title":"Technical Questions","text":""},{"location":"faq/#what-is-micropython-and-how-is-it-different-from-regular-python","title":"What is MicroPython and how is it different from regular Python?","text":"<p>MicroPython is a streamlined version of Python designed to run on microcontrollers. While it maintains Python's core features and syntax, it's optimized for hardware control and has special libraries for working with electronic components.</p>"},{"location":"faq/#what-is-a-raspberry-pi-pico-w","title":"What is a Raspberry Pi Pico W?","text":"<p>The Raspberry Pi Pico W is a small, affordable microcontroller board with built-in Wi-Fi. It's perfect for learning because it's user-friendly, well-documented, and has plenty of input/output pins for connecting different components.</p>"},{"location":"faq/#will-we-be-doing-any-soldering","title":"Will we be doing any soldering?","text":"<p>Most projects will use breadboards for non-permanent connections. Some optional advanced projects might involve soldering, but this will be optional and supervised.</p>"},{"location":"faq/#how-accurate-will-our-clocks-be","title":"How accurate will our clocks be?","text":"<p>The accuracy depends on the components used. With the basic oscillator, clocks might drift a few seconds per day. When we add a Real-Time Clock (RTC) module, accuracy improves significantly to within a few seconds per month.</p>"},{"location":"faq/#project-related-questions","title":"Project-Related Questions","text":""},{"location":"faq/#what-kind-of-displays-will-we-use","title":"What kind of displays will we use?","text":"<p>We'll work with several types: - Simple LEDs for basic digital displays - 128\u00d764 OLED displays for more sophisticated interfaces - Other display options for final projects</p>"},{"location":"faq/#can-i-create-my-own-custom-clock-design-for-the-final-project","title":"Can I create my own custom clock design for the final project?","text":"<p>Yes! The final project is designed to be creative and personal. You can combine different components and features we've learned about to create something unique.</p>"},{"location":"faq/#how-will-we-handle-time-zones-and-daylight-saving-time","title":"How will we handle time zones and daylight saving time?","text":"<p>We'll learn to sync time using web services (when Wi-Fi is available) and program time zone adjustments. Managing daylight saving time will be covered as part of the advanced features.</p>"},{"location":"faq/#learning-and-assessment","title":"Learning and Assessment","text":""},{"location":"faq/#how-will-i-be-graded","title":"How will I be graded?","text":"<p>Assessment typically includes:</p> <ul> <li>Participation in class activities and discussions</li> <li>Ability to work in teams</li> <li>Completion of hands-on labs and exercises</li> <li>Quality and functionality of projects</li> <li>Final project presentation and documentation</li> </ul>"},{"location":"faq/#what-happens-if-my-clock-doesnt-work","title":"What happens if my clock doesn't work?","text":"<p>Troubleshooting is a crucial part of the learning process. You'll have support from instructors and peers, and we'll learn systematic debugging approaches. Making mistakes and fixing them is how we learn!</p>"},{"location":"faq/#can-i-work-with-ai-tools-during-the-course","title":"Can I work with AI tools during the course?","text":"<p>Yes, part of the course includes learning how to effectively use AI tools for design and problem-solving. We'll cover best practices for AI collaboration while ensuring you understand the fundamental concepts.</p>"},{"location":"faq/#hardware-and-components","title":"Hardware and Components","text":""},{"location":"faq/#what-happens-if-i-accidentally-damage-a-component","title":"What happens if I accidentally damage a component?","text":"<p>Don't worry! Learning electronics involves some trial and error. Basic components are relatively inexpensive and replaceable. Just inform your instructor if something breaks.</p>"},{"location":"faq/#how-do-breadboards-work","title":"How do breadboards work?","text":"<p>A breadboard is a reusable platform for creating temporary electrical connections. We'll spend time early in the course understanding how they work and practicing proper connection techniques.</p>"},{"location":"faq/#whats-the-difference-between-digital-and-analog-inputsoutputs","title":"What's the difference between digital and analog inputs/outputs?","text":"<p>Digital signals are either on (1) or off (0), while analog signals can have many values in between. We'll use both types: digital for buttons and simple LEDs, analog for sensors and variable controls.</p>"},{"location":"faq/#programming-concepts","title":"Programming Concepts","text":""},{"location":"faq/#do-i-need-to-memorize-all-the-micropython-commands","title":"Do I need to memorize all the MicroPython commands?","text":"<p>No, you don't need to memorize everything. We'll provide reference materials, and part of learning is knowing how to find and use documentation effectively.</p>"},{"location":"faq/#what-if-i-miss-a-class-and-fall-behind","title":"What if I miss a class and fall behind?","text":"<p>Each concept builds on previous learning, but we'll provide catch-up resources and extra help sessions. Talk to your instructor as soon as possible if you fall behind.</p>"},{"location":"faq/#how-will-we-debug-our-code","title":"How will we debug our code?","text":"<p>We'll learn several debugging techniques:</p> <ul> <li>Using print statements for troubleshooting</li> <li>Reading error messages</li> <li>Using the Thonny debugger</li> <li>Systematic problem-solving approaches</li> </ul>"},{"location":"faq/#safety-and-best-practices","title":"Safety and Best Practices","text":""},{"location":"faq/#is-there-any-risk-of-electric-shock","title":"Is there any risk of electric shock?","text":"<p>The Pico W and components we use operate at very low voltages (3.3V or 5V) which are safe to handle. However, we'll still learn and follow proper safety procedures.</p>"},{"location":"faq/#how-do-i-protect-the-electronic-components","title":"How do I protect the electronic components?","text":"<p>We'll cover basic handling procedures including:</p> <ul> <li>Static electricity precautions</li> <li>Proper connection techniques</li> <li>Component storage and handling</li> <li>Avoiding common mistakes that could damage components</li> </ul>"},{"location":"faq/#advanced-topics-and-extensions","title":"Advanced Topics and Extensions","text":""},{"location":"faq/#can-we-add-features-like-alarms-or-stopwatch-functions","title":"Can we add features like alarms or stopwatch functions?","text":"<p>Yes! As you progress through the course, you'll learn to add various features including:</p> <ul> <li>Multiple alarms</li> <li>Stopwatch and timer functions</li> <li>Custom sounds and alerts</li> <li>Special display effects</li> </ul>"},{"location":"faq/#will-we-learn-about-power-management","title":"Will we learn about power management?","text":"<p>Yes, we'll cover power management including:</p> <ul> <li>Battery operation</li> <li>Sleep modes</li> <li>Power-efficient programming</li> <li>Battery life optimization</li> </ul>"},{"location":"faq/#how-long-will-the-cr2032-coin-cell-battery-last","title":"How long will the CR2032 coin cell battery last?","text":"<p>The typical operational duration in real-time clock circuits ranges from 2 to 10 years, depending on temperature conditions and current draw. </p> <p>The DS3231 RTC module used in our kits draw 3\u03bcA at  room temperature typically operates for 8 years on a single CR2032 battery. The key factors affecting battery life are:</p> <ul> <li>Operating temperature (lower temps extend life)</li> <li>Current draw of the RTC (varies by model)</li> <li>Battery capacity (typical CR2032 = 220mAh)</li> <li>Additional features active (temperature sensing, alarms, etc.)</li> </ul>"},{"location":"faq/#if-the-clock-is-plugged-into-the-wall-will-the-backup-cr2032-battery-be-drained","title":"If the clock is plugged into the wall will the backup CR2032 battery be drained?","text":"<p>No. When external power is connected, the DS3231 RTC board automatically switches to the main power supply and isolates the backup battery circuit, preventing battery drain. The CR2032 is only used when main power is disconnected.</p> <p>This power switching is handled by internal circuitry using diodes that prevent current from flowing to/from the backup battery during normal operation.</p>"},{"location":"faq/#future-applications","title":"Future Applications","text":""},{"location":"faq/#can-i-use-these-skills-for-other-projects","title":"Can I use these skills for other projects?","text":"<p>Absolutely! The skills you'll learn apply to many other electronics and programming projects:</p> <ul> <li>Other types of electronic devices</li> <li>Home automation projects</li> <li>Sensor-based systems</li> <li>IoT (Internet of Things) devices</li> </ul>"},{"location":"faq/#how-does-this-course-prepare-me-for-further-study","title":"How does this course prepare me for further study?","text":"<p>This course builds valuable skills for:</p> <ul> <li>Computer science courses</li> <li>Engineering programs</li> <li>Electronics projects</li> <li>General problem-solving</li> <li>Understanding modern technology</li> </ul>"},{"location":"faq/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"faq/#what-online-resources-can-we-use","title":"What online resources can we use?","text":"<p>We'll use various resources including:</p> <ul> <li>MicroPython documentation</li> <li>Raspberry Pi Pico documentation</li> <li>Component datasheets</li> <li>Online simulators</li> <li>Programming reference guides</li> </ul>"},{"location":"faq/#will-we-use-version-control-like-git","title":"Will we use version control like Git?","text":"<p>While not required, we'll introduce basic version control concepts and how they can help manage your code as projects become more complex.  Many of the clock kits will have all the sample code preloaded into the Raspberry Pi Pico file system.</p>"},{"location":"faq/#collaboration-and-community","title":"Collaboration and Community","text":""},{"location":"faq/#can-we-work-in-teams","title":"Can we work in teams?","text":"<p>Yes! Many activities will involve pair programming or team collaboration. The final project can be individual or team-based, depending on complexity and scope.</p>"},{"location":"faq/#how-can-we-share-our-projects-with-others","title":"How can we share our projects with others?","text":"<p>We'll discuss ways to:</p> <ul> <li>Document your work</li> <li>Create project presentations</li> <li>Share code responsibly</li> <li>Collaborate with other students</li> <li>Showcase your projects</li> </ul>"},{"location":"faq/#getting-help","title":"Getting Help","text":""},{"location":"faq/#what-if-i-get-stuck-on-a-problem","title":"What if I get stuck on a problem?","text":"<p>Multiple support options are available:</p> <ul> <li>Generative AI tools like ChatGPT and Anthropic Claude</li> <li>In-class help from instructors</li> <li>Peer support</li> <li>Office hours</li> <li>Online resources</li> <li>Lab assistance sessions</li> </ul> <p>Note that you can load sample programs and yur config.py file into the generative AI projects area and get high quality results that use your local configuration.</p>"},{"location":"faq/#can-i-get-extra-help-outside-of-class","title":"Can I get extra help outside of class?","text":"<p>Yes, instructors will have office hours and may offer additional  lab time for students who want extra practice or help.</p>"},{"location":"faq/#course-materials","title":"Course Materials","text":""},{"location":"faq/#what-should-i-bring-to-class","title":"What should I bring to class?","text":"<p>Typically you'll need:</p> <ul> <li>Notebook for taking notes</li> <li>Computer (if not provided)</li> <li>Any assigned reading materials</li> <li>Your project components once distributed</li> </ul>"},{"location":"faq/#how-should-i-store-and-transport-my-projects","title":"How should I store and transport my projects?","text":"<p>We'll provide guidance on:</p> <ul> <li>Component storage</li> <li>Project organization</li> <li>Safe transport methods</li> <li>Protecting delicate components</li> </ul>"},{"location":"faq/#final-projects","title":"Final Projects","text":""},{"location":"faq/#what-makes-a-good-final-project","title":"What makes a good final project?","text":"<p>Strong final projects typically:</p> <ul> <li>Solve a real problem or fulfill a genuine need</li> <li>Demonstrate technical skills learned in the course</li> <li>Show creativity and originality</li> <li>Are well-documented</li> <li>Function reliably</li> </ul>"},{"location":"faq/#can-i-continue-working-on-my-project-after-the-course-ends","title":"Can I continue working on my project after the course ends?","text":"<p>Yes! You'll have the knowledge to continue developing and improving your projects. We'll discuss ways to extend your learning and continue exploring electronics and programming.</p>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#12-hour-vs-24-hour-formats","title":"12-Hour vs 24-Hour Formats","text":"<p>Methods for displaying time in either 12-hour (AM/PM) or 24-hour (military) format, including conversion between the two.</p> <p>Example: Converting 13:00 to 1:00 PM and handling the AM/PM indicator.</p>"},{"location":"glossary/#3d-printing-clock-and-watch-enclosures","title":"3D Printing Clock and Watch Enclosures","text":"<p>A process of creating custom protective cases for watch components using additive manufacturing technology.</p> <p>We will not cover these topics in this course.  Our focus in this website is using clock and watch projects to teach computational thinking.</p>"},{"location":"glossary/#abstraction","title":"Abstraction","text":"<p>A technique for managing complexity by hiding unnecessary details while keeping essential features visible. </p> <p>Example: Using a <code>display_time()</code> function that accepts hours and minutes without needing to know how individual LED segments are controlled.</p> <p>Abstraction is one of the four key computational thinking topics we teach in this course.</p>"},{"location":"glossary/#accelerometer","title":"Accelerometer","text":"<p>A sensor that measures physical acceleration and orientation, useful for tilt-based display activation.</p> <p>Example: Detecting when a user lifts their wrist to view the watch face.</p>"},{"location":"glossary/#alarm","title":"Alarm","text":"<p>A scheduled alert that triggers audio, visual, or vibration notifications at specific times.</p> <p>Example: Setting multiple daily alarms using the RTC module.</p>"},{"location":"glossary/#analog-clock-face","title":"Analog Clock Face","text":"<p>A traditional clock display using rotating hands to show time on a circular dial.</p> <p>Example: Drawing hour and minute hands using <code>math.sin()</code> and <code>math.cos()</code> for position calculations.</p>"},{"location":"glossary/#animation","title":"Animation","text":"<p>The process of creating movement by rapidly updating display contents.</p> <p>Example: Smoothly rotating second hands or creating blinking colons between hours and minutes.</p>"},{"location":"glossary/#asynchronous-programming","title":"Asynchronous Programming","text":"<p>A coding technique that allows multiple tasks to run concurrently without blocking each other.</p> <p>Example: Using <code>uasyncio</code> to handle display updates while monitoring button presses.</p>"},{"location":"glossary/#battery-backup","title":"Battery Backup","text":"<p>A power system that maintains time and settings when main power is disconnected.</p>"},{"location":"glossary/#battery-drain-calculation","title":"Battery Drain Calculation","text":"<p>The process of measuring and estimating power consumption to determine battery life.</p> <p>Example: Measuring current draw during different display update modes.</p>"},{"location":"glossary/#battery-power","title":"Battery Power","text":"<p>Portable electrical energy storage used to operate mobile timepieces.</p> <p>Example: Calculating power consumption to estimate battery life.</p>"},{"location":"glossary/#battery-tools","title":"Battery Tools","text":"<p>Instruments and methods for measuring power consumption and battery health.</p> <p>Example: Using multimeters to measure current draw in different modes.</p>"},{"location":"glossary/#blitting","title":"Blitting","text":"<p>A technique for rapidly copying rectangular portions of memory to update displays efficiently.</p> <p>Example: Using framebuffer operations to reduce screen flicker.</p>"},{"location":"glossary/#breadboard","title":"Breadboard","text":"<p>A reusable plastic board with holes and internal connections for prototyping electronic circuits without soldering.</p> <p>Example: Connecting LED displays and buttons to the Pico W using jumper wires on a breadboard.</p>"},{"location":"glossary/#button-debouncing","title":"Button Debouncing","text":"<p>A technique to prevent false button readings caused by mechanical switch contacts bouncing when pressed or released.</p> <p>Example: <code>debounce_time = 100</code> in button configuration prevents multiple accidental triggers.</p>"},{"location":"glossary/#button-input-handling","title":"Button Input Handling","text":"<p>Software techniques for detecting and responding to button presses.</p> <p>Example: Using interrupts and debouncing for reliable input detection.</p>"},{"location":"glossary/#callback-function","title":"Callback Function","text":"<p>A function passed as an argument to another function, which will be executed when a specific event occurs.</p> <p>Example: <code>button_mode_irq</code> function that runs whenever the mode button is pressed.</p>"},{"location":"glossary/#changing-fonts","title":"Changing Fonts","text":"<p>The process of modifying text appearance by loading and applying different typefaces.</p> <p>Example: Using the micropython-ufont library to load compact digital number styles.</p>"},{"location":"glossary/#chimes","title":"Chimes","text":"<p>Musical or tone sequences played at specific intervals or times.</p> <p>Example: Playing Westminster quarter-hour chimes using PWM audio output.</p>"},{"location":"glossary/#chronograph","title":"Chronograph","text":"<p>A timepiece with both timekeeping and stopwatch capabilities.</p>"},{"location":"glossary/#color-animations","title":"Color Animations","text":"<p>Dynamic changes in display colors to create visual effects or indicate status.</p> <p>Example: Gradually shifting background colors throughout the day.</p>"},{"location":"glossary/#color-conversion","title":"Color Conversion","text":"<p>The process of transforming between different color representation systems.</p> <p>Example: Converting RGB colors to 16-bit format for TFT displays.</p>"},{"location":"glossary/#color-conversion-palettes","title":"Color Conversion &amp; Palettes","text":"<p>Methods for transforming between different color representations and managing limited color sets.</p> <p>Example: Converting RGB colors to display-specific formats and creating custom color themes.</p>"},{"location":"glossary/#color-depth","title":"Color Depth","text":"<p>The number of bits used to represent colors in a display.</p> <p>Example: Using 16 bits per pixel to show 65,536 different colors.</p>"},{"location":"glossary/#computational-thinking","title":"Computational Thinking","text":"<p>A structured problem-solving approach that uses computer science principles to formulate solutions by breaking down complex tasks into logical, repeatable steps that can be understood by both humans and machines Example: Breaking down the task of making a peanut butter sandwich into discrete steps: \"open jar\", \"grasp knife\", \"scoop peanut butter\".</p> <p>The main concepts of computational thinking are:</p>"},{"location":"glossary/#decomposition","title":"Decomposition","text":"<p>The process of breaking a complex problem into smaller, more manageable parts Example: Dividing a clock program into separate functions for displaying time, handling buttons, and managing alarms.</p>"},{"location":"glossary/#pattern-recognition","title":"Pattern Recognition","text":"<p>The ability to identify similarities, trends, and regularities in data or problems Example: Noticing that both analog and digital clocks need similar time calculation functions despite different display methods.</p>"},{"location":"glossary/#abstraction_1","title":"Abstraction","text":"<p>Focusing on essential details while filtering out irrelevant information to create a generalized solution Example: Creating a <code>display_time()</code> function that works with any type of display by hiding the specific implementation details.</p>"},{"location":"glossary/#algorithmic-thinking","title":"Algorithmic Thinking","text":"<p>Creating a set of ordered steps that will solve a problem or achieve a goal Example: Developing a sequence of steps to synchronize a clock with an internet time server.</p> <p>These concepts work together:</p> <ol> <li>First, decompose the problem</li> <li>Look for patterns in the smaller pieces</li> <li>Abstract away unnecessary details</li> <li>Create step-by-step solutions with algorithms</li> </ol>"},{"location":"glossary/#concurrency","title":"Concurrency","text":"<p>The ability to handle multiple tasks or events simultaneously in a program.</p> <p>Example: Updating the display while checking for button presses.</p>"},{"location":"glossary/#conditionals","title":"Conditionals","text":"<p>Programming statements that perform different actions based on whether a condition is true or false.</p> <p>Example: Switching between 12-hour and 24-hour time formats.</p>"},{"location":"glossary/#connecting-speakers","title":"Connecting Speakers","text":"<p>Methods for attaching and controlling audio output devices to create sound effects and alarms.</p> <p>Example: Wiring a speaker to a PWM-capable GPIO pin for generating tones for an alarm clock.</p>"},{"location":"glossary/#console-output","title":"Console Output","text":"<p>Text-based information displayed in the development environment for debugging.</p> <p>Example: <code>print(\"Current time:\", hours, \":\", minutes)</code></p>"},{"location":"glossary/#cuckoo-clock","title":"Cuckoo Clock","text":"<p>A timepiece that marks specific hours with sound and optional mechanical movement.</p> <p>Example: Playing bird sounds and activating a servo at the top of each hour.</p>"},{"location":"glossary/#custom-font","title":"Custom Font","text":"<p>A specialized set of character designs loaded into memory for display purposes.</p> <p>Example: Loading compact number fonts using the micropython-ufont library.</p>"},{"location":"glossary/#custom-segment-display","title":"Custom Segment Display","text":"<p>A specialized arrangement of LED segments for showing numbers or characters.</p> <p>Example: Creating unique digit patterns using individual LED segments.</p>"},{"location":"glossary/#digital-to-analog-converter-dac","title":"Digital to Analog Converter (DAC)","text":"<p>An integrated circuit that transforms digital data into a continuous analog voltage. For example we can generate sound using a microcontroller to play an alarm sounds.</p> <p>In our labs we use the MicroPython I2S (Inter-IC Sound) protocol for generating high-fidelity audio output. </p> <p>For example we have a lab that generates a sine wave to create audible tones through a speaker.</p> <p>Specifically our class uses the PCM5102A DAC Module to generate Sound.</p>"},{"location":"glossary/#date-and-calendar-display","title":"Date and Calendar Display","text":"<p>Showing current date information including day of week, month, and year.</p> <p>Example: Formatting and displaying full date alongside time information.</p>"},{"location":"glossary/#datetime-objects","title":"datetime Objects","text":"<p>Programming structures that store date and time information together.</p> <p>Example: Converting between timestamp integers and datetime format.</p>"},{"location":"glossary/#daylight-saving-time","title":"Daylight Saving Time","text":"<p>A seasonal time adjustment typically involving a one-hour shift.</p> <p>Example: Automatically adjusting clock time based on DST rules.</p>"},{"location":"glossary/#deep-sleep","title":"Deep Sleep","text":"<p>A low-power mode that disables most system functions to conserve energy.</p> <p>Example: Entering sleep mode when the watch face isn't being viewed.</p>"},{"location":"glossary/#digital-display","title":"Digital Display","text":"<p>An electronic output device that shows numbers, letters, or symbols using discrete segments or pixels.</p> <p>Example: Four-digit seven-segment LED display showing hours and minutes.</p>"},{"location":"glossary/#display-driver","title":"Display Driver","text":"<p>Software that controls how information is shown on a specific type of display.</p> <p>Example: Using the ST7735 driver for TFT LCD screens.</p>"},{"location":"glossary/#display-technology-comparison","title":"Display Technology Comparison","text":"<p>Analysis of different screen types' advantages and limitations.</p> <p>Example: Evaluating power consumption versus update speed for various displays.</p>"},{"location":"glossary/#double-buffering","title":"Double Buffering","text":"<p>A technique using two memory areas to prepare the next frame while displaying the current one.</p> <p>Example: Creating smooth animations without visible drawing operations.</p>"},{"location":"glossary/#drawing-arcs","title":"Drawing Arcs","text":"<p>Creating curved lines as portions of circles on displays.</p> <p>Example: Drawing round clock face elements and decorative features.</p>"},{"location":"glossary/#drawing-circles","title":"Drawing Circles","text":"<p>Creating perfect circular shapes on displays.</p> <p>Example: Drawing clock face outlines and hour markers.</p>"},{"location":"glossary/#drawing-ellipses","title":"Drawing Ellipses","text":"<p>Creating oval shapes on displays.</p> <p>Example: Designing stylized clock faces and decorative elements.</p>"},{"location":"glossary/#drawing-hands","title":"Drawing Hands","text":"<p>Creating moving indicators for hours, minutes, and seconds.</p> <p>Example: Using line drawing functions to show analog time.</p>"},{"location":"glossary/#drawing-libraries","title":"Drawing Libraries","text":"<p>Software collections that provide functions for creating visual elements.</p> <p>Example: Using built-in graphics functions to draw clock hands and numbers.</p>"},{"location":"glossary/#drawing-lines","title":"Drawing Lines","text":"<p>Creating straight line segments on displays.</p> <p>Example: Drawing clock hand indicators and markings.</p>"},{"location":"glossary/#drawing-numbers","title":"Drawing Numbers","text":"<p>Displaying numerical values on screen.</p> <p>Example: Showing digital time values and markers.</p>"},{"location":"glossary/#drawing-pixels","title":"Drawing Pixels","text":"<p>Setting individual display points for custom graphics.</p> <p>Example: Creating fine details in watch face designs.</p>"},{"location":"glossary/#drawing-polygons","title":"Drawing Polygons","text":"<p>Creating shapes with multiple straight sides.</p> <p>Example: Making custom hour markers and decorative elements.</p>"},{"location":"glossary/#drawing-primitives","title":"Drawing Primitives","text":"<p>Basic shapes and elements used to create more complex visual displays.</p> <p>Example: Using lines and arcs to create clock hands.</p>"},{"location":"glossary/#drawing-rectangles","title":"Drawing Rectangles","text":"<p>Creating four-sided shapes with right angles.</p> <p>Example: Drawing display borders and menu backgrounds.</p>"},{"location":"glossary/#drawing-text","title":"Drawing Text","text":"<p>Displaying characters and strings on screen.</p> <p>Example: Showing time, date, and menu options.</p>"},{"location":"glossary/#drawing-tick-marks","title":"Drawing Tick Marks","text":"<p>Creating small indicators around a clock face.</p> <p>Example: Marking hours and minutes on an analog display.</p>"},{"location":"glossary/#ds1307","title":"DS1307","text":""},{"location":"glossary/#ds3231","title":"DS3231","text":"<p>A high-precision real-time clock (RTC) integrated circuit with temperature compensation for accurate timekeeping.</p> <p>Example: Using the DS3231 to maintain time accuracy within seconds per month.</p>"},{"location":"glossary/#e-paper-display","title":"E-Paper Display","text":"<p>A low-power screen technology that maintains its image without constant power.</p> <p>Example: Using partial updates to change only modified portions of the display.</p>"},{"location":"glossary/#epoch","title":"Epoch","text":"<p>A fixed point in time chosen as a reference for measuring or calculating elapsed time in a computer system or data structure.</p> <p>Example: The Unix epoch begins at midnight UTC on January 1, 1970, while the NTP epoch begins at midnight UTC on January 1, 1900.  The MicroPython epoch is often set to be January 1 2000.  On the Raspberry Pi Pico the epoch is January 1st, 2021.</p>"},{"location":"glossary/#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<p>Techniques for detecting and recovering from timing errors, power issues, or communication failures.</p> <p>Example: Implementing watchdog timers and automatic resynchronization after power loss.#### Event Handler A function that responds to specific occurrences like button presses or timer updates.</p> <p>Example: The <code>button_mode_irq</code> function handles mode button press events.</p>"},{"location":"glossary/#external-rtc","title":"External RTC","text":"<p>A separate timekeeping chip that maintains accurate time independent of the main processor.</p> <p>Example: Using a DS3231 module for precise timekeeping.</p>"},{"location":"glossary/#external-sensors","title":"External Sensors","text":"<p>Additional hardware components that measure environmental conditions.</p> <p>Example: Reading temperature and humidity for weather display.</p>"},{"location":"glossary/#fast-redraw","title":"Fast Redraw","text":"<p>Techniques for updating displays quickly to maintain smooth animation.</p> <p>Example: Using hardware acceleration for screen updates.</p>"},{"location":"glossary/#filesystem","title":"Filesystem","text":"<p>A system for storing and organizing files on the microcontroller.</p> <p>Example: Saving configuration settings and logs to internal storage.</p>"},{"location":"glossary/#flicker-reduction","title":"Flicker Reduction","text":"<p>Methods to minimize visible display instability during updates.</p> <p>Example: Using double buffering to prevent partial frame displays.</p>"},{"location":"glossary/#framebuffer","title":"Framebuffer","text":"<p>A region of memory that holds the complete contents of a display.</p> <p>Example: Modifying pixel data before updating the screen.</p>"},{"location":"glossary/#functions","title":"Functions","text":"<p>Reusable blocks of code that perform specific tasks.</p> <p>Example: Creating a function to convert between 12-hour and 24-hour formats.</p>"},{"location":"glossary/#generating-waveforms-for-audio","title":"Generating Waveforms for Audio","text":"<p>Creating electrical signals for producing sounds and tones using digital-to-analog conversion or PWM.</p> <p>Example: Synthesizing different frequencies for alarm sounds and hourly chimes.</p>"},{"location":"glossary/#ghosting","title":"Ghosting","text":"<p>A visual artifact where previous images remain partially visible on certain display types.</p> <p>Example: Using display clearing techniques on e-paper screens.</p>"},{"location":"glossary/#gpio-pin","title":"GPIO Pin","text":"<p>General Purpose Input/Output connection on a microcontroller that can be programmed to send or receive electrical signals.</p> <p>Example: Using GPIO pin 16 for the mode button: <code>mode_pin = Pin(16, Pin.IN, Pin.PULL_UP)</code></p>"},{"location":"glossary/#hardware-documentation","title":"Hardware Documentation","text":"<p>Technical specifications and usage instructions for electronic components.</p> <p>Example: Consulting pinout diagrams for display connections.</p>"},{"location":"glossary/#i2c","title":"I2C","text":"<p>A medium speed 4-wire communication protocol that allows multiple digital components to exchange data using just two wires plus power and ground.</p> <p>I2C also has many different connectors that allow you to connect I2C components without the need for soldering.</p>"},{"location":"glossary/#i2c-sensors","title":"I2C Sensors","text":"<p>Digital components that communicate using the I2C protocol to provide measurements.</p> <p>Example: Reading temperature and humidity data for weather display.</p>"},{"location":"glossary/#i2s","title":"I2S","text":"<p>The Inter-sound protocol we use to transmit sound data to components such as a Digital to Analog Converter.</p> <p>Inter-IC Sound bus protocol is a synchronous serial protocol used to connect digital audio devices. </p> <p>I2S is a communication protocol that allows multiple digital  components to exchange data using just two wires plus power and ground.</p> <p>MicroPython 1.21 has builtin support for the I2S bus.</p> <ul> <li>MicroPython I2S Documentation</li> <li>See also: DAC</li> <li>See also: PCM5102A DAC</li> </ul>"},{"location":"glossary/#implementing-clock-themes","title":"Implementing Clock Themes","text":"<p>Creating customizable visual styles for clock displays, including colors, fonts, and layouts.</p> <p>Example: Allowing users to switch between day/night themes or seasonal variations.</p>"},{"location":"glossary/#incremental-drawing","title":"Incremental Drawing","text":"<p>Updating only the necessary portions of a display to improve efficiency.</p> <p>Example: Refreshing only the seconds indicator rather than the full screen.</p>"},{"location":"glossary/#interrupt","title":"Interrupt","text":"<p>A signal that temporarily pauses normal program execution to handle important events.</p> <p>Example: Responding immediately to button presses.</p>"},{"location":"glossary/#json","title":"JSON","text":"<p>A text-based data format commonly used for exchanging information with web services.</p> <p>Example: Parsing weather data from online APIs.</p>"},{"location":"glossary/#led-clock-displays","title":"LED Clock Displays","text":"<p>A digital timepiece display using light-emitting diodes arranged in segments or matrices to show time information.</p> <p>Example: Using a four-digit seven-segment LED display to show hours and minutes.</p>"},{"location":"glossary/#led-matrix","title":"LED Matrix","text":"<p>An array of light-emitting diodes arranged in rows and columns that can display patterns, numbers, or text.</p>"},{"location":"glossary/#libraries","title":"Libraries","text":"<p>Collections of pre-written code that provide useful functions and features.</p> <p>Example: Using the <code>math</code> module for trigonometric calculations.</p>"},{"location":"glossary/#lipo-charging","title":"LiPo Charging","text":"<p>The process of safely recharging Lithium Polymer batteries.</p> <p>Example: Implementing USB charging circuits with protection features.</p>"},{"location":"glossary/#lipo-charging-circuit","title":"LiPo Charging Circuit","text":"<p>Electronic system for safely charging Lithium Polymer batteries while protecting against overcharge and overdischarge.</p> <p>Example: Implementing USB charging with voltage regulation and protection features.</p>"},{"location":"glossary/#loading-drivers","title":"Loading Drivers","text":"<p>Installing and initializing software that controls specific hardware components.</p> <p>Example: Importing and configuring TFT display drivers.</p>"},{"location":"glossary/#localtime-function","title":"localtime() Function","text":"<p>A MicroPython function that returns the current time as a tuple of values.</p> <p>Example: <code>year, month, day, hour, minute, second = localtime()</code></p>"},{"location":"glossary/#logging","title":"Logging","text":"<p>The practice of recording program events and data for debugging or analysis.</p> <p>Example: Saving timing discrepancies to investigate accuracy issues.</p>"},{"location":"glossary/#logging-time-data-to-an-sd-card","title":"Logging Time Data to an SD Card","text":"<p>Recording timestamped information to external storage for debugging or data collection.</p> <p>Example: Saving temperature readings with timestamps every hour.</p>"},{"location":"glossary/#loops","title":"Loops","text":"<p>Programming structures that repeat code blocks multiple times.</p> <p>Example: Continuously updating the display every second.</p>"},{"location":"glossary/#math-module","title":"Math Module","text":"<p>A collection of mathematical functions for complex calculations.</p> <p>Example: Using trigonometry to position clock hands.</p>"},{"location":"glossary/#mathsin-and-mathcos","title":"math.sin() and math.cos()","text":"<p>Trigonometric functions used for calculating positions on circular displays.</p> <p>Example: Computing analog clock hand coordinates.</p>"},{"location":"glossary/#menu-system","title":"Menu System","text":"<p>An interface allowing users to navigate options and settings.</p> <p>Example: Creating hierarchical settings menus for watch configuration.</p>"},{"location":"glossary/#menu-systems-for-watch-settings","title":"Menu Systems for Watch Settings","text":"<p>Hierarchical interface structures for configuring watch parameters and features.</p> <p>Example: Creating nested menus for time, alarm, and display settings.</p>"},{"location":"glossary/#micropython","title":"MicroPython","text":"<p>A streamlined version of Python programming language designed to run on microcontrollers and embedded systems.</p>"},{"location":"glossary/#micropython-drawing","title":"MicroPython Drawing","text":"<p>Built-in functions for creating visual elements on displays.</p> <p>Example: Using framebuf methods to draw shapes and text.</p>"},{"location":"glossary/#micropython-network","title":"MicroPython network","text":"<p>A module providing Wi-Fi and network connectivity functions.</p> <p>Example: Connecting to wireless networks for time synchronization.</p>"},{"location":"glossary/#micropython-syntax","title":"MicroPython Syntax","text":"<p>The specific programming language rules and structure for MicroPython code.</p> <p>Example: Using Python-style indentation for code blocks.</p>"},{"location":"glossary/#micropython-ufont-library","title":"micropython-ufont Library","text":"<p>A specialized library for handling compact font rendering in MicroPython applications.</p> <p>Example: Loading custom digit fonts optimized for small displays.</p>"},{"location":"glossary/#neopixel","title":"NeoPixel","text":"<p>A programmable light-emitting diode that combines red, green, and blue elements in a single package with built-in control circuitry.</p> <p>NeoPixel's strips only require three wires: GND, 5V and data.  It makes creating clock display patterns very easy.</p> <p>Example: Creating a ring of 12 individually addressable RGB LEDs to mark hour positions on a clock face.</p>"},{"location":"glossary/#network-time-protocol-ntp","title":"Network Time Protocol (NTP)","text":"<p>A method for synchronizing time over the internet.</p> <p>Example: Updating the RTC from online time servers.</p>"},{"location":"glossary/#oled-display","title":"OLED Display","text":"<p>A thin, bright display that uses organic light-emitting diodes to show text and graphics without a backlight.</p>"},{"location":"glossary/#partial-refresh","title":"Partial Refresh","text":"<p>Updating only changed portions of a display to improve efficiency.</p> <p>Example: Refreshing only the seconds digits each update.</p>"},{"location":"glossary/#partial-screen-updates","title":"Partial Screen Updates","text":"<p>Techniques for refreshing only the changed portions of a display to improve efficiency and reduce flicker.</p> <p>Example: Updating only the seconds digits while leaving hours and minutes static.</p>"},{"location":"glossary/#pedometer","title":"Pedometer","text":"<p>A feature that counts steps using motion sensor data.</p> <p>Example: Calculating daily step counts from accelerometer readings.</p>"},{"location":"glossary/#pcm5102a-dac","title":"PCM5102A DAC","text":"<p>An audio Digital to Analog chip we use in our clock projects.</p> <ul> <li>See Also: PCM5102A Data Sheet</li> </ul>"},{"location":"glossary/#pin","title":"Pin","text":"<p>A metal connector on electronic components that carries electrical signals or power.</p>"},{"location":"glossary/#power-management","title":"Power Management","text":"<p>Techniques for minimizing and controlling energy consumption.</p> <p>Example: Using sleep modes and efficient display updates.</p>"},{"location":"glossary/#power-monitoring","title":"Power Monitoring","text":"<p>Methods for measuring and tracking power consumption in battery-operated devices.</p> <p>Example: Logging battery voltage and current draw to optimize device lifetime.</p>"},{"location":"glossary/#pull-up-resistor","title":"Pull-up Resistor","text":"<p>An electronic component that ensures a consistent voltage level on input pins when buttons or switches are not pressed.</p> <p>Example: Using internal pull-up resistors with <code>Pin.PULL_UP</code> for button inputs.</p>"},{"location":"glossary/#pwm","title":"PWM","text":"<p>Pulse Width Modulation - a technique for creating varying levels of brightness or speed by rapidly switching a signal on and off.</p>"},{"location":"glossary/#pwm-audio","title":"PWM Audio","text":"<p>Using Pulse Width Modulation to generate sounds and tones.</p> <p>Example: Creating alarm beeps and hourly chimes.</p>"},{"location":"glossary/#raspberry-pi-pico-w","title":"Raspberry Pi Pico W","text":"<p>A small, low-cost microcontroller board with built-in wireless capabilities, designed for learning and DIY projects.</p>"},{"location":"glossary/#real-time-clock-rtc","title":"Real-Time Clock (RTC)","text":"<p>A specialized chip or circuit that keeps accurate time even when main power is removed.</p> <p>Example: Using the RTC module to maintain accurate time: <code>rtc = RTC()</code></p>"},{"location":"glossary/#real-time-clock-rtc-overview","title":"Real-time Clock (RTC) Overview","text":"<p>A comprehensive explanation of how real-time clock modules maintain accurate time, including initialization, synchronization, and backup power considerations.</p> <p>Example: Understanding how the RTC maintains time even when main power is disconnected.</p>"},{"location":"glossary/#rotary-encoder","title":"Rotary Encoder","text":"<p>A input device that converts rotational movement into digital signals.</p> <p>Example: Using encoder rotation to adjust time settings.</p>"},{"location":"glossary/#screen-tearing-prevention","title":"Screen Tearing Prevention","text":"<p>Techniques to avoid visual artifacts caused by updating display content while it's being refreshed.</p> <p>Example: Using vsync or double buffering to ensure clean display updates.</p>"},{"location":"glossary/#screen-update","title":"Screen Update","text":"<p>The process of refreshing display contents to show new information.</p> <p>Example: Efficiently updating only changed portions of the time display.</p>"},{"location":"glossary/#screen-via-spi","title":"Screen Via SPI","text":"<p>High-speed serial communication method for updating displays.</p> <p>Example: Sending framebuffer data to TFT screens efficiently.</p>"},{"location":"glossary/#servo-motor","title":"Servo Motor","text":"<p>An actuator that can rotate to precise positions.</p> <p>Example: Moving physical clock hands on a hybrid display.</p>"},{"location":"glossary/#setting-system-clock","title":"Setting System Clock","text":"<p>Configuring the internal timekeeping system with accurate time.</p> <p>Example: Updating RTC time from an external time source.</p>"},{"location":"glossary/#setting-time-with-buttons","title":"Setting Time with Buttons","text":"<p>Interface design and implementation for adjusting clock time using physical buttons.</p> <p>Example: Using mode, increment, and decrement buttons to set hours and minutes.</p>"},{"location":"glossary/#setting-up-i2c-communication","title":"Setting Up I\u00b2C Communication","text":"<p>Configuring and using the Inter-Integrated Circuit (I\u00b2C) protocol for connecting multiple devices.</p> <p>Example: Initializing I\u00b2C bus for communicating with RTC and sensor modules.</p>"},{"location":"glossary/#setting-up-wifi-on-the-pico-w","title":"Setting Up Wi\u2011Fi on the Pico W","text":"<p>Process of configuring wireless network connectivity on the Raspberry Pi Pico W microcontroller.</p> <p>Example: Connecting to a local network using SSID and password credentials.</p>"},{"location":"glossary/#seven-segment-display","title":"Seven-Segment Display","text":"<p>A display made of seven LED segments plus a decimal point that can show numbers and some letters.</p> <p>Example: Creating patterns for digits using segments 'a' through 'g': <code>SEGMENTS = {'a': 4, 'b': 3, 'c': 2, 'd': 7, 'e': 6, 'f': 5, 'g': 1}</code></p>"},{"location":"glossary/#shift-register","title":"Shift Register","text":"<p>An integrated circuit that converts serial data into parallel outputs, useful for controlling multiple LEDs with fewer pins.</p> <p>Example: Using SR74HC595 shift register to control display segments.</p>"},{"location":"glossary/#sleep-mode","title":"Sleep Mode","text":"<p>A low-power state that reduces energy consumption.</p> <p>Example: Entering deep sleep between display updates.</p>"},{"location":"glossary/#sleep-scheduling","title":"Sleep Scheduling","text":"<p>Managing when the device enters and exits low-power states.</p> <p>Example: Programming wake-up times for hourly updates.</p>"},{"location":"glossary/#smartwatch-displays","title":"Smartwatch Displays","text":"<p>Advanced display modules designed specifically for wearable devices, optimizing size, power consumption, and readability.</p> <p>Example: Using a small, high-resolution display with automatic brightness adjustment.</p>"},{"location":"glossary/#sound-encoding","title":"Sound Encoding","text":"<p>Methods for storing and playing audio data for alarms and notifications.</p> <p>Example: Converting WAV files to suitable format for playback.</p>"},{"location":"glossary/#spi","title":"SPI","text":"<p>Serial Peripheral Interface - a fast communication protocol for connecting digital components using multiple signal lines.</p>"},{"location":"glossary/#spi-interface","title":"SPI Interface","text":"<p>A high-speed serial communication protocol for connecting displays and sensors.</p> <p>Example: Transferring data to TFT displays efficiently.</p>"},{"location":"glossary/#state-machine","title":"State Machine","text":"<p>A programming concept where a system can be in one of several defined states, with specific rules for transitioning between them.</p> <p>Example: Clock modes including \"run\", \"set hour\", \"set minute\", and \"set AM/PM\".</p>"},{"location":"glossary/#step-counting-pedometer","title":"Step Counting (Pedometer)","text":"<p>Using motion sensors to detect and count walking steps for fitness tracking.</p> <p>Example: Processing accelerometer data to identify step patterns and maintain daily count.</p>"},{"location":"glossary/#stopwatch","title":"Stopwatch","text":"<p>A timing device that measures elapsed time from a starting point, typically with precision to fractions of a second.</p> <p>Example: Implementing start, stop, and lap timing functions with millisecond accuracy.</p>"},{"location":"glossary/#synchronizing-time-from-the-pc","title":"Synchronizing Time from the PC","text":"<p>The process of setting a microcontroller's clock using the connected computer's time.</p> <p>Example: Using Thonny IDE to automatically update the Pico's RTC when uploading code.</p>"},{"location":"glossary/#temperature-and-humidity","title":"Temperature and Humidity","text":"<p>Integration of environmental sensors to display current conditions alongside time.</p> <p>Example: Reading DHT22 sensor data to show temperature and humidity with clock display.</p>"},{"location":"glossary/#temperature-sensor","title":"Temperature Sensor","text":"<p>A component that measures ambient temperature.</p> <p>Example: Displaying current temperature alongside time.</p>"},{"location":"glossary/#tft-displays","title":"TFT Displays","text":"<p>Thin-film-transistor liquid crystal displays for showing color graphics.</p> <p>Example: Using ST7735 or ILI9341 displays for watch faces.</p>"},{"location":"glossary/#thonny-ide","title":"Thonny IDE","text":"<p>An integrated development environment optimized for MicroPython programming.</p> <p>Example: Using Thonny to upload code and debug timing issues.</p>"},{"location":"glossary/#time-module","title":"Time Module","text":"<p>MicroPython library for handling time-related operations.</p> <p>Example: Using scheduling functions for regular updates.</p>"},{"location":"glossary/#time-synchronization","title":"Time Synchronization","text":"<p>Process of updating device time from an accurate external source.</p> <p>Example: Getting current time from network time servers.</p>"},{"location":"glossary/#time-zone","title":"Time Zone","text":"<p>A region that observes a uniform standard time.</p> <p>Example: Converting between local time and UTC.</p>"},{"location":"glossary/#time-based-tasks-with-uasyncio","title":"Time-Based Tasks with uasyncio","text":"<p>Scheduling and managing time-dependent operations using MicroPython's asynchronous I/O framework.</p> <p>Example: Updating multiple display elements at different intervals without blocking.</p>"},{"location":"glossary/#timer","title":"Timer","text":"<p>A system resource that generates regular time-based events.</p> <p>Example: Creating precise one-second update intervals.</p>"},{"location":"glossary/#timer-based-events","title":"Timer-Based Events","text":"<p>Actions triggered by internal timing mechanisms.</p> <p>Example: Updating display elements at specific intervals.</p>"},{"location":"glossary/#ultra-low-power","title":"Ultra-Low Power","text":"<p>Operating modes and techniques that minimize energy consumption.</p> <p>Example: Using sleep modes and efficient screen updates.</p>"},{"location":"glossary/#usb-power","title":"USB Power","text":"<p>A 5-volt power source available through Universal Serial Bus connections, commonly used for powering small electronic projects.</p>"},{"location":"glossary/#using-16-bits-to-represent-color","title":"Using 16 Bits to Represent Color","text":"<p>A color depth specification that allocates 16 bits per pixel, typically with 5 bits for red, 6 for green, and 5 for blue (RGB565 format).</p> <p>Example: Converting RGB colors to 16-bit format for efficient storage and display.</p>"},{"location":"glossary/#utc","title":"UTC","text":"<p>Coordinated Universal Time, the primary time standard for global time coordination.</p> <p>Example: Converting local time to UTC for synchronization.</p>"},{"location":"glossary/#wake-on-alarm","title":"Wake on Alarm","text":"<p>Feature that activates the device from sleep mode at specific times.</p> <p>Example: Waking the display for scheduled notifications.</p>"},{"location":"glossary/#watch-face-design","title":"Watch Face Design","text":"<p>Principles and techniques for creating visually appealing and functional clock displays.</p> <p>Example: Balancing aesthetics and readability in analog and digital layouts.</p>"},{"location":"glossary/#watchdog-timer","title":"Watchdog Timer","text":"<p>A hardware feature that resets the system if the program stops responding.</p> <p>Example: Ensuring reliability in long-running clock applications.</p>"},{"location":"glossary/#weather-updates","title":"Weather Updates","text":"<p>Real-time environmental data obtained through internet services.</p> <p>Example: Displaying current conditions alongside time.</p>"},{"location":"glossary/#web-services","title":"Web Services","text":"<p>Online resources that provide data or functionality through standard internet protocols.</p> <p>Example: Fetching current time from an internet time server for clock synchronization.</p>"},{"location":"glossary/#wi-fi-module","title":"Wi-Fi Module","text":"<p>Hardware that enables wireless network connectivity.</p> <p>Example: Connecting to the internet for time synchronization.</p>"},{"location":"glossary/#wifibased-weather-updates","title":"Wi\u2011Fi\u2013Based Weather Updates","text":"<p>Retrieving and displaying current weather conditions using wireless internet connectivity.</p> <p>Example: Fetching temperature, humidity, and forecast data from online weather services.</p>"},{"location":"glossary/#world-clock","title":"World Clock","text":"<p>A timepiece that displays times for multiple time zones simultaneously.</p> <p>Example: Showing local time alongside other major cities' times.</p>"},{"location":"references/","title":"References","text":"<ol> <li>watchmaker - custom watch faces</li> <li>Makerfabs GC9A01 1.28 Inch Round LCD Module </li> <li>Dronebotworkshop Using GC9A01 Round LCD Modules</li> <li>DroneBot Workshop YouTube Video</li> <li>Mr. Volt YouTube Exotic Round Displays and How to Use Them  - this videos demonstrates some very new round displays up to 5 inches.  These would be ideal for robot faces but they cost up to $200 for the larger displays.</li> <li>NTP Pool Project - sites that run the network time protocol</li> <li>Pico Displays and Fonts</li> <li>Analog Clock Face Generator - a wonderful way to try out different designs.  This web app allows you to change the format of the markers, digits and hands.</li> <li>Blocklayer Clock Face</li> <li>Mick Make's YouTube Video: Build a talking Alarm Clock synced to Google calendars - great example of how to use the Google API to access your personal calendar.</li> </ol>"},{"location":"references/#inspirational-electronic-clocks","title":"Inspirational Electronic Clocks","text":"<ul> <li> <p>Simple Pico Clock</p> </li> <li> <p>PicoClock - RPI PICO Multifunctional Digital Clock</p> </li> <li> <p>Raspberry Pi Pico W Fibonacci Clock Project - YouTube Video</p> </li> <li> <p>\"The Clock\" using 1,916 parts by Gislain Benoit</p> </li> <li> <p>Divoom Times Gate Clock - Five 128x128 color LCD displays.</p> </li> <li> <p>ClocTech Tube Shaped Nixie Clock available for $49 at WalMart.  This clock shines an LED into a Plexiglass plate to give the appearance of a 3D Nixie Tube.</p> </li> <li> <p>Single Digit Clock with 7 Servos</p> </li> </ul>"},{"location":"references/#data-sheets","title":"Data Sheets","text":""},{"location":"references/#battery-management","title":"Battery Management","text":"<p>[HT4928S - T6845C Data sheet][https://components101.com/sites/default/files/component_datasheet/T6845C-Datasheet.pdf] 8 pin battery management Chip</p> <p>https://www.youtube.com/watch?v=np4NRMKOG6U</p>"},{"location":"kits/","title":"Introduction to Clock and Watch Project and Kits","text":"<p>We have grouped information on specific projects together in structures that allow you to find what you are looking for and customize both the hardware and software.  We focus on using generative AI tools to customize the code to accelerate your development an enhance your understanding of how each project works.</p>"},{"location":"kits/#project-structure","title":"Project Structure","text":"<p>Each kit has the following structure:</p>"},{"location":"kits/#1-introduction","title":"1. Introduction","text":"<p>A brief overview of the project including a image of the clock, key features, approximate costs and possible variations.</p>"},{"location":"kits/#2-purchasing-and-assembly","title":"2. Purchasing and Assembly","text":"<p>This section shows how to purchase and assemble the clock.  Most of the clocks require at a minimum a Raspberry Pi Pico (\\(4), a breadboard (\\)2) and a display.  In addition you might add one or more of the following items:</p> <ol> <li>A real-time clock with a coin-cell battery backup to remember the time between power resets.</li> <li>Buttons to manually set the date and time.</li> <li>A wireless Pico W to allow your clock to connect to the internet.</li> <li>A speaker for alarms.</li> <li>A photodetector for detecting the lighting conditions.</li> <li>Additional controls such as a knob for adjusting the time.</li> </ol> <p>Since these features can be used in combination, we also provide you with generative AI prompts to customize the code to run these clocks and watches</p>"},{"location":"kits/#3-code","title":"3. Code","text":"<p>This kit section provides you with a  walkthrough of the core pa project has a brief overview of the project, a separate page for the physical assembly of the clock and a detailed guide to program the clock.  The documentation may also have sample generative AI prompts you can use to generate your own code using a tool such as OpenAI's ChatGPT or Anthropic Claude.  In general, the more precise your prompt is, the higher the odds that the code generated will be correct.</p> <p>Each project also has separate folder in the GitHub \"src/kits\" folder.  The running clock programs (called the \"mains\") come in several variations.  One uses manual buttons (main-buttons.py) to set the time after a power outage.  The other version called the \"main-rtc.py\" file name uses a real-time-clock to remember the time between power outages.  They require an additional RTC clock that uses a coin-cell battery to hold the current time.  If you find a \"main-w.py\" file that uses the secrets.py file to lookup your local wifi login to get the time from the internet.  These versions don't need buttons or a RTC to get the correct time. They only need internet access.</p>"},{"location":"kits/#4-generative-ai-prompts","title":"4. Generative AI Prompts","text":""},{"location":"kits/#led-clocks","title":"LED Clocks","text":""},{"location":"kits/#standard-tm1637-led-clock","title":"Standard TM1637 LED Clock","text":"<p>This is a great starter clock.  The display is low-cost ($1-2), and it only requires four wires to connect it up. It is easy to program LED clock with 4 7-segment displays.</p> <p>TM1637 LED Clock Kit</p>"},{"location":"kits/#tinyssd1306-oled-with-an-i2c-interface","title":"TinySSD1306 OLED with an I2C Interface","text":"<p>This small low-cost OLED display is easy to hook up with just 4 wires. The combination of low-cost and easy hookup makes it an ideal starter project.</p> <p>We hav purchased these OLEDs on eBay for under $4 each.  Some of they have the first 20 rows yellow and the remaining 44 rows blue.</p> <p>Tiny SSD1306 OLED with I2C Interface</p>"},{"location":"kits/#larger-242-oled-ssd1306-with-spi-interface","title":"Larger 2.42\" OLED SSD1306 with SPI Interface","text":"<p>Larger OLED</p>"},{"location":"kits/#neopixel-clocks","title":"NeoPixel Clocks","text":""},{"location":"kits/#binary-clock","title":"Binary Clock","text":"<p>Binary Clock</p>"},{"location":"kits/#seven-segment-clock","title":"Seven Segment Clock","text":""},{"location":"kits/#fibonacci-clock","title":"Fibonacci Clock","text":"<p>Fibonacci Clock</p>"},{"location":"kits/#lilygo-rp2040","title":"LilyGo RP2040","text":"<p>LilyGo RP2040 Kit</p>"},{"location":"kits/#smartwatch-displays","title":"SmartWatch Displays","text":"<p>GC9a01 Smartwatch Display</p> <p>Waveshare LCD Smartwatch Display</p>"},{"location":"kits/#e-paper-clocks","title":"E-Paper Clocks","text":"<p>Waveshare e-Paper</p>"},{"location":"kits/gallery/","title":"Gallery of Clock and Watch Projects","text":"<ul> <li>TM1637 LED Clock</li> <li>Character LCD Clock</li> <li>NeoPixel Binary Clock</li> <li>NeoPixel Seven Segment Clock</li> <li>OLED SSD1306 I2C Clock</li> <li>OLED SH1106 Clock</li> <li>ST7735 Color LCD Clock</li> <li>Large SSD1306 OLED Clock</li> <li>Stopwatch</li> <li>Wireless Clock</li> <li>ILI9341</li> <li>GC9a01 Smartwatch Display</li> <li>EPaper Display Clock (TBD)</li> <li>NeoPixel Fibonacci-clock (TBD)</li> <li>Shift Register Clocks (TBD)</li> <li>Alarm Clock(TBD)</li> </ul>"},{"location":"kits/alarm-clock/","title":"Alarm Clocks","text":"<p>Many changeling features requires attention to detail. Setting requires thoughtfulness of features.</p>"},{"location":"kits/alarm-clock/#using-buttons","title":"Using Buttons","text":"<ul> <li>Set button</li> <li>Increment button</li> <li>Decrement button</li> <li>Hold to move faster</li> <li>Displaying the alarm set icon</li> <li>Doze button - add 10 minutes and restart</li> <li>Stop alarm </li> </ul>"},{"location":"kits/alarm-clock/#setting-an-alarm","title":"Setting an Alarm","text":""},{"location":"kits/alarm-clock/#modes","title":"Modes","text":"<p>The Set Button</p>"},{"location":"kits/alarm-clock/#set-menu","title":"Set Menu","text":"<ul> <li>Set Alarm</li> <li>Set Time</li> </ul>"},{"location":"kits/alarm-clock/#set-alarm","title":"Set Alarm","text":"<ul> <li>Blinking Hour Digit</li> <li>Blinking Minute Digit</li> <li>Blinking AM/PM</li> </ul>"},{"location":"kits/alarm-clock/#stop-alarm","title":"Stop Alarm","text":""},{"location":"kits/alarm-clock/#doze-button","title":"Doze Button","text":""},{"location":"kits/alarm-clock/#multiple-alarms","title":"Multiple Alarms","text":""},{"location":"kits/alarm-clock/#multiple-tones","title":"Multiple Tones","text":""},{"location":"kits/alarm-clock/#custom-wake-music","title":"Custom Wake Music","text":""},{"location":"kits/alarm-clock/display-alarm-icon/","title":"Display Alarm Icon","text":"<pre><code>from array import array\n\ndef draw_alarm_icon(display, x, y, alarm_hour, alarm_minute, size=24):\n    \"\"\"\n    Draw an alarm bell icon with time display using polygons.\n\n    Args:\n        display: SSD1306 display instance\n        x, y: Top-left position for the icon\n        alarm_hour: Hour of the alarm (1-12)\n        alarm_minute: Minute of the alarm (0-59)\n        size: Base size of the icon (default 24 pixels)\n    \"\"\"\n    # Scale factors\n    scale = size / 24  # Base size is 24 pixels\n\n    # Bell body coordinates (scaled from base design)\n    bell_body = array('B', [\n        int(4 * scale),  int(0 * scale),    # Top left of dome\n        int(20 * scale), int(0 * scale),    # Top right of dome\n        int(24 * scale), int(12 * scale),   # Bottom right curve\n        int(22 * scale), int(18 * scale),   # Right side\n        int(2 * scale),  int(18 * scale),   # Left side\n        int(0 * scale),  int(12 * scale),   # Bottom left curve\n    ])\n\n    # Bell base coordinates\n    bell_base = array('B', [\n        int(2 * scale),  int(18 * scale),   # Top left\n        int(22 * scale), int(18 * scale),   # Top right\n        int(20 * scale), int(20 * scale),   # Bottom right\n        int(4 * scale),  int(20 * scale),   # Bottom left\n    ])\n\n    # Clapper coordinates\n    clapper = array('B', [\n        int(11 * scale), int(20 * scale),   # Top\n        int(13 * scale), int(20 * scale),   # Top right\n        int(14 * scale), int(24 * scale),   # Bottom right\n        int(10 * scale), int(24 * scale),   # Bottom left\n    ])\n\n    # Sound wave lines (using array for consistency)\n    left_wave = array('B', [\n        int(0 * scale),  int(12 * scale),\n        int(-3 * scale), int(12 * scale),\n        int(-4 * scale), int(14 * scale),\n        int(-3 * scale), int(16 * scale),\n    ])\n\n    right_wave = array('B', [\n        int(24 * scale), int(12 * scale),\n        int(27 * scale), int(12 * scale),\n        int(28 * scale), int(14 * scale),\n        int(27 * scale), int(16 * scale),\n    ])\n\n    # Draw the components\n    display.poly(x, y, bell_body, 1, 1)  # Filled bell body\n    display.poly(x, y, bell_base, 1, 1)  # Filled bell base\n    display.poly(x, y, clapper, 1, 1)    # Filled clapper\n\n    # Draw the sound waves\n    if size &gt;= 20:  # Only draw waves if icon is large enough\n        display.poly(x, y, left_wave, 1, 0)   # Left sound wave\n        display.poly(x, y, right_wave, 1, 0)  # Right sound wave\n\n    # Draw the alarm time below the bell\n    time_str = f\"{alarm_hour:2d}:{alarm_minute:02d}\"\n    # Center the time string under the bell\n    text_x = x + (int(24 * scale) - len(time_str) * 6) // 2\n    text_y = y + int(26 * scale)\n    display.text(time_str, text_x, text_y, 1)\n\ndef demo_alarm_icons(display):\n    \"\"\"\n    Demonstrate the alarm icon at different sizes and positions\n    \"\"\"\n    # Clear the display\n    display.fill(0)\n\n    # Draw three different sized bells\n    draw_alarm_icon(display, 0, 0, 7, 30, size=20)    # Small bell\n    draw_alarm_icon(display, 35, 0, 8, 15, size=28)   # Medium bell\n    draw_alarm_icon(display, 80, 0, 6, 45, size=36)   # Large bell\n\n    # Update the display\n    display.show()\n\n# Example usage:\n\"\"\"\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\ndemo_alarm_icons(oled)\n\"\"\"\n</code></pre>"},{"location":"kits/char-lcd-clock/","title":"Character LCD Clock","text":"<p>The LCD1602 is a low cost ($5) character LCD display with 16 characters in two rows.  They frequently come with an I2C interface.  In this kit we combine this display with a real-time clock chip to create a clock that will display the date, time and temperature </p> <p></p>"},{"location":"kits/char-lcd-clock/#i2c-scanner","title":"I2C Scanner","text":"<p>In our kit, we put the I2C data pins on GPIO 0 (row 1 of the breadboard) and we put the I2C clock pin on GPIO 1 (row 2 of the breadboard).</p> <p>When we run the I2C scanner we should be able to see the address of the LCD display and the real-time clock.</p> <p>Here is the I2C scanner code:</p> <pre><code>import machine\nI2C_SDA_PIN = 0\nI2C_SCL_PIN = 1\ni2c=machine.I2C(0,sda=machine.Pin(I2C_SDA_PIN), scl=machine.Pin(I2C_SCL_PIN), freq=400000)\n\nprint('Scanning I2C bus.')\ndevices = i2c.scan() # this returns a list of devices\ndevice_count = len(devices)\nif device_count == 0:\n    print('No i2c device found.')\nelse:\n    print(device_count, 'devices found.')\nfor device in devices:\n    print('Decimal address:', device, \", Hex address: \", hex(device))\n</code></pre>"},{"location":"kits/char-lcd-clock/#lcd1602-micropython-libraries","title":"LCD1602 MicroPython Libraries","text":"<p>Because the LCD1602 is a common display, there are several LCD1602 libraries.  Many of the share a common interface language.</p> <p>Here is how we initialize the LCD driver</p> <pre><code>I2C_ADDR     = 0x27\nI2C_NUM_ROWS = 2\nI2C_NUM_COLS = 16\n\ni2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400000)\nlcd = I2cLcd(i2c, I2C_ADDR, I2C_NUM_ROWS, I2C_NUM_COLS)\n</code></pre>"},{"location":"kits/char-lcd-clock/#sample-clock-program","title":"Sample Clock Program","text":"<pre><code>from machine import I2C, Pin\nfrom lcd_api import LcdApi\nfrom pico_i2c_lcd import I2cLcd\nfrom utime import sleep, localtime\n\nI2C_ADDR     = 0x27\nI2C_NUM_ROWS = 2\nI2C_NUM_COLS = 16\n\ni2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400000)\nlcd = I2cLcd(i2c, I2C_ADDR, I2C_NUM_ROWS, I2C_NUM_COLS)\n\nwhile True:\n    # Clear the display before writing new content\n    lcd.clear()\n\n    # change this line to read the RTC time\n    now = localtime()\n    year = now[0]\n    month = now[1]\n    day = now[2]\n    hour = now[3]\n    minute = now[4]\n    second = now[5]\n\n    if hour == 0:\n        # Midnight edge case\n        hour = 12\n        am_pm = 'AM'\n    elif hour == 12:\n        # Noon edge case\n        am_pm = 'PM'\n    elif hour &gt; 12:\n        # Afternoon hours\n        hour -= 12\n        am_pm = 'PM'\n    else:\n        # Morning hours\n        am_pm = 'AM'\n\n    # Format date on first row - centered\n    date_str = f\"{month:02d}/{day:02d}/{year}\"\n    lcd.move_to((16 - len(date_str)) // 2, 0)  # Center the date\n    lcd.putstr(date_str)\n\n    # Format time on second row with seconds\n    time_str = f\"{hour}:{minute:02d}:{second:02d} {am_pm}\"\n    lcd.move_to((16 - len(time_str)) // 2, 1)  # Center the time\n    lcd.putstr(time_str)\n\n    sleep(1)\n</code></pre>"},{"location":"kits/char-lcd-clock/#purchasing","title":"Purchasing","text":"<p>I recommend getting the version with the </p> <p>eBay Listing with I2c Backpack</p>"},{"location":"kits/char-lcd-clock/#references","title":"References","text":"<p>eBay Search for 16X3 LCD Display I2C</p>"},{"location":"kits/e-paper/","title":"E-Ink Displays","text":"<p>Prompt</p> <p>Please suggest a low-cost e-ink display that has strong support for a microPython driver.</p> <p>ChatGPT</p> <p>Thought about e-ink display and MicroPython for 5 seconds</p> <p>If you're looking for a budget-friendly e-ink module that's well-documented and easy to use in MicroPython projects, a great place to start is with the smaller Waveshare e-Paper displays. Specifically, the Waveshare 1.54-inch e-Paper module is often cited for its low cost and good MicroPython support. Here are some details:</p>"},{"location":"kits/e-paper/#chatgpt-response","title":"ChatGPT Response","text":"<p>1) Waveshare 1.54-inch e-Paper Module</p> <p>Why it's a good pick</p> <ul> <li>Affordability: Often in the \\(15--\\)25 range, depending on where you purchase.</li> <li>MicroPython libraries: Strong community support and official Waveshare repositories on GitHub. There are also third-party MicroPython drivers floating around that make it easier to integrate.</li> <li>Multiple variants: You can find \"red/black/white\" or \"black/white\" only variants. The simpler (black/white) ones tend to be cheaper.</li> <li>Low power consumption: Typical for e-ink, so it's great for battery-powered projects.</li> </ul> <p>Where to find drivers</p> <ul> <li>Waveshare's official GitHub has examples in C, Arduino, and sometimes MicroPython.</li> <li>Look for community forks or repos titled similarly to <code>micropython-waveshare-epaper</code> (there are a few) for more up-to-date drivers.</li> </ul> <p>Key specs</p> <ul> <li>Resolution: ~200 \u00d7 200 pixels (for the 1.54\" black/white version)</li> <li>Interfaces: SPI, typically 3.3 V (works well with ESP8266, ESP32, etc.)</li> <li>Refresh time: ~2 seconds for a full refresh; partial refresh also possible on some models.</li> </ul>"},{"location":"kits/e-paper/#2-waveshare-213-inch-e-paper-slightly-larger-option","title":"2) Waveshare 2.13-inch e-Paper (Slightly Larger Option)","text":"<p>If you need a bit more display real estate, the 2.13-inch Waveshare e-Paper module is another solid choice. It's still relatively low cost (somewhere around \\(25--\\)30) but gives you higher resolution (around 250 \u00d7 122 or 212 \u00d7 104, depending on the version) for more text or small graphics.</p> <ul> <li>Strong MicroPython support (similarly to the 1.54-inch).</li> <li>Typically uses the same library approach from Waveshare, so upgrading the size is straightforward.</li> </ul>"},{"location":"kits/e-paper/#3-lilygo-t5-series-all-in-one-board","title":"3) LilyGo T5 Series (All-in-One Board)","text":"<p>Another cost-effective route (if you don't mind an all-in-one solution rather than a separate module) is the LilyGo T5 board series. These boards come with an ESP32 already integrated and a small e-ink display (like 1.54\", 2.13\", 2.7\", 4.7\" versions).</p> <ul> <li>Pros:<ul> <li>ESP32 + e-ink combined in one board</li> <li>Some have built-in battery circuitry</li> <li>Often includes MicroPython support or ready-to-flash firmware</li> </ul> </li> <li>Cons:<ul> <li>Slightly more expensive than just a raw display</li> <li>Tied to LilyGo's board layout and pins</li> </ul> </li> </ul> <p>If you already have a microcontroller board and want to keep costs low, a stand-alone Waveshare display will likely be cheaper. However, if you're starting from scratch, the LilyGo T5 might save you some setup time (fewer wiring hassles, etc.).</p>"},{"location":"kits/e-paper/#summary","title":"Summary","text":"<ul> <li> <p>Best Overall Low-Cost:     Waveshare 1.54-inch e-Paper module. It's consistently among the cheapest e-ink modules, with decent resolution for text/graphics and ample MicroPython support from both the official Waveshare examples and the community.</p> </li> <li> <p>Slightly Larger Screen:     Waveshare 2.13-inch e-Paper offers more room but at a slightly higher price.</p> </li> <li> <p>All-in-One Alternative:     LilyGo T5 boards combine an ESP32 and e-ink, and often come with MicroPython pre-installed or easily flashed.</p> </li> </ul> <p>All of these displays have active communities, plenty of tutorials, and code examples you can adapt for MicroPython, making them a great fit if you're just getting started with e-ink in your microcontroller projects.</p> <p>o1</p>"},{"location":"kits/gc9a01/","title":"GC9A01 Display","text":"<p>The gc9a01 is a chip that drives a 240x240 round display that is connected to a microcontroller by an SPI display.</p> <p>The current gc9a01 drivers are not compatable with the current release of framebuf in the standard MicroPython runtime.  Therefore the standard framebuf functions such as <code>ellipse()</code> and <code>poly()</code> functions do not work.  This limits the portability of many of or clock and watch example.</p> <p>The good news is that you can do some drawing operations faster and your code does not have to run the <code>show()</code> command.  Functions such as <code>line()</code> will draw directly to the display.</p> <p>To connect we need to either use a firmware version or load the driver into the /lib directory and we can then use the following code:</p> <pre><code>from machine import Pin, SPI\nimport gc9a01 as gc9a01\n\n# hardware config\nSCL_PIN = 2\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\nRST_PIN = 6\nspi = SPI(0, baudrate=60000000, sck=Pin(SCL_PIN), mosi=Pin(SDA_PIN))\n\n# initialize the display\ntft = gc9a01.GC9A01(\n    spi,\n    dc=Pin(DC_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT),\n    reset=Pin(RST_PIN, Pin.OUT),\n    rotation=0)\n\ntft.fill(gc9a01.BLACK)\n\n# x, y, width, height\n# red\ntft.fill_rect(50,  75, 50, 60, gc9a01.color565(255,0,0))\n# green\ntft.fill_rect(100, 75, 50, 60, gc9a01.color565(0,255,0))\n# blue\ntft.fill_rect(150, 75, 50, 60, gc9a01.color565(0,0,255))\n</code></pre>"},{"location":"kits/gc9a01/#rotation","title":"Rotation","text":"<p>The driver supports 8 different types of rotations:</p> <ul> <li>0 - PORTRAIT</li> <li>1 - LANDSCAPE</li> <li>2 - INVERTED PORTRAIT</li> <li>3 - INVERTED LANDSCAPE</li> <li>4 - PORTRAIT MIRRORED</li> <li>5 - LANDSCAPE MIRRORED</li> <li>6 - INVERTED PORTRAIT MIRRORED</li> <li>7 - INVERTED LANDSCAPE MIRRORED</li> </ul> <p>In our labs we have the connector at the bottom so we use the Portrait rotation of 0 which is the default rotation.</p>"},{"location":"kits/gc9a01/#references","title":"References","text":"<ol> <li>Russ Hughes - Russ provides firmware images that you can use for both the Pico and Pico W.<ol> <li>Raspberry Pi Pico</li> <li>Raspberry Pi Pico W</li> </ol> </li> </ol>"},{"location":"kits/gc9a01/01-hello-world/","title":"Hello World Test","text":"<p>We begin by carefully setting up the 7 wires that connect from the gc9a01 graphics controller to the breadboard that we have our Raspberry Pi Pico W connected.</p> <pre><code># 01-hello-world-firmware.py\n# \nfrom machine import Pin, SPI\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\ntft.init()\ntft.fill(0) # fill the screen with black\ntft.text(font, \"Hello world!\", 20, 100, gc9a01.color565(255,0,0), gc9a01.color565(0,0,255))\n</code></pre>"},{"location":"kits/gc9a01/02-display-time/","title":"Display Time and Date","text":"<p>Here is a program that will display the time and date including the day-of-the-week and the name of the month.</p> <p>We use the ``localtime()``` function to get the current time in an array of integers that looks like this:</p> <pre><code>(2023, 9, 30, 13, 18, 9, 5, 273)\n</code></pre> <p>The fields are:</p> <ol> <li>Year</li> <li>Month</li> <li>Day of Month</li> <li>Hour in 24-hour format</li> <li>Minutes</li> <li>Seconds</li> <li>Day of Week (Monday = 0, Sunday = 6)</li> <li>Day of the Year</li> </ol> <p>We could convert each of these numbers to strings and display them. However, most people like to do a bit of formatting such as displaing a 12-hour am/pm format and returning the name of the month and day of the week.  Here is the complete progam with the formatting.</p> <pre><code># 02-display-time.py\n# \nfrom machine import Pin, SPI\nfrom utime import sleep, localtime\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\ntft.init()\ntft.fill(0) # fill the screen with black\n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\n# I limit the month names to 5 characters max\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef day_of_week(now):\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    return day_name\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {}, {}\".format(month_name, now[2], now[0])\n\ntft.fill(0) # erase the screen to black\nwhite = gc9a01.color565(255, 255, 255)\nwhile(True):\n    # get the time from the local real-time clock\n    now = localtime()\n    print(now)    \n    tft.text(font, format_time(now), 35, 50, white)\n    tft.text(font, day_of_week(now), 50, 80, white)\n    tft.text(font, format_date(now), 5, 110, white)\n    #tft.show()\n    sleep(1)\n</code></pre>"},{"location":"kits/gc9a01/03-display-hand/","title":"Display Second Hand","text":"<p>In this lesson we will use a bit of trigonometry to display a second hand that ticks every second.</p> <pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nHAND_LENGTH = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nwhite = gc9a01.color565(255, 255, 255)\n\nwhile True:\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    print(radians, x, y)\n    tft.fill(0)\n    tft.line(CENTER, CENTER, CENTER+x,CENTER+y, white)\n    sleep(1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre>"},{"location":"kits/gc9a01/04-cycle-fonts/","title":"Cycle Through the Builtin Fonts","text":"<p>This program will cycle through the built-in fonts showing greetings in different fonts, langauges and colors.</p> <pre><code># Adapted from the hersey.py program\nfrom machine import Pin, SPI\nfrom utime import sleep, localtime\nimport random\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0)\n\n# Load several frozen fonts from flash\n\nimport greeks\nimport italicc\nimport italiccs\nimport meteo\nimport romanc\nimport romancs\nimport romand\nimport romanp\nimport romans\nimport scriptc\nimport scripts\n\n\ndef cycle(p):\n    '''\n    return the next item in a list\n    '''\n    try:\n        len(p)\n    except TypeError:\n        cache = []\n        for i in p:\n            yield i\n            cache.append(i)\n        p = cache\n    while p:\n        yield from p\n\n\nCOLORS = cycle([0xe000, 0xece0, 0xe7e0, 0x5e0, 0x00d3, 0x7030])\n\nFONTS = cycle([\n    greeks, italicc, italiccs, meteo, romanc, romancs,\n    romand, romanp, romans, scriptc, scripts])\n\nGREETINGS = cycle([\n    \"bonjour\", \"buenas noches\", \"buenos dias\",\n    \"good day\", \"good morning\", \"hey\",\n    \"hi-ya\", \"hi\", \"how are you\", \"how goes it\",\n    \"howdy-do\", \"howdy\", \"shalom\", \"welcome\",\n    \"what's happening\", \"what's up\"])\n\ntft.init()\nrow = 120\n\nwhile True:\n    color = next(COLORS)\n    tft.fill(gc9a01.BLACK)\n    tft.draw(next(FONTS), next(GREETINGS), 0, row, color)\n    sleep(0.5)\n</code></pre>"},{"location":"kits/gc9a01/04-cycle-fonts/#references","title":"References","text":"<ol> <li>Russ Hughes Example</li> </ol>"},{"location":"kits/gc9a01/05-draw-ticks/","title":"Draw Clock Face Ticks","text":"<p>This program draws 12 short white radial lines around a watch face.</p> <p></p> <p>We use the same math we used to draw a single hand.  However, in this example we just need to iterate through a range of 0 to 12.</p> <pre><code>for i in range(0,12):\n    radians = (i/12)*TWO_PI\n    x1 = int(math.sin(radians)*TICK_START)\n    y1 = -int(math.cos(radians)*TICK_START)\n    x2 = int(math.sin(radians)*TICK_END)\n    y2 = -int(math.cos(radians)*TICK_END)\n    tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, WHITE)\n</code></pre> <p>Instead of just drawing from the center to a point at (x,y), we need to calculate four numbers.  These are the start and ending points of each tick.</p>"},{"location":"kits/gc9a01/05-draw-ticks/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nTICK_START = 80\nTICK_END = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nWHITE = gc9a01.color565(255, 255, 255)\nBLACK = gc9a01.color565(0, 0, 0)\ntft.fill(BLACK)\nfor i in range(0,12):\n    radians = (i/12)*TWO_PI\n    x1 = int(math.sin(radians)*TICK_START)\n    y1 = -int(math.cos(radians)*TICK_START)\n    x2 = int(math.sin(radians)*TICK_END)\n    y2 = -int(math.cos(radians)*TICK_END)\n    print(i, radians, x1, y1, x2, y2)  \n    tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, WHITE)\n</code></pre>"},{"location":"kits/gc9a01/07-draw-12-digits/","title":"Draw Clock Dial Digits","text":"<p>This program builds on the previous progam that draws the ticks. It also draws a ditit at the end of each tick.</p> <p></p> <p>We use the same math we used to draw a single hand.  However, in this example we just need to iterate through a range of 0 to 12.</p> <p>We have to remember to load our 16x32 fonts.  Although this is a bit large for most watch faces, they are easy to read.</p> <p>Here is the line we added: <pre><code>import vga1_bold_16x32 as font\n</code></pre></p> <p>Note that there are other sizes we can use.  A list of the other fonts is here:</p> <p>GitHub Site for Russ Hughes for GC9a01 bitmap fonts</p> <p>These fonts include the following sizes:</p> <ol> <li>8x8</li> <li>8x16</li> <li>16x16</li> <li>16x32</li> </ol> <p>Here is the appropriate line for the normal 16x16:</p> <pre><code>import vga1_16x16 as font\n</code></pre> <p><pre><code>if i == 0:\n    num_str = \"12\"\nelse:\n    num_str = str(i)\ntft.text(font, num_str, CENTER+x3-8, CENTER+y3-16, WHITE)\n</code></pre> Note because the fonts are 16 wide and 32 high we move 8 to the left and 16 up.</p>"},{"location":"kits/gc9a01/07-draw-12-digits/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nTICK_START = 50\nTICK_END = 80\nNUM_POS = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nWHITE = gc9a01.color565(255, 255, 255)\nBLACK = gc9a01.color565(0, 0, 0)\nBLUE = gc9a01.color565(0, 0, 255)\ntft.fill(BLACK)\nfor i in range(0,12):\n    radians = (i/12)*TWO_PI\n    x1 = int(math.sin(radians)*TICK_START)\n    y1 = -int(math.cos(radians)*TICK_START)\n    x2 = int(math.sin(radians)*TICK_END)\n    y2 = -int(math.cos(radians)*TICK_END)\n    x3 = int(math.sin(radians)*NUM_POS)\n    y3 = -int(math.cos(radians)*NUM_POS)\n    print(i, radians, x1, y1, x2, y2)  \n    tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, BLUE)\n    if i == 0:\n        num_str = \"12\"\n    else:\n        num_str = str(i)\n    tft.text(font, num_str, CENTER+x3-8, CENTER+y3-16, WHITE)\n</code></pre> <p>If you use the 16x16 font the offset in the last line are:</p> <pre><code>    if i == 0:\n        num_str = \"12\"\n        xOffest = 16\n    else:\n        num_str = str(i)\n        xOffest = 8\n    tft.text(font, num_str, CENTER+x3-xOffest, CENTER+y3-8, WHITE)\n</code></pre> <p>The exception is for the \"12\" at the top of the dial.  The \"12\" needed to be exactly centered above the top tick mark.</p> <p></p>"},{"location":"kits/gc9a01/07-draw-12-digits/#full-code-for-16x16-clock-face-digits","title":"Full Code for 16x16 Clock Face Digits","text":"<pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\nimport vga1_16x16 as font\n\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nTICK_START = 70\nTICK_END = 100\nNUM_POS = 111\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nWHITE = gc9a01.color565(255, 255, 255)\nBLACK = gc9a01.color565(0, 0, 0)\nBLUE = gc9a01.color565(0, 0, 255)\ntft.fill(BLACK)\nfor i in range(0,12):\n    radians = (i/12)*TWO_PI\n    x1 = int(math.sin(radians)*TICK_START)\n    y1 = -int(math.cos(radians)*TICK_START)\n    x2 = int(math.sin(radians)*TICK_END)\n    y2 = -int(math.cos(radians)*TICK_END)\n    x3 = int(math.sin(radians)*NUM_POS)\n    y3 = -int(math.cos(radians)*NUM_POS)\n    print(i, radians, x1, y1, x2, y2)  \n    tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, BLUE)\n    if i == 0:\n        num_str = \"12\"\n        xOffest = 16\n    else:\n        num_str = str(i)\n        xOffest = 8\n    tft.text(font, num_str, CENTER+x3-xOffest, CENTER+y3-8, WHITE)\n</code></pre>"},{"location":"kits/gc9a01/08-draw-filled-triangle/","title":"Draw a Filled Triangle","text":"<p>Analog clock hands can be draw with simple lines.  But the display will be more pleasing if we use clock hands that are made of triangles.</p> <p>If the framebuf functions were supported in the driver drawing a filled triangle would be easy.  We would just put the three points in an array and call the <code>poly()</code> with a fill option.</p> <p>However, the current driver does not support the framebuf functions.  To overcome this limiation we will need to write our own function that will fill all the points in a triangle.</p> <p>Our founction must take in the three points and a color and draw the traingle.</p>"},{"location":"kits/gc9a01/08-draw-filled-triangle/#draw-filled-triangle","title":"Draw Filled Triangle","text":"<p>Without going into too much detail, here is the algorithm we will use dto draw a filled triangle. Note that only the last line does drawing using the <code>line()</code> function. You will note that it must get the points in order before the main loops run. This version also checks for divide by zero errors.</p> <pre><code>def drawFilledTriangle(x1, y1, x2, y2, x3, y3, color=WHITE):\n    def swap(x, y):\n        return y, x\n\n    # get our points in order\n    if y1 &gt; y2:\n        x1, x2 = swap(x1, x2)\n        y1, y2 = swap(y1, y2)\n    if y1 &gt; y3:\n        x1, x3 = swap(x1, x3)\n        y1, y3 = swap(y1, y3)\n    if y2 &gt; y3:\n        x2, x3 = swap(x2, x3)\n        y2, y3 = swap(y2, y3)\n\n    for y in range(y1, y3+1):\n        if y2 - y1 != 0 and y &lt; y2:\n            xa = x1 + (x2 - x1) * (y - y1) // (y2 - y1)\n        elif y3 - y1 != 0:\n            xa = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if y3 - y2 != 0 and y &gt;= y2:\n            xb = x2 + (x3 - x2) * (y - y2) // (y3 - y2)\n        elif y3 - y1 != 0:\n            xb = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if xa &gt; xb:\n            xa, xb = swap(xa, xb)\n\n        for x in range(xa, xb+1):\n            # sleep(.1)\n            tft.line(x, y, x, y, color)\n</code></pre>"},{"location":"kits/gc9a01/08-draw-filled-triangle/#full-test-program","title":"Full Test Program","text":"<p>To test our alforithm we can genrate three random points near the center of the display and then call the traingle fill on these points.  If you would like to see how the algorithm does the drawing, you can uncomment the sleep function just before the <code>tft.line()</code> above.</p> <pre><code># 01-display-test.py\n# \nfrom machine import Pin, SPI\nimport random\nimport gc9a01\nimport vga1_16x16 as font\nfrom utime import sleep\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\nWHITE = gc9a01.color565(255,255,255)\nBLUE = gc9a01.color565(0,0,255)\nBLACK = gc9a01.color565(0,0,0)\n\ntft.init()\ntft.fill(0) # fill the screen with black\ntft.text(font, \"Draw Filled Triangle Test\", 20, 10, BLUE, BLACK)\n\n\n\ndef drawFilledTriangle(x1, y1, x2, y2, x3, y3, color=WHITE):\n    def swap(x, y):\n        return y, x\n\n    if y1 &gt; y2:\n        x1, x2 = swap(x1, x2)\n        y1, y2 = swap(y1, y2)\n    if y1 &gt; y3:\n        x1, x3 = swap(x1, x3)\n        y1, y3 = swap(y1, y3)\n    if y2 &gt; y3:\n        x2, x3 = swap(x2, x3)\n        y2, y3 = swap(y2, y3)\n\n    for y in range(y1, y3+1):\n        if y2 - y1 != 0 and y &lt; y2:\n            xa = x1 + (x2 - x1) * (y - y1) // (y2 - y1)\n        elif y3 - y1 != 0:\n            xa = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if y3 - y2 != 0 and y &gt;= y2:\n            xb = x2 + (x3 - x2) * (y - y2) // (y3 - y2)\n        elif y3 - y1 != 0:\n            xb = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if xa &gt; xb:\n            xa, xb = swap(xa, xb)\n\n        for x in range(xa, xb+1):\n            tft.line(x, y, x, y, color)\n\n\nmin = 50\nmax = 150\nwhile True:\n    tft.fill(BLACK)\n    x1 = random.randint(min, max)\n    y1 = random.randint(min, max)\n    x2 = random.randint(min, max)\n    y2 = random.randint(min, max)\n    x3 = random.randint(min, max)\n    y3 = random.randint(min, max)\n    drawFilledTriangle(x1, y1, x2, y2, x3, y3, WHITE)\n    sleep(.1)\n</code></pre>"},{"location":"kits/gc9a01/08-draw-filled-triangle/#crazy-triangles","title":"Crazy Triangles","text":"<pre><code># lab 15: Filled Triangles\n# \nfrom machine import Pin, SPI\nimport random\nimport gc9a01\nimport vga1_16x16 as font\nfrom utime import sleep\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\nWHITE = gc9a01.color565(255,255,255)\nBLUE = gc9a01.color565(0,0,255)\nBLACK = gc9a01.color565(0,0,0)\n\ntft.init()\ntft.fill(0) # fill the screen with black\ntft.text(font, \"Triangles\", 57, 22, BLUE, BLACK)\n\ndef drawFilledTriangle(x1, y1, x2, y2, x3, y3, color=WHITE):\n    def swap(x, y):\n        return y, x\n\n    if y1 &gt; y2:\n        x1, x2 = swap(x1, x2)\n        y1, y2 = swap(y1, y2)\n    if y1 &gt; y3:\n        x1, x3 = swap(x1, x3)\n        y1, y3 = swap(y1, y3)\n    if y2 &gt; y3:\n        x2, x3 = swap(x2, x3)\n        y2, y3 = swap(y2, y3)\n\n    for y in range(y1, y3+1):\n        if y2 - y1 != 0 and y &lt; y2:\n            xa = x1 + (x2 - x1) * (y - y1) // (y2 - y1)\n        elif y3 - y1 != 0:\n            xa = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if y3 - y2 != 0 and y &gt;= y2:\n            xb = x2 + (x3 - x2) * (y - y2) // (y3 - y2)\n        elif y3 - y1 != 0:\n            xb = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if xa &gt; xb:\n            xa, xb = swap(xa, xb)\n\n        for x in range(xa, xb+1):\n            # for wathing the drawing\n            # sleep(.001)\n            tft.line(x, y, x, y, color)\n\nmin = 40\nmax = 220\nwhile True:\n    # tft.fill(BLACK)\n    x1 = random.randint(min, max)\n    y1 = random.randint(min, max)\n    x2 = random.randint(min, max)\n    y2 = random.randint(min, max)\n    x3 = random.randint(min, max)\n    y3 = random.randint(min, max)\n    red = random.randint(0, 255)\n    green = random.randint(0, 255)\n    blue = random.randint(0, 255)\n    color = gc9a01.color565(red,green,blue)\n    drawFilledTriangle(x1, y1, x2, y2, x3, y3, color)\n    # slow down the drawing here\n    sleep(.1)\n</code></pre>"},{"location":"kits/gc9a01/09-watch-face/","title":"Watch Face","text":"<ol> <li>Ticks</li> <li>Second hand</li> <li>Minute hand</li> <li>Hour hand</li> </ol> <pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n# A full circle is 2*Pi radians\nTWO_PI = 3.1415926*2\nWHITE = gc9a01.color565(255, 255, 255)\nBLUE = gc9a01.color565(0, 0, 255)\nGREEN = gc9a01.color565(0, 255, 0)\nPURPLE = gc9a01.color565(255, 0, 255)\nBLACK = gc9a01.color565(0, 0, 0)\ntft.fill(BLACK)\nCENTER = 120\nMIN_TICK_START = 80\nMIN_TICK_END = 98\nSEC_TICK_START = 100\nSEC_TICK_END = 120\n\ndef drawFilledTriangle(x1, y1, x2, y2, x3, y3, color=WHITE):\n    def swap(x, y):\n        return y, x\n    if y1 &gt; y2:\n        x1, x2 = swap(x1, x2)\n        y1, y2 = swap(y1, y2)\n    if y1 &gt; y3:\n        x1, x3 = swap(x1, x3)\n        y1, y3 = swap(y1, y3)\n    if y2 &gt; y3:\n        x2, x3 = swap(x2, x3)\n        y2, y3 = swap(y2, y3)\n    for y in range(y1, y3+1):\n        if y2 - y1 != 0 and y &lt; y2:\n            xa = x1 + (x2 - x1) * (y - y1) // (y2 - y1)\n        elif y3 - y1 != 0:\n            xa = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n        if y3 - y2 != 0 and y &gt;= y2:\n            xb = x2 + (x3 - x2) * (y - y2) // (y3 - y2)\n        elif y3 - y1 != 0:\n            xb = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n        if xa &gt; xb:\n            xa, xb = swap(xa, xb)\n        for x in range(xa, xb+1):\n            tft.line(x, y, x, y, color)\n\ndef drawTicks():\n    for i in range(0,60):\n        radians = (i/60)*TWO_PI\n        x1 = int(math.sin(radians)*SEC_TICK_START)\n        y1 = -int(math.cos(radians)*SEC_TICK_START)\n        x2 = int(math.sin(radians)*SEC_TICK_END)\n        y2 = -int(math.cos(radians)*SEC_TICK_END)\n        # print(i, radians, x1, y1, x2, y2)  \n        tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, BLUE)\n\n    for i in range(0,12):\n        radians = (i/12)*TWO_PI\n        x1 = int(math.sin(radians)*MIN_TICK_START)\n        y1 = -int(math.cos(radians)*MIN_TICK_START)\n        x2 = int(math.sin(radians)*MIN_TICK_END)\n        y2 = -int(math.cos(radians)*MIN_TICK_END)\n        # print(i, radians, x1, y1, x2, y2)  \n        tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, GREEN)\n\nCENTER = 120\nSEC_HAND_LENGTH = 118\ndef drawSecondHand(sec):\n    # print('sec=', sec)\n    if sec ==0:\n        radians = 0\n    else: radians = (sec/60)*TWO_PI\n    x = int(math.sin(radians)*SEC_HAND_LENGTH)\n    y = -int(math.cos(radians)*SEC_HAND_LENGTH)\n    # print(radians, x, y)\n    tft.line(CENTER, CENTER, CENTER+x,CENTER+y, WHITE)\n    sleep(.1)\n    tft.line(CENTER, CENTER, CENTER+x,CENTER+y, BLACK)\n\n\nMIN_HAND_LENGTH = 90\nMIN_HAND_WIDTH = 5\ndef drawMinuteHand(min, color):\n    radians = (min/60)*TWO_PI\n    x1 = -int(math.cos(radians)*MIN_HAND_WIDTH)\n    y1 = -int(math.sin(radians)*MIN_HAND_WIDTH)\n    x2 = int(math.sin(radians)*MIN_HAND_LENGTH)\n    y2 = -int(math.cos(radians)*MIN_HAND_LENGTH)\n    x3 = int(math.cos(radians)*MIN_HAND_WIDTH)\n    y3 = int(math.sin(radians)*MIN_HAND_WIDTH)\n    # print('min:', x1, y1, x2, y2, x3, y3)\n    drawFilledTriangle(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, CENTER+x3, CENTER+y3, color)\n\nHOUR_HAND_LENGTH = 60\nHOUR_HAND_WIDTH = 6\ndef drawHourHand(hour, color):\n    radians = (hour/12)*TWO_PI\n    x1 = -int(math.cos(radians)*HOUR_HAND_WIDTH)\n    y1 = -int(math.sin(radians)*HOUR_HAND_WIDTH)\n    x2 = int(math.sin(radians)*HOUR_HAND_LENGTH)\n    y2 = -int(math.cos(radians)*HOUR_HAND_LENGTH)\n    x3 = int(math.cos(radians)*HOUR_HAND_WIDTH)\n    y3 = int(math.sin(radians)*HOUR_HAND_WIDTH)\n    # print('hour:', x1, y1, x2, y2, x3, y3)\n    drawFilledTriangle(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, CENTER+x3, CENTER+y3, color)\n\ncounter = 0\nmin = 58\nhour = 6\ndrawMinuteHand(min, GREEN)\ndrawHourHand(hour, PURPLE)\nhour = 6\nwhile True:\n    # this is the flicker\n    # tft.fill(BLACK)\n    drawTicks()\n\n    drawSecondHand(counter)\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        drawMinuteHand(min, BLACK)\n        counter = 0\n        min += 1\n        drawMinuteHand(min, GREEN)\n        if min &gt; 59:\n            min=0\n            drawHourHand(hour, BLACK)\n            hour += 1\n            drawHourHand(hour, PURPLE)\n            if hour &gt; 11:\n                hour = 0\n    counter += 1\n    # sleep(.5)\n</code></pre>"},{"location":"kits/ili9341/","title":"ILI9341 Display","text":"<p>The ILI9341 is a low-cost color single-chip driver for a TFT liquid crystal display with a resolution of 240x320.  </p> <p></p> <p>The board for the ILI9341 with a display costs around $9.00.  Although these displays are not a high contrast as OLED displays, they are still adequate for many clock projects that would like to draw smooth circles on a clock face.</p>"},{"location":"kits/ili9341/#driver","title":"Driver","text":"<p>dagger GitHub Repo</p>"},{"location":"kits/ili9341/#characteristics","title":"Characteristics","text":"<p>Direct write No support for standard micropython framebuf</p>"},{"location":"kits/ili9341/#sample-lesson-plan","title":"Sample Lesson Plan","text":"<p>GPT-4 Generated Lesson Plan</p>"},{"location":"kits/ili9341/#source-code","title":"Source Code","text":"<p>Source Code</p>"},{"location":"kits/ili9341/01-rainbow-test/","title":"Rainbow Test","text":"<pre><code>from ili9341 import Display, color565\nfrom machine import Pin, SPI\n\n# Use these PIN definitions.  SCK must be on 2 and data (SDL) on 3 for SPI bus 0\nSCK_PIN = 2\nMISO_PIN = 3 # labeled SDI(MOSI) on the back of the display\nDC_PIN = 4\nRESET_PIN = 5\nCS_PIN = 6\nROTATION = 90\n\nWIDTH=320\nHEIGHT=240\n\nspi = SPI(0, baudrate=40000000, sck=Pin(SCK_PIN), mosi=Pin(MISO_PIN))\ndisplay = Display(spi, dc=Pin(DC_PIN), cs=Pin(CS_PIN), rst=Pin(RESET_PIN), width=WIDTH, height=HEIGHT, rotation=ROTATION)\n\nRED = color565(255,0,0)\nORANGE = color565(255,128,0)\nYELLOW = color565(255,255,0)\nGREEN = color565(0,255,0)\nBLUE = color565(0,0,255)\nPURPLE = color565(255,0,255)\nWHITE = color565(255,255,255)\nBLACK = color565(0,0,0)\n\ndisplay.fill_rectangle(0,0, 50,HEIGHT, RED)\ndisplay.fill_rectangle(50,0, 50,HEIGHT, ORANGE)\ndisplay.fill_rectangle(100,0, 50,HEIGHT, YELLOW)\ndisplay.fill_rectangle(150,0, 50,HEIGHT, GREEN)\ndisplay.fill_rectangle(200,0, 50,HEIGHT, BLUE)\ndisplay.fill_rectangle(250,0, 50,HEIGHT, PURPLE)\ndisplay.fill_rectangle(300,0, 20,HEIGHT, WHITE)\n\nprint('Done')\n</code></pre>"},{"location":"kits/ili9341/01-rainbow-test/#color-definitions","title":"Color Definitions","text":"<p>We can also use this same process for storing all of the common constants that we duplicate in our examples.  For example all the named color defintions can be moved into a serate color-defs.py file like this:</p> <p>Sample colors.py <pre><code>from ili9341 import color565\n\nWHITE = color565(255,255,255)\nBLACK = color565(0,0,0)\nRED = color565(255,0,0)\nORANGE = color565(255,128,0)\nYELLOW = color565(255,255,0)\nGREEN = color565(0,255,0)\nBLUE = color565(0,0,255)\nCYAN = color565(0,255,255)\nPURPLE = color565(255,0,255)\n</code></pre></p> <p>This sample program imports both the config and the colors file:</p> <pre><code>from ili9341 import Display, color565\nfrom machine import Pin, SPI\nimport config\nimport colors\n\n# Use these PIN definitions.  SCK must be on 2 and data (SDL) on 3\nSCK_PIN = config.SCK_PIN\nMISO_PIN = config.MISO_PIN # labeled SDI(MOSI) on the back of the display\nDC_PIN = config.DC_PIN\nRESET_PIN = config.RESET_PIN\nCS_PIN = config.CS_PIN\n\nWIDTH=config.WIDTH\nHEIGHT=config.HEIGHT\nROTATION=config.ROTATION\n\n# mosi=Pin(23)\n# miso=Pin(MISO_PIN)\nspi = SPI(0, baudrate=40000000, sck=Pin(SCK_PIN), mosi=Pin(MISO_PIN))\ndisplay = Display(spi, dc=Pin(DC_PIN), cs=Pin(CS_PIN), rst=Pin(RESET_PIN), width=WIDTH, height=HEIGHT, rotation=ROTATION)\n\ndisplay.fill_rectangle(0,0, 50,HEIGHT, colors.RED)\ndisplay.fill_rectangle(50,0, 50,HEIGHT, colors.ORANGE)\ndisplay.fill_rectangle(100,0, 50,HEIGHT, colors.YELLOW)\ndisplay.fill_rectangle(150,0, 50,HEIGHT, colors.GREEN)\ndisplay.fill_rectangle(200,0, 50,HEIGHT, colors.BLUE)\ndisplay.fill_rectangle(250,0, 50,HEIGHT, colors.PURPLE)\ndisplay.fill_rectangle(300,0, 20,HEIGHT, colors.WHITE)\n\nprint('Done')\n</code></pre> <p>Note that the string <code>colors.</code> must appear before each color name.  You can shorten this to be just <code>c.</code> if you want to keep your code smaller and easier to read.</p>"},{"location":"kits/ili9341/01-rainbow-test/#hiding-hardware-initialization","title":"Hiding Hardware Initialization","text":"<p>We could take this one step further and put the lines that setup the SPI and the Display into a separate function.  However, in our labs we want to keep some of this code explicit so we will leave the SPI and Display initialization in our examples.</p>"},{"location":"kits/ili9341/02-config/","title":"Creating a Hardware Configuration File","text":"<p>Rather than hard-coding the pin numbers in every example, let's put all our hardware configuration data in a single file.  All the examples from here on can use that configuration data.</p>"},{"location":"kits/ili9341/02-config/#hardware-configuration-file","title":"Hardware Configuration File","text":"<pre><code># Dan's Robot Labs configuration file for ILI9341 clock project\n# The colors on the SPI bus cable are:\n# 3.3v power - red\n# SCK - orange\n# MISO/Data - yellow\n# DC - green\n# RESET - blue\n# GND - black\n# CS - purple\nSCK_PIN = 2\nMISO_PIN = 3 # labeled SDI(MOSI) on the back of the display\nDC_PIN = 4\nRESET_PIN = 5\nCS_PIN = 6\nROTATION = 90\n\nWIDTH=320\nHEIGHT=240\n</code></pre>"},{"location":"kits/ili9341/02-config/#sample-use-of-haredwre-configuration-file","title":"Sample Use of Haredwre Configuration File","text":"<pre><code># print out \"Hello World!\" using the rotation=3 using 32-bit high font\n# the default is white text on a black background\nfrom ili9341 import Display, color565\nfrom machine import Pin, SPI\nimport config\n\n# Use these PIN definitions.  SCK must be on 2 and data (SDL) on 3\nSCK_PIN = config.SCK_PIN\nMISO_PIN = config.MISO_PIN # labeled SDI(MOSI) on the back of the display\nDC_PIN = config.DC_PIN\nRESET_PIN = config.RESET_PIN\nCS_PIN = config.CS_PIN\n\nWIDTH=config.WIDTH\nHEIGHT=config.HEIGHT\nROTATION=config.ROTATION\n\n# mosi=Pin(23)\n# miso=Pin(MISO_PIN)\nspi = SPI(0, baudrate=40000000, sck=Pin(SCK_PIN), mosi=Pin(MISO_PIN))\ndisplay = Display(spi, dc=Pin(DC_PIN), cs=Pin(CS_PIN), rst=Pin(RESET_PIN), width=WIDTH, height=HEIGHT, rotation=ROTATION)\n\nRED = color565(255,0,0)\nORANGE = color565(255,128,0)\nYELLOW = color565(255,255,0)\nGREEN = color565(0,255,0)\nBLUE = color565(0,0,255)\nPURPLE = color565(255,0,255)\nWHITE = color565(255,255,255)\nBLACK = color565(0,0,0)\n\ndisplay.fill_rectangle(0,0, 50,HEIGHT, RED)\ndisplay.fill_rectangle(50,0, 50,HEIGHT, ORANGE)\ndisplay.fill_rectangle(100,0, 50,HEIGHT, YELLOW)\ndisplay.fill_rectangle(150,0, 50,HEIGHT, GREEN)\ndisplay.fill_rectangle(200,0, 50,HEIGHT, BLUE)\ndisplay.fill_rectangle(250,0, 50,HEIGHT, PURPLE)\ndisplay.fill_rectangle(300,0, 20,HEIGHT, WHITE)\n\nprint('Done')\n</code></pre>"},{"location":"kits/led-displays/","title":"LED Display Clock","text":""},{"location":"kits/led-displays/#simple-tm1637","title":"Simple TM1637","text":"<p>Simple TM1637</p>"},{"location":"kits/led-displays/#shift-register-displays","title":"Shift Register Displays","text":"<p>Shift Register Displays</p> <p></p> <p>We can use the TM1637 4-Digit LED Display Module which can be purchased on e-Bay for a few dollars.  This means that your clock will cost under $10 total.</p> <p>Sample Listing on EBay</p>"},{"location":"kits/led-displays/#hookup-instructions","title":"Hookup Instructions","text":"<p>We can hook this up to  the Raspberry Pi.</p> <p>|Name|Pin|| |5 Volts|VBUS or VSYS| |GND|Any GND Pin| |CLK|Pins 4|  |Data|Pin 5 |</p>"},{"location":"kits/led-displays/#micropython-driver","title":"MicroPython Driver","text":"<p>Mike Causer's TM1637 GitHub Driver</p>"},{"location":"kits/led-displays/#sample-code","title":"Sample Code","text":""},{"location":"kits/led-displays/#python-imports","title":"Python Imports","text":"<pre><code>import tm1637\nfrom machine import Pin\nfrom utime import sleep\ntm = tm1637.TM1637(clk=Pin(0), dio=Pin(1))\n</code></pre>"},{"location":"kits/led-displays/#test-program","title":"Test Program","text":"<pre><code>import tm1637\nfrom machine import Pin\nfrom utime import sleep\ntm = tm1637.TM1637(clk=Pin(0), dio=Pin(1))\n\nwhile True:\n    # all LEDS on \"88:88\"\n    tm.write([127, 255, 127, 127])\n    sleep(1)\n\n    # all LEDS off\n    tm.write([0, 0, 0, 0])\n    sleep(1)\n\n    # show \"0123\"\n    tm.write([63, 6, 91, 79])\n    sleep(1)\n\n    # show \"COOL\"\n    tm.write([0b00111001, 0b00111111, 0b00111111, 0b00111000])\n    sleep(1)\n\n    # show \"HELP\"\n    tm.show('help')\n    sleep(1)\n\n    # display \"dEAd\", \"bEEF\"\n    tm.hex(0xdead)\n    sleep(1)\n\n    tm.hex(0xbeef)\n    sleep(1)\n\n    # show \"12:59\"\n    tm.numbers(12, 59)\n    sleep(1)\n\n    # show \"-123\"\n    tm.number(-123)\n    sleep(1)\n\n    # show temperature '24*C'\n    tm.temperature(24)\n    sleep(1)\n</code></pre> <p>Next, will will use the <code>localtime()</code> function to build a simple clock.</p> <p>Simple Clock</p>"},{"location":"kits/led-displays/#references","title":"References","text":"<ul> <li>Mike Causer TM1637 Driver GitHub Repo</li> <li>YouTube Video by NerdCave</li> </ul>"},{"location":"kits/led-displays/clock-simple/","title":"A Simple Clock with the TM1637 LED Display","text":"<p>Here is a simple clock program that will display the hours and minutes from the localtime() function.  It will also turn the colon LEDs on and off every second using the <code>modulo</code> function to test for the even/odd property of the second.</p>"},{"location":"kits/led-displays/clock-simple/#the-localtime-function","title":"The Localtime function","text":"<pre><code># display hours and minutes on the TM1637 LED display\n# make the colon go on and off every second\nimport tm1637\nfrom machine import Pin\nfrom utime import sleep, localtime\ntm = tm1637.TM1637(clk=Pin(0), dio=Pin(1))\n\nwhile True:\n    now = localtime() # returns 8 inits for date and time\n    hours = now[3]\n    minutes = now[4]\n    seconds = now[5]\n    print(hours, \":\", minutes, ' ', seconds)\n    # flash the colon on and off every second\n    if (seconds % 2): # modulo 2 will be true for odd numbers\n        tm.numbers(hours, minutes, True)\n    else:\n        tm.numbers(hours, minutes, False)\n    sleep(1)\n</code></pre> <p>That is it!  Pretty cool that you can write an entire clock program in that few lines of code.  But it is not perfect.  Let's find some ways to make the clock work a little better.</p> <p>Note that the hours is always in 24 hour time.  If you want to  use 12 hour time you will need to subtract 12 from the hours if the hours is greater than 12.</p> <p>We can add the following lines of code to make the display better for people that use a 12-hour clock.</p> <pre><code>if hours &gt; 12:\n    hours = now[3]\n    hours = hours - 12\n</code></pre> <p>This will work, but it has the disadvantage of displaying the leading zero before the ones digit.  Unfortunately, this is the way that the <code>numbers()</code> function was written in the TM1637 module.  Let's take a look at how we can clean this up a bit.</p>"},{"location":"kits/led-displays/clock-simple/#removing-leading-zeros","title":"Removing Leading Zeros","text":"<p>In order to fix the leading zeros problem in the hours place, we need to write our own version of the <code>numbers()</code> function that changes '0' to be a space (all 7 segments off) if the hours is less than 10.</p> <p>Here is the original <code>numbers()</code> function taken directly from the driver: <pre><code>def numbers(self, num1, num2, colon=True):\n    \"\"\"Display two numeric values -9 through 99, with leading zeros\n    and separated by a colon.\"\"\"\n    num1 = max(-9, min(num1, 99))\n    num2 = max(-9, min(num2, 99))\n    segments = self.encode_string('{0:0&gt;2d}{1:0&gt;2d}'.format(num1, num2))\n    if colon:\n        segments[1] |= 0x80 # colon on\n    self.write(segments)\n</code></pre></p> <p>You can see that the author used the Python .format function to display the first number using a leading zero.  This is fine for our minutes, but not a standard for the hours.</p> <p>We will need to modify this code to put in a space character in if the hours is less than 10 and to only display the hours number without a leading zero.  The format <code>{0:0&gt;2d}</code> will be changed to be: <code>{prefix}{num1:d}</code> where:</p> <pre><code>prefix = ' ' if num1 &lt; 10 else ''\n</code></pre> <pre><code>def numbers_nlz(num1, num2, colon=True):\n    \"\"\"Display two numeric values -9 through 99, with a leading space before\n    single-digit first numbers and separated by a colon.\"\"\"\n    num1 = max(-9, min(num1, 99))\n    num2 = max(-9, min(num2, 99))\n    prefix = ' ' if num1 &lt; 10 else ''\n    print(f'\"{prefix}{num1:d}{num2:0&gt;2d}\"')\n    segments = tm.encode_string(f'{prefix}{num1:d}{num2:0&gt;2d}')\n    if colon:\n        segments[1] |= 0x80  # colon on\n    tm.write(segments)\n</code></pre> <p>Now the display will work as most normal digital clocks.</p> <p>So as long as the localtime() function is working, this clock should work fine.  An as long as your device is connected to your computer via an USB cable it will be fine.</p> <p>What if you would like your clock to work without being connected to a computer.  We have two options:</p> <ol> <li>Used a Raspberry Pi Pico W to get time from a central time service over Wifi</li> <li>or use a local clock and set the time manually</li> </ol>"},{"location":"kits/led-displays/reference/","title":"Programming Reference for the TM1637 Clock LED Driver","text":""},{"location":"kits/led-displays/reference/#seven-segment-font","title":"Seven Segment Font","text":"<p>They are called 7-segment displays as there are 7 LEDs for each digit (segment). One byte (7 lower bits) for each segment. The 8th bit (MSB) is for the colon and only on the 2nd segment.</p> <pre><code>      A\n     ---\n  F |   | B   *\n     -G-      H (on 2nd segment)\n  E |   | C   *\n     ---\n      D\n\n  HGFEDCBA\n0b01101101 = 0x6D = 109 = show \"5\"\n</code></pre> Display Bin Hex Dec 0 0b00111111 0x3F 63 1 0b00000110 0x06 6 2 0b01011011 0x5B 91 3 0b01001111 0x4F 79 4 0b01100110 0x66 102 5 0b01101101 0x6D 109 6 0b01111101 0x7D 125 7 0b00000111 0x07 7 8 0b01111111 0x7F 127 9 0b01101111 0x6F 111 A 0b01110111 0x77 119 b 0b01111100 0x7C 124 C 0b00111001 0x39 57 d 0b01011110 0x5E 94 E 0b01111001 0x79 121 F 0b01110001 0x71 113 G 0b00111101 0x3D 61 H 0b01110110 0x76 118 I 0b00000110 0x06 6 J 0b00011110 0x1E 30 K 0b01110110 0x76 118 L 0b00111000 0x38 56 M 0b01010101 0x55 85 n 0b01010100 0x54 84 O 0b00111111 0x3F 63 P 0b01110011 0x73 115 q 0b01100111 0x67 103 r 0b01010000 0x50 80 S 0b01101101 0x6D 109 t 0b01111000 0x78 120 U 0b00111110 0x3E 62 v 0b00011100 0x1C 28 W 0b00101010 0x2A 42 X 0b01110110 0x76 118 y 0b01101110 0x6E 110 Z 0b01011011 0x5B 91 blank 0b00000000 0x00 0 - 0b01000000 0x40 64 * 0b01100011 0x63 99"},{"location":"kits/led-displays/reference/#methods","title":"Methods","text":""},{"location":"kits/led-displays/reference/#set-brightneww","title":"Set Brightneww","text":"<p>Get or set brightness. <pre><code>brightness(val=None)\n</code></pre></p>"},{"location":"kits/led-displays/reference/#write-segments","title":"Write Segments","text":"<p>Write one or more segments at a given offset. <pre><code>write(segments, pos=0)\n</code></pre></p>"},{"location":"kits/led-displays/reference/#write-two-numbers-and-colon","title":"Write Two Numbers and Colon","text":"<p>Write Two Numbers and Colon</p> <pre><code>numbers(num1, num2, colon=True):\n</code></pre>"},{"location":"kits/led-displays/shift-register-displays/","title":"Shift Register Displays","text":"<p>The 74hc595 is a chip that takes a clock and data stream in and turns many LEDs on or off. 74hc595 chips can be connected in series to control 7 segments on 4 digits.</p> <p>I'll create a detailed walkthrough of the <code>clock-driver.py</code> program, breaking it down into digestible sections with accompanying labs. This will help students understand both the code and the underlying concepts.</p>"},{"location":"kits/led-displays/shift-register-displays/#1-core-components-and-imports","title":"1. Core Components and Imports","text":"<pre><code>from machine import Pin, RTC \nfrom sr74hc595 import SR74HC595_BITBANG\nfrom utime import sleep, localtime, ticks_ms\n</code></pre> <p>This section imports the necessary libraries. The program uses: - <code>machine.Pin</code>: Controls individual GPIO pins on the Pico - <code>RTC</code>: Real-Time Clock for keeping time - <code>sr74hc595</code>: Manages the shift register that controls the display - <code>utime</code>: Provides timing functions</p>"},{"location":"kits/led-displays/shift-register-displays/#lab-1-understanding-gpio-pins","title":"Lab 1: Understanding GPIO Pins","text":"<p>Have students create a simple LED blink program:</p> <pre><code>from machine import Pin\nfrom utime import sleep\n\nled = Pin(25, Pin.OUT)  # Built-in LED on Pico\nwhile True:\n    led.value(1)  # Turn on\n    sleep(1)\n    led.value(0)  # Turn off\n    sleep(1)\n</code></pre>"},{"location":"kits/led-displays/shift-register-displays/#2-rtc-initialization","title":"2. RTC Initialization","text":"<pre><code>def wait_for_rtc():\n    print(\"Waiting for RTC to be ready...\")\n    rtc = RTC()\n    while True:\n        current_time = rtc.datetime()\n        if current_time[0] != 2021 or current_time[1] != 1 or current_time[2] != 1:\n            print(\"RTC is ready!\")\n            return\n        print(\"RTC not ready yet...\")\n        sleep(1)\n</code></pre> <p>This function ensures the RTC has been set to a valid time before proceeding.</p>"},{"location":"kits/led-displays/shift-register-displays/#lab-2-rtc-basics","title":"Lab 2: RTC Basics","text":"<p>Have students experiment with reading and setting the RTC:</p> <pre><code>from machine import RTC\nfrom utime import sleep\n\nrtc = RTC()\n# Set the time (year, month, day, weekday, hour, minute, second, subsecond)\nrtc.datetime((2024, 12, 27, 5, 14, 30, 0, 0))\n\nwhile True:\n    current_time = rtc.datetime()\n    print(f\"Current time: {current_time[4]:02d}:{current_time[5]:02d}:{current_time[6]:02d}\")\n    sleep(1)\n</code></pre>"},{"location":"kits/led-displays/shift-register-displays/#3-seven-segment-display-setup","title":"3. Seven-Segment Display Setup","text":"<p><pre><code>class FourDigitClock:\n    ALL_OFF = 0xFF  # All segments off (inverted logic)\n\n    def __init__(self, ser_pin, srclk_pin, rclk_pin):\n        self.ser = Pin(ser_pin, Pin.OUT)\n        self.srclk = Pin(srclk_pin, Pin.OUT) \n        self.rclk = Pin(rclk_pin, Pin.OUT)\n</code></pre> This class manages the four-digit display. It uses three pins to control the shift register.</p>"},{"location":"kits/led-displays/shift-register-displays/#lab-3-seven-segment-pattern-display","title":"Lab 3: Seven-Segment Pattern Display","text":"<p>Have students create a simple program to display a single digit: <pre><code>from machine import Pin\nfrom utime import sleep\n\n# Create a simple version that lights up segments manually\nsegments = {\n    'a': Pin(2, Pin.OUT),\n    'b': Pin(3, Pin.OUT),\n    'c': Pin(4, Pin.OUT),\n    # ... add more segments\n}\n\ndef display_number(number):\n    # Pattern for number 1\n    if number == 1:\n        segments['b'].value(1)\n        segments['c'].value(1)\n    # Add more numbers...\n</code></pre></p>"},{"location":"kits/led-displays/shift-register-displays/#4-digit-patterns","title":"4. Digit Patterns","text":"<p><pre><code>self.SEGMENTS = {\n    'a': 4, 'b': 3, 'c': 2, \n    'd': 7, 'e': 6, 'f': 5, 'g': 1\n}\nself.DIGIT_SEGMENTS = {\n    0: 'abcdef', 1: 'bc', 2: 'abged', 3: 'abgcd',\n    4: 'fbcg', 5: 'afgcd', 6: 'afedcg', \n    7: 'abc', 8: 'abcdefg', 9: 'abfgcd'\n}\n</code></pre> This section defines which segments should be lit for each number.</p>"},{"location":"kits/led-displays/shift-register-displays/#lab-4-pattern-design","title":"Lab 4: Pattern Design","text":"<p>Have students draw and design their own custom characters using the seven segments. They can create: - Letters (A, b, C, d, E, F) - Custom symbols - Animated patterns</p>"},{"location":"kits/led-displays/shift-register-displays/#5-time-display-logic","title":"5. Time Display Logic","text":"<pre><code>def display_time(self, hour, minute, colon_state):\n    # Convert to 12-hour format\n    if hour &gt; 12:\n        hour -= 12\n    elif hour == 0:  \n        hour = 12\n</code></pre>"},{"location":"kits/led-displays/shift-register-displays/#lab-5-time-format-conversion","title":"Lab 5: Time Format Conversion","text":"<p>Have students write a program that converts between 24-hour and 12-hour time formats:</p> <pre><code>def convert_time(hour24):\n    if hour24 &gt; 12:\n        return hour24 - 12, \"PM\"\n    elif hour24 == 0:\n        return 12, \"AM\"\n    elif hour24 == 12:\n        return 12, \"PM\"\n    else:\n        return hour24, \"AM\"\n</code></pre>"},{"location":"kits/led-displays/shift-register-displays/#advanced-labs-and-extensions","title":"Advanced Labs and Extensions:","text":""},{"location":"kits/led-displays/shift-register-displays/#1-alarm-clock-lab","title":"1. Alarm Clock Lab","text":"<p>Modify the clock to add alarm functionality: - Add a button to set alarm time - Add a buzzer for the alarm - Implement snooze functionality</p>"},{"location":"kits/led-displays/shift-register-displays/#2-temperature-display-lab","title":"2. Temperature Display Lab","text":"<p>Alternate between showing time and temperature: - Add a temperature sensor - Display temperature for 3 seconds every minute - Add a button to toggle between time and temperature</p>"},{"location":"kits/led-displays/shift-register-displays/#3-custom-animation-lab","title":"3. Custom Animation Lab","text":"<p>Create animations for the display: - Make digits spin when changing - Create a \"snake\" animation for the top of each hour - Design transitions between numbers</p>"},{"location":"kits/led-displays/shift-register-displays/#4-world-clock-lab","title":"4. World Clock Lab","text":"<p>Modify the clock to show multiple time zones: - Add buttons to cycle through different time zones - Show timezone abbreviation - Store favorite time zones</p>"},{"location":"kits/led-displays/shift-register-displays/#5-stopwatch-lab","title":"5. Stopwatch Lab","text":"<p>Add stopwatch functionality: - Use buttons to start/stop/reset - Display tenths of seconds - Store lap times</p>"},{"location":"kits/led-displays/shift-register-displays/#summary","title":"Summary","text":"<p>These labs progressively build upon the base code while introducing new concepts and challenges. Each lab reinforces different programming concepts:</p> <ul> <li>Variables and data types</li> <li>Control structures (if/else, loops)</li> <li>Functions and methods</li> <li>Object-oriented programming</li> <li>Hardware interaction</li> <li>Time and date handling</li> <li>User input processing</li> </ul> <p>This allows students to learn both programming and hardware concepts in a hands-on, engaging way while creating something practical and visible.</p>"},{"location":"kits/lilygo/","title":"LILYGO T-Display RP2040 Kit","text":"<p>LILYGO makes low-cost and high-quality microcontroller development boards that include small displays.  Although most of their boards run on C programs on ESP-32 processors, they do have one that runs MicroPython on an RP2040.  This \"kit\" is really just that development board placed on a breadboard.  The device has two buttons on it which can be used to adjust the time.</p> <p>This is a color 1.14 inch LCD display PS with 240*135 resolution. It uses the ST7789V chip that has an extreamly high quality driver created by Russ Hughes that allows for flicker-free drawing.</p> <p>I purchased mine on Ebay for $10.66 and three dollars for shipping.</p> <p>Although the display is too small for most robotic applications where the robot is on the floor and we are standing, it is a good example of how we can get both clocks and watches to look great.  My hope is that LILYGO comes out with a larger display in the future.</p> <p>Lilygo also sells their own \"wearable\" watch kits] for $35 to $45.  However, I have not purchased any of these that can be programmed with an RP2040 and MicroPython yet.  Here is a GitHub Page for the T-Watch that implies it might be on the way.  Note that using this requires extensive knowledge of the ESP32 development system.</p>"},{"location":"kits/lilygo/#getting-started","title":"Getting Started","text":"<p>To use the ST7789V driver we MUST use a custom image provide by Rull Hughes.  This is because the driver is written in low-level C code and the python driver requires it to be combiled into the firmware image.</p> <p>I downloaded the custom image here:</p> <p>T-DISPLAY RP2040 Firmware</p> <p>I then held the Boot button down while I powered up the device.</p> <p>I soldered my own header pins on the LILYGO and placed it on a breadboard.  Unfortunatly this makes it impossible to hold down the boot button with the device on the breadboard.</p>"},{"location":"kits/lilygo/#pinouts","title":"Pinouts","text":"<p>The pinouts are very different from the Raspberry Pi Pico.</p> <p></p>"},{"location":"kits/lilygo/#config-file","title":"Config File","text":"<p>This implementation puts the driver in a hidden C program, but it does have a configuration file that we must upload and place in the /lib directory.</p> <p>Here is a Link to the File for the T-Display RP2040</p> <pre><code>\"\"\"TTGO T-Display RP2040 display\"\"\"\n\nfrom machine import Pin, SPI\nfrom time import sleep\nimport st7789\n\nTFA = 40    # top free area when scrolling\nBFA = 40    # bottom free area when scrolling\n\ndef config(rotation=0, buffer_size=0, options=0):\n\n    Pin(22, Pin.OUT, value=1)\n\n    spi = SPI(0,\n        baudrate=62500000,\n        polarity=1,\n        phase=0,\n        sck=Pin(2, Pin.OUT),\n        mosi=Pin(3, Pin.OUT),\n        miso=None)\n\n    return st7789.ST7789(\n        spi,\n        135,\n        240,\n        cs=Pin(5, Pin.OUT),\n        dc=Pin(1, Pin.OUT),\n        backlight=Pin(4, Pin.OUT),\n        rotation=rotation,\n        options=options,\n        buffer_size=buffer_size)\n</code></pre>"},{"location":"kits/lilygo/#blink-the-onboard-led","title":"Blink The Onboard LED","text":"<p>This red LED is on the bottom of the board.</p> <p>Blink Timer example:</p> <pre><code>from machine import Pin, Timer\nled = Pin(25,Pin.OUT)\ntim = Timer()\ndef tick(timer):\n    global led\n    led.toggle()\ntim.init(freq=2.5, mode=Timer.PERIODIC, callback=tick)\n</code></pre>"},{"location":"kits/lilygo/#display-example","title":"Display Example","text":"<pre><code>\"\"\"\ndisplay-test.py\nFills the screen with red, green and blue\n\"\"\"\n\nfrom utime import sleep\nimport st7789\nimport tft_config\ntft = tft_config.config(1)\ntft.init()\n\nwhile True:\n    tft.fill(st7789.RED)\n    sleep(1)\n    tft.fill(st7789.GREEN)\n    sleep(1)\n    tft.fill(st7789.BLUE)\n    sleep(1)\n</code></pre>"},{"location":"kits/lilygo/#drawing-text","title":"Drawing Text","text":"<p>For this example to work, you will need to load a font library into the /lib directory.</p> <pre><code>import random\nimport utime\nimport st7789\nimport tft_config\nimport vga2_bold_16x32 as font\n\ntft = tft_config.config(1)\ntft.init()\n\n# draw text using a 16X32 font using blue text on a white background\ntft.text(\n        font,\n        'Hello World!',\n        tft.width()//2-100, # x position to start writing\n        tft.height()//2-50, # y position\n        st7789.BLUE, # font in blue\n        st7789.WHITE # background in white\n)\n</code></pre>"},{"location":"kits/lilygo/#referneces","title":"Referneces","text":"<p>Item on Aliexpress Sample GitHub repo: https://github.com/Xinyuan-LilyGO/LILYGO-T-display-RP2040</p> <p>ST7789V Submodule: Russ Hughes GitHub Repo</p> <p>Config: Sample Config File</p>"},{"location":"kits/max7219/","title":"MAX7219 Clocks","text":"<p>The Analog Devices MAX7219 is a low-cost chip that communicates with a row of seven-segment displays using a single serial interface.</p> <p>eBay search for MAX7219</p> <p> </p>"},{"location":"kits/max7219/#lesson-plan-building-a-clock-with-the-max7219-chip-using-micropython-and-raspberry-pi-pico","title":"Lesson Plan: Building a Clock with the MAX7219 Chip using MicroPython and Raspberry Pi Pico","text":""},{"location":"kits/max7219/#objective","title":"Objective:","text":"<p>Students will learn about basic electronics and programming by building a digital clock using the MAX7219 LED driver chip with a Raspberry Pi Pico programmed in MicroPython.</p>"},{"location":"kits/max7219/#materials","title":"Materials:","text":"<ul> <li>MAX7219 LED dot matrix modules</li> <li>Raspberry Pi Pico</li> <li>Jumper wires</li> <li>Breadboard</li> <li>USB cable for the Raspberry Pi Pico</li> <li>Computers with Thonny Python IDE installed</li> <li>Basic electronic components (resistors, capacitors, etc.)</li> <li>Reference materials on MAX7219 and MicroPython programming</li> </ul>"},{"location":"kits/max7219/#duration","title":"Duration:","text":"<p>5 classes (45 minutes each)</p>"},{"location":"kits/max7219/#class-1-introduction-to-the-max7219-and-raspberry-pi-pico","title":"Class 1: Introduction to the MAX7219 and Raspberry Pi Pico","text":"<ul> <li>Lecture Topic: Overview of the MAX7219 chip and its applications in digital displays.</li> <li>Activity: Demonstration of a simple LED matrix setup using the MAX7219 and Raspberry Pi Pico.</li> <li>Homework: Read provided material about MAX7219 and basics of MicroPython.</li> </ul>"},{"location":"kits/max7219/#class-2-basic-electronics-and-circuit-design","title":"Class 2: Basic Electronics and Circuit Design","text":"<ul> <li>Lecture Topic: Fundamentals of electronics, introduction to using a breadboard, and designing circuits.</li> <li>Activity: Students practice creating basic circuits on the breadboard using Raspberry Pi Pico.</li> <li>Homework: Sketch a basic circuit diagram for connecting the MAX7219 to the Raspberry Pi Pico.</li> </ul>"},{"location":"kits/max7219/#class-3-introduction-to-micropython","title":"Class 3: Introduction to MicroPython","text":"<ul> <li>Lecture Topic: Basics of MicroPython programming and its application in controlling electronic components.</li> <li>Activity: Simple programming exercises in Thonny Python IDE to</li> </ul> <p>understand MicroPython syntax and basic commands.</p> <ul> <li>Homework: Write a simple program in MicroPython to blink an LED.</li> </ul>"},{"location":"kits/max7219/#class-4-programming-the-max7219-with-micropython","title":"Class 4: Programming the MAX7219 with MicroPython","text":"<ul> <li>Lecture Topic: Detailed instruction on programming the MAX7219 using MicroPython.</li> <li>Activity: Students will write and upload a MicroPython script to the Raspberry Pi Pico to control the MAX7219 module, starting with displaying static numbers.</li> <li>Homework: Modify the script to create a simple animation or pattern on the LED matrix.</li> </ul>"},{"location":"kits/max7219/#class-5-building-and-programming-the-clock","title":"Class 5: Building and Programming the Clock","text":"<ul> <li>Lecture Topic: Integrating the knowledge gained to build a digital clock.</li> <li>Activity: Students will complete the assembly of their digital clocks and program them to display the current time. This will involve fetching the time from the Raspberry Pi Pico and displaying it on the MAX7219 LED matrix.</li> <li>Assessment: Evaluate the students' projects based on functionality, creativity, and understanding of the concepts taught.</li> </ul>"},{"location":"kits/max7219/#additional-notes","title":"Additional Notes:","text":"<ul> <li>Ensure that each student or group has access to all the necessary materials.</li> <li>Supplement the course with online resources and forums for additional support.</li> <li>Encourage students to document their progress and challenges for a reflective learning experience.</li> <li>Consider having a session for students to present their finished clocks and share their learning experiences with the class.</li> </ul>"},{"location":"kits/max7219/#references","title":"References","text":"<p>DIY clock | Homemade 7 segments \"nixie\" tubes</p>"},{"location":"kits/neopixel/","title":"NeoPixel LED Strip Clock Kits","text":"<p>In this section we will present three clocks that use a string of low-cost RGB LEDs commonly called NeoPixels.  The name of this standard is technically called the WS2812B addressable LED standards.  NeoPixels are frequently used in art-clock projects because they are:</p> <ol> <li>Easy to hook up - just three wires can drive up to 400 RGB LED</li> <li>Low cost - typically they sell for about $5/meter (60 pixels per meter) on eBay</li> <li>Available in many variations - they come is strips of various densities, rings, matrices, string and fairy light configurations</li> </ol> <p>We have an entire on-line course on how to used these fun and colorful strips at our Moving Rainbow website.  That site includes hundreds of step-by-step lesson plans and sample programs for kids ranging from age 8 to 18.</p> <p>In this book we have several examples of clocks built with NeoPixels.</p> <ol> <li>Binary Clock This kit displays the time using binary numbers.  It is a little hard to read at first, but these kits are extremely popular. Link to the Binary Clock Project.  There are also several alternate layouts of how to display a binary clock.  There are six different NeoPixel strips, each strip requires about five minutes of soldering, so the assembly takes about an hour.  The total parts cost about $11.</li> <li>Seven Segment Clock The second requires building four seven-segment displays from the LED strip (or LED string) so the assembly time is significantly longer - about three hours if you are good with a soldering iron.  Link to the Seven Segment Clock Project</li> <li>Fibonacci Clock This clock is unusual since it requires a bit of time to be able to read the time.  However, it has what many consider the most elegant simple display.  Link to the Fibonacci Clock Project.</li> </ol>"},{"location":"kits/neopixel/binary-clock/","title":"Binary Clock","text":"<p>The binary clock is a popular project where binary numbers are used to display the digits of a clock.</p> <p>This kit just needs a Pico and a short segment of an LED strip - about 20 pixels.</p> <p>We can create a very simple binary clock using a single NeoPixel LED strip with just 12 pixels.</p>"},{"location":"kits/neopixel/binary-clock/#microsim","title":"MicroSim","text":"<p>You can see a simulation of the clock here:</p> <p>Note that you can click the \"Show Text Time\" and \"Show Values\" to get a decoded human-understandable view of how to tell time with the clock.</p>"},{"location":"kits/neopixel/binary-clock/alternative-layouts/","title":"Alternative Binary Clock Layouts","text":"<p>The strip will have two rows of six pixels each:</p> <ol> <li>The first row will be the binary hour (0 to 24) (5 green pixels) and one pixel that flashes the second</li> <li>The second row will show the minutes (0 to 59) (6 blue pixels)</li> </ol>"},{"location":"kits/neopixel/binary-clock/alternative-layouts/#three-row-clock","title":"Three Row Clock","text":""},{"location":"kits/neopixel/binary-clock/alternative-layouts/#sample-code-for-three-rows-with-second-counter","title":"Sample Code for Three Rows with Second Counter","text":"<ol> <li>Row 1 is five pixels with the hours (0-24)</li> <li>Row 2 is the minutes with the minutes (0-60)</li> <li>Row 3 is the seconds (0-60)</li> </ol> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, localtime\n\nNEOPIXEL_PIN = 0\nNUMBER_PIXELS = 18\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nsec_bits = [0,0,0,0,0,0]\nmin_bits = [0,0,0,0,0,0]\nhr_bits = [0,0,0,0,0,0]\n\ndef decimal_to_binary(n, a):\n    global sec_bits\n    for i in range(0,6):\n        if n % 2:\n            a[i] = 1\n        else:\n            a[i] = 0\n        # n is halfed doing a divide by 2\n        n //= 2\n\ndef display_binary(binary, index, color):\n    for i in range(0, 6):\n        # print(i, ' ', end='')\n        if binary[i] == 1:\n            strip[index+i] = color\n        else:\n            strip[index+i] = (0,0,0)\n    strip.write()\n\n# light mark and write\ndef display_mark(loc):\n    strip[loc] = (5,5,5)\n    strip.write()\n\n# update from the first time\n# sec\ndisplay_mark(0)\ndisplay_mark(7)\n\n# min\ndisplay_mark(9)\ndisplay_mark(16)\n\n# min\ndisplay_mark(19)\ndisplay_mark(26)\n\nnow = localtime()\nhour = now[3]\n# use AM/PM 12 hour time\nif hour &gt; 12:\n    hour = hour - 12\nminute = now[4]\n\n# this is not working\ndecimal_to_binary(minute, min_bits)\nprint('initial min:', minute, min_bits)\ndisplay_binary(min_bits, 10, (0,10,0))\n\ndecimal_to_binary(hour, hr_bits)\nprint('initial hour:', hour, hr_bits)\ndisplay_binary(hr_bits, 20, (0,0,10))\n\nwhile True:\n    now = localtime()\n    hour = now[3]\n    # use AM/PM 12 hour time\n    if hour &gt; 12:\n        hour = hour - 12\n    minute = now[4]\n    sec = now[5]\n    print(hour, ':', minute, ' ', sec, sep='')\n    strip.write()\n    decimal_to_binary(sec, sec_bits)\n    print('sec:', sec, sec_bits)\n    display_binary(sec_bits, 1, (10,0,0))\n    if sec == 60:\n        minute = minute + 1\n        sec = 0\n        decimal_to_binary(minute, min_bits)\n        print('min:', minute, min_bits)\n        display_binary(min_bits, 10, (0,10,0))\n        if minute == 60:\n            decimal_to_binary(hour, hr_bits)\n            print('hour:', hour, hr_bits)\n            display_binary(hr_bits, 20, (0,0,10))\n            hour = hour + 1\n            minute = 0\n            if hour == 24:\n                hour = 0\n    sleep(1)\n</code></pre>"},{"location":"kits/neopixel/binary-clock/alternative-layouts/#references","title":"References","text":"<ul> <li>Moving Rainbow Clock</li> </ul>"},{"location":"kits/neopixel/binary-clock/assembly/","title":"Binary Clock Assembly","text":""},{"location":"kits/neopixel/binary-clock/assembly/#led-strip-layout","title":"LED Strip Layout","text":""},{"location":"kits/neopixel/binary-clock/code/","title":"Binary Clock Code","text":""},{"location":"kits/neopixel/binary-clock/code/#colum-configuration-values","title":"Colum Configuration Values","text":"<pre><code># Column configuration (start_index, height, color)\nCOLUMN_CONFIG = {\n    'hours_tens':   (18, 2, HOURS_COLOR),   # Column 1: 2 pixels (0-2)\n    'hours_ones':   (14, 4, HOURS_COLOR),   # Column 2: 4 pixels (0-9)\n    'minutes_tens': (11, 3, MINUTES_COLOR), # Column 3: 3 pixels (0-5)\n    'minutes_ones': (7, 4, MINUTES_COLOR),  # Column 4: 4 pixels (0-9)\n    'seconds_tens': (4, 3, SECONDS_COLOR),  # Column 5: 3 pixels (0-5)\n    'seconds_ones': (0, 4, SECONDS_COLOR),  # Column 6: 4 pixels (0-9)\n}\n</code></pre> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import localtime, sleep\n\n# Configuration\nNEOPIXEL_PIN = 0\nNUM_PIXELS = 20  # Total number of pixels (18 + 2)\n\n# Colors (RGB values) - using light/pastel versions\nHOURS_COLOR = (10, 50, 10)     # Light green\nMINUTES_COLOR = (10, 10, 60)   # Light cyan\nSECONDS_COLOR = (30, 40, 0)    # Light yellow\nOFF_COLOR = (0, 0, 0)          # Off\n\n# Column configuration (start_index, height, color)\nCOLUMN_CONFIG = {\n    'hours_tens':   (18, 2, HOURS_COLOR),   # Column 1: 2 pixels (0-2)\n    'hours_ones':   (14, 4, HOURS_COLOR),   # Column 2: 4 pixels (0-9)\n    'minutes_tens': (11, 3, MINUTES_COLOR), # Column 3: 3 pixels (0-5)\n    'minutes_ones': (7, 4, MINUTES_COLOR),  # Column 4: 4 pixels (0-9)\n    'seconds_tens': (4, 3, SECONDS_COLOR),  # Column 5: 3 pixels (0-5)\n    'seconds_ones': (0, 4, SECONDS_COLOR),  # Column 6: 4 pixels (0-9)\n}\n\n# Initialize NeoPixels\npixels = NeoPixel(Pin(NEOPIXEL_PIN), NUM_PIXELS)\n\ndef int_to_binary_column(number, num_bits):\n    \"\"\"Convert a number to binary and return list of bits.\"\"\"\n    binary = []\n    for i in range(num_bits):\n        binary.append(1 if number &amp; (1 &lt;&lt; i) else 0)\n    return binary  # LSB first\n\ndef set_column(start_index, height, color, number):\n    \"\"\"Set the LEDs for a specific column based on the number.\"\"\"\n    binary = int_to_binary_column(number, height)\n\n    # Set each LED in the column\n    for bit_pos in range(height):\n        pixel_index = start_index + bit_pos\n        pixels[pixel_index] = color if binary[bit_pos] else OFF_COLOR\n\ndef update_display(hours, minutes, seconds):\n    \"\"\"Update all columns with current time.\"\"\"\n    # Hours\n    set_column(*COLUMN_CONFIG['hours_tens'], hours // 10)\n    set_column(*COLUMN_CONFIG['hours_ones'], hours % 10)\n\n    # Minutes\n    set_column(*COLUMN_CONFIG['minutes_tens'], minutes // 10)\n    set_column(*COLUMN_CONFIG['minutes_ones'], minutes % 10)\n\n    # Seconds\n    set_column(*COLUMN_CONFIG['seconds_tens'], seconds // 10)\n    set_column(*COLUMN_CONFIG['seconds_ones'], seconds % 10)\n\n    pixels.write()  # Update the NeoPixels\n\ndef main():\n    print(\"Binary Clock Started\")\n    print(\"Columns from right to left:\")\n    print(\"1. Seconds ones (4 bits) - Light Yellow\")\n    print(\"2. Seconds tens (3 bits) - Light Yellow\")\n    print(\"3. Minutes ones (4 bits) - Light Cyan\")\n    print(\"4. Minutes tens (3 bits) - Light Cyan\")\n    print(\"5. Hours ones (4 bits) - Light Green\")\n    print(\"6. Hours tens (2 bits) - Light Green\")\n    print(\"LSB at bottom of each column\")\n\n    while True:\n        # Get current time - replace this line with the RTC call in the final version\n        t = localtime()\n        hours, minutes, seconds = t[3], t[4], t[5]\n\n        # Update the display\n        update_display(hours, minutes, seconds)\n\n        # Print current time for debugging\n        print(f\"{hours:02d}:{minutes:02d}:{seconds:02d}\")\n\n        # Wait before next update\n        sleep(1)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"kits/neopixel/binary-clock/prompt/","title":"Prompt","text":"<p>Prompt</p> <p>I would like your help designing a binary clock using NeoPixels with MicroPython The clock will have six columns. Column 1 is for the hours tens digits. Column 2 is for the hours one digits. Column 3 is for the minutes tens digits Column 4 is for the minutes ones digits Column 5 is for the seconds tens digits Column 6 is for the seconds ones digits</p> <p>Column 6 (seconds ones) starts a index=0 and is 4 pixels high Column 5 (seconds tens) starts  index=4 and is 3 pixels high Column 4 (minutes ones) starts at index-7 and is 4 pixels high Column 3 (minutes tens) starts at index=11 and is 3 pixels high Column 2 (hours ones) starts at index=14 and is 4 pixels high Column 1 (hour tens) starts at index=18 and is 2 pixels high</p> <p>Put the least significant bit at the bottom of the column. Please generate a MicroPython application that shows the time. Use the following preamble.</p>"},{"location":"kits/neopixel/binary-clock/prompt/#preamble","title":"Preamble","text":"<pre><code># Configuration\nNEOPIXEL_PIN = 0\nNUM_PIXELS = 20  # Total number of pixels (18 + 2)\n\n# Column configuration (start_index, height)\nCOLUMN_CONFIG = {\n    'hours_tens':   (18, 2),  # Column 1: 2 pixels (0-2)\n    'hours_ones':   (14, 4),  # Column 2: 4 pixels (0-9)\n    'minutes_tens': (11, 3),  # Column 3: 3 pixels (0-5)\n    'minutes_ones': (7, 4),   # Column 4: 4 pixels (0-9)\n    'seconds_tens': (4, 3),   # Column 5: 3 pixels (0-5)\n    'seconds_ones': (0, 4),   # Column 6: 4 pixels (0-9)\n}\n\n# Initialize NeoPixels\npixels = NeoPixel(Pin(NEOPIXEL_PIN), NUM_PIXELS)\n\n# Colors (RGB values)\nON_COLOR = (0, 20, 20)    # Cyan, dimmed for less power usage\nOFF_COLOR = (0, 0, 0)     # Off\n</code></pre>"},{"location":"kits/neopixel/binary-clock/prompt/#full-program-generated","title":"Full Program Generated","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import localtime, sleep\n\n# Configuration\nNEOPIXEL_PIN = 0\nNUM_PIXELS = 20  # Total number of pixels (18 + 2)\n\n# Column configuration (start_index, height)\nCOLUMN_CONFIG = {\n    'hours_tens':   (18, 2),  # Column 1: 2 pixels (0-2)\n    'hours_ones':   (14, 4),  # Column 2: 4 pixels (0-9)\n    'minutes_tens': (11, 3),  # Column 3: 3 pixels (0-5)\n    'minutes_ones': (7, 4),   # Column 4: 4 pixels (0-9)\n    'seconds_tens': (4, 3),   # Column 5: 3 pixels (0-5)\n    'seconds_ones': (0, 4),   # Column 6: 4 pixels (0-9)\n}\n\n# Initialize NeoPixels\npixels = NeoPixel(Pin(NEOPIXEL_PIN), NUM_PIXELS)\n\n# Colors (RGB values)\nON_COLOR = (0, 20, 20)    # Cyan, dimmed for less power usage\nOFF_COLOR = (0, 0, 0)     # Off\n\ndef int_to_binary_column(number, num_bits):\n    \"\"\"Convert a number to binary and return list of bits.\"\"\"\n    binary = []\n    for i in range(num_bits):\n        binary.append(1 if number &amp; (1 &lt;&lt; i) else 0)\n    return binary  # LSB first\n\ndef set_column(start_index, height, number):\n    \"\"\"Set the LEDs for a specific column based on the number.\"\"\"\n    binary = int_to_binary_column(number, height)\n\n    # Set each LED in the column\n    for bit_pos in range(height):\n        pixel_index = start_index + bit_pos\n        pixels[pixel_index] = ON_COLOR if binary[bit_pos] else OFF_COLOR\n\ndef update_display(hours, minutes, seconds):\n    \"\"\"Update all columns with current time.\"\"\"\n    # Hours\n    set_column(*COLUMN_CONFIG['hours_tens'], hours // 10)\n    set_column(*COLUMN_CONFIG['hours_ones'], hours % 10)\n\n    # Minutes\n    set_column(*COLUMN_CONFIG['minutes_tens'], minutes // 10)\n    set_column(*COLUMN_CONFIG['minutes_ones'], minutes % 10)\n\n    # Seconds\n    set_column(*COLUMN_CONFIG['seconds_tens'], seconds // 10)\n    set_column(*COLUMN_CONFIG['seconds_ones'], seconds % 10)\n\n    pixels.write()  # Update the NeoPixels\n\ndef main():\n    print(\"Binary Clock Started\")\n    print(\"Columns from right to left:\")\n    print(\"1. Seconds ones (4 bits)\")\n    print(\"2. Seconds tens (3 bits)\")\n    print(\"3. Minutes ones (4 bits)\")\n    print(\"4. Minutes tens (3 bits)\")\n    print(\"5. Hours ones (4 bits)\")\n    print(\"6. Hours tens (2 bits)\")\n    print(\"LSB at bottom of each column\")\n\n    while True:\n        # Get current time\n        t = localtime()\n        hours, minutes, seconds = t[3], t[4], t[5]\n\n        # Update the display\n        update_display(hours, minutes, seconds)\n\n        # Print current time for debugging\n        print(f\"{hours:02d}:{minutes:02d}:{seconds:02d}\")\n\n        # Wait before next update\n        sleep(1)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"kits/neopixel/fibonacci-clock/","title":"Fibonacci Clock","text":"<p>Assembly</p> <p>Programming Code</p> <p>Generative AI Prompt</p>"},{"location":"kits/neopixel/fibonacci-clock/assembly/","title":"Assembly","text":""},{"location":"kits/neopixel/fibonacci-clock/code/","title":"Code","text":"<pre><code># Fibonacci time function\ndef fib_time(hours, minutes):\n    vals = [1, 1, 2, 3, 5]\n    state = [0, 0, 0, 0, 0]\n\n    # Calculate Fibonacci representation for hours\n    remaining_hours = hours\n    idx = len(vals) - 1\n    for v in vals[::-1]:\n        if remaining_hours == 0 or idx &lt; 0: break\n        if remaining_hours &gt;= v:\n            state[idx] += 1\n            remaining_hours -= v\n        idx -= 1\n\n    # Calculate Fibonacci representation for minutes (in increments of 5)\n    remaining_minutes = math.floor(minutes / 5)\n    idx = len(vals) - 1\n    for v in vals[::-1]:\n        if remaining_minutes == 0 or idx &lt; 0: break\n        if remaining_minutes &gt;= v:\n            state[idx] += 2\n            remaining_minutes -= v\n        idx -= 1\n\n    return state\n</code></pre>"},{"location":"kits/neopixel/seven-segment-clock/","title":"Neopixel Seven Segment Clock","text":"<p>We can create a large, bright clock visible in a large classroom by lighting up selective pixels of an LED strip and arranging the pixels in the shape of seven segment displays.  We can use three pixels per segment.</p> <p></p>"},{"location":"kits/neopixel/seven-segment-clock/#seven-segment-digits","title":"Seven Segment Digits","text":"<ul> <li>We can use three pixels per segment.</li> <li>21 pixels per digit</li> <li>63 pixels + 6 for the \"1\" + two for the colon = 70 pixels</li> </ul> <p>eBay 50 for $12</p> <p>Drawing Digits</p> <p>Lessons</p> <p>We can create an array of the segments like this:</p> <pre><code>segmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n]\n</code></pre>"},{"location":"kits/neopixel/seven-segment-clock/#digit-pixel-map","title":"Digit Pixel Map","text":"<p>Assume that a digit starts at pixel n and that each segment has three pixels. To turn on the segments, here is the mapping:</p> <ul> <li>a: n, n+1, n+2</li> <li>b: n+3, n+4, n+5</li> <li>c: n+6, n+7, n+8</li> <li>d: n+9, n+10, n+11</li> </ul> <pre><code>def set_pixels(digit, value, color):\n    # look up start pixel for digit\n    # for value turn on pixels\n    n = startVals[digit]\n\n    segmentOn = segmentMapping[value];\n    for i in range(0, 9):\n        if (segmentOn[i]):\n            o = i*3 // offset\n            strip(n+o) = color\n            strip(n+o+1) = color\n            strip(n+o+2) = color\n</code></pre>"},{"location":"kits/neopixel/seven-segment-clock/#clock-code","title":"Clock Code","text":"<p>Here is some working Python code that displays the time on the clock.</p> <p>```python from machine import Pin from neopixel import NeoPixel from utime import sleep, localtime</p> <p>NUMBER_PIXELS = 74 strip = NeoPixel(Pin(0), NUMBER_PIXELS)</p>"},{"location":"kits/neopixel/seven-segment-clock/#define-segment-patterns-for-digits-0-9","title":"Define segment patterns for digits 0-9","text":""},{"location":"kits/neopixel/seven-segment-clock/#segments-in-order-abcdefg","title":"Segments in order [a,b,c,d,e,f,g]:","text":""},{"location":"kits/neopixel/seven-segment-clock/#a-top-012","title":"a: top (0,1,2)","text":""},{"location":"kits/neopixel/seven-segment-clock/#b-top-right-345","title":"b: top right (3,4,5)","text":""},{"location":"kits/neopixel/seven-segment-clock/#c-bottom-right-678","title":"c: bottom right (6,7,8)","text":""},{"location":"kits/neopixel/seven-segment-clock/#d-bottom-91011","title":"d: bottom (9,10,11)","text":""},{"location":"kits/neopixel/seven-segment-clock/#e-bottom-left-121314","title":"e: bottom left (12,13,14)","text":""},{"location":"kits/neopixel/seven-segment-clock/#f-upper-left-151617","title":"f: upper left (15,16,17)","text":""},{"location":"kits/neopixel/seven-segment-clock/#g-middle-181920","title":"g: middle (18,19,20)","text":"<p>DIGITS = {     #    a,b,c,d,e,f,g     0: [1,1,1,1,1,1,0],  # all but middle     1: [0,1,1,0,0,0,0],  # right side only     2: [1,1,0,1,1,0,1],  # all but bottom right and upper left     3: [1,1,1,1,0,0,1],  # all but left side     4: [0,1,1,0,0,1,1],  # both right, upper left, and middle     5: [1,0,1,1,0,1,1],  # all but top right and bottom left     6: [1,0,1,1,1,1,1],  # all but top right     7: [1,1,1,0,0,0,0],  # top and both right segments     8: [1,1,1,1,1,1,1],  # all segments     9: [1,1,1,1,0,1,1]   # all but bottom left }</p>"},{"location":"kits/neopixel/seven-segment-clock/#color-definitions-rgb","title":"Color definitions (RGB)","text":"<p>ON_COLOR = (10, 10, 10)  # Dim white OFF_COLOR = (0, 0, 0)    # Off</p> <p>def set_segment_pixels(start_idx, segment_pattern):     \"\"\"Set three pixels for a segment based on pattern\"\"\"     for i in range(3):         strip[start_idx + i] = ON_COLOR if segment_pattern else OFF_COLOR</p> <p>def display_digit(digit, start_pixel):     \"\"\"Display a single digit starting at the specified pixel\"\"\"     if digit not in DIGITS:         return</p> <pre><code>pattern = DIGITS[digit]\n# Map the array positions to the physical segments in correct order\nsegments = [\n    start_pixel + 0,   # a: top (0,1,2)\n    start_pixel + 3,   # b: top right (3,4,5)\n    start_pixel + 6,   # c: bottom right (6,7,8)\n    start_pixel + 9,   # d: bottom (9,10,11)\n    start_pixel + 12,  # e: bottom left (12,13,14)\n    start_pixel + 15,  # f: upper left (15,16,17)\n    start_pixel + 18   # g: middle (18,19,20)\n]\n\n# Set pixels for each segment based on pattern\nfor segment_index, segment_on in enumerate(pattern):\n    set_segment_pixels(segments[segment_index], segment_on)\n</code></pre> <p>def set_colon(on=True):     \"\"\"Set colon pixels (42 and 43)\"\"\"     color = ON_COLOR if on else OFF_COLOR     strip[42] = color     strip[43] = color</p> <p>def display_time(hour, minute, colon_on):     \"\"\"Display time on the LED strip\"\"\"     # Convert 24-hour to 12-hour format     hour = hour if hour &lt;= 12 else hour - 12     if hour == 0:         hour = 12</p> <pre><code># Set hours \"1\" digit if needed (pixels 65-73)\nif hour &gt;= 10:\n    for i in range(65, 74):\n        strip[i] = ON_COLOR\nelse:\n    for i in range(65, 74):\n        strip[i] = OFF_COLOR\n\n# Display ones digit of hours (pixels 44-64)\ndisplay_digit(hour % 10, 44)\n\n# Display tens digit of minutes (pixels 21-41)\ndisplay_digit(minute // 10, 21)\n\n# Display ones digit of minutes (pixels 0-20)\ndisplay_digit(minute % 10, 0)\n\n# Set colon (pixels 42-43)\nset_colon(colon_on)\n\nstrip.write()\n</code></pre> <p>def clear_display():     \"\"\"Turn off all pixels\"\"\"     for i in range(NUMBER_PIXELS):         strip[i] = OFF_COLOR     strip.write()</p>"},{"location":"kits/neopixel/seven-segment-clock/#main-loop","title":"Main loop","text":"<p>colon_state = True clear_display()</p> <p>while True:     current_time = localtime()     hour = current_time[3]     minute = current_time[4]     if hour &gt; 12:         display_hour = hour - 12</p> <pre><code>display_time(hour, minute, colon_state)\ncolon_state = not colon_state\nprint(f'{display_hour}:{minute}')\nsleep(1)\n</code></pre> <p>```</p> <p>7-Segment Display Demo with P5.js</p> <p>Moving Rainbow Arduino Sign</p>"},{"location":"kits/neopixel/seven-segment-clock/03-light-diffusion/","title":"NeoPixel Light Diffusion","text":"<p>To make a nice clock we need to design an effective diffusion system for NeoPixels that balances visibility and brightness.</p> <p>For optimal diffusion while maintaining brightness, we recommend a multi-layer approach:</p> <ol> <li> <p>Primary diffusion layer: Use a thin (1-3mm) sheet of white acrylic with a light frost or matte finish, positioned about 5-10mm away from the NeoPixels. This distance allows enough space for the light to blend while keeping individual pixels distinguishable.</p> </li> <li> <p>Air gap: The space between the NeoPixels and the diffusion layer is crucial. Too close and you'll see harsh spots; too far and you'll lose brightness. Start with 8mm and adjust based on your needs.</p> </li> <li> <p>Optional secondary diffusion: If you need more smoothing, add a very thin (0.5-1mm) layer of standard white diffusion film about 2-3mm in front of the primary layer.</p> </li> </ol> <p>Some specific materials to consider:</p> <ul> <li>White acrylic with 30-50% light transmission</li> <li>Light Shaping Diffuser (LSD) film with 20\u00b0 beam angle</li> <li>Frosted polycarbonate with light transmission around 80%</li> </ul> <p>To maximize brightness while maintaining the pixel effect, you can also:</p> <ul> <li>Create a reflective cavity behind the NeoPixels using white material</li> <li>Use higher brightness NeoPixels (like the WS2812B-Eco)</li> <li>Consider adding small dividers between pixels if you want more definition</li> </ul> <p>https://www.youtube.com/watch?v=Y2tWdKKYAak</p>"},{"location":"kits/neopixel/seven-segment-clock/assembly/","title":"Assembling Your Seven Segment NeoPixel Clock","text":""},{"location":"kits/neopixel/seven-segment-clock/assembly/#time-estimate","title":"Time Estimate","text":"<ul> <li>4 digits</li> <li>7 segments per digit</li> <li>6 solder connections per segment</li> <li>two colons - four solder connections each</li> </ul> <p>Total = 476 + 8 = 168 + 8 = 174 solder connections</p> <p>Per connection (average times):</p> <ul> <li>Measuring, stripping, and bending wires: 30 seconds</li> <li>Positioning and soldering: 30 seconds</li> <li>Checking and testing: 30 seconds</li> </ul> <p>Total: 260 minutes or 4.3 hours</p> <p>Total: 180 </p> <p></p> <p></p> <p></p>"},{"location":"kits/neopixel/seven-segment-clock/code/","title":"Code for the NeoPixel Seven Segment Clock","text":""},{"location":"kits/neopixel/seven-segment-clock/prompt/","title":"Sample Prompt to Generate NeoPixel Clock Code","text":""},{"location":"kits/neopixel/seven-segment-clock/prompt/#sample-prompt","title":"Sample Prompt","text":"<p>Prompt</p> <p>We created a clock display using a 74 pixel WS2811B LED strip. The clock has three full digits and a \"1\" for the tens digit as well as two pixels for the colon. Each digit has seven segments with three pixels per segment. The right-most ones digit minutes digit starts at 0 and goes to 20. The second digit for the tens of minutes goes from 21 to 41. The colons are 42 and 43. The third digit is for the one hours and goes from 44 to 64. The hours ten single 1 goes from 65 to 73. Within a digit, here are the segment pixels Segment a on the top are pixels (0,1,2). Segment b on the upper right are pixels (3,4,5) Segment c on the lower right are pixels (6,7,8) Segment d on the bottom are pixels (9,10,11) Segment e on the lower left are pixels (12, 13, 14) Segment f on the upper left are pixels (15, 16, 17) Segment g in the middle are pixels (18,19 and 20)</p> <p>Please write a clock program in MicroPython that displays the hours and minutes of localtime() function but the hours range from 1 to 12. Make the colon turn on and off every second.</p> <p>Here is the preamble</p> <p>from machine import Pin from neopixel import NeoPixel from utime import sleep</p> <p>NUMBER_PIXELS = 74 strip = NeoPixel(Pin(0), NUMBER_PIXELS)</p>"},{"location":"kits/neopixel/seven-segment-clock/prompt/#result","title":"Result","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, localtime\n\nNUMBER_PIXELS = 74\nstrip = NeoPixel(Pin(0), NUMBER_PIXELS)\n\n# Define segment patterns for digits 0-9\n# Segments in order [a,b,c,d,e,f,g]:\n# a: top (0,1,2)\n# b: top right (3,4,5)\n# c: bottom right (6,7,8)\n# d: bottom (9,10,11)\n# e: bottom left (12,13,14)\n# f: upper left (15,16,17)\n# g: middle (18,19,20)\nDIGITS = {\n    #    a,b,c,d,e,f,g\n    0: [1,1,1,1,1,1,0],  # all but middle\n    1: [0,1,1,0,0,0,0],  # right side only\n    2: [1,1,0,1,1,0,1],  # all but bottom right and upper left\n    3: [1,1,1,1,0,0,1],  # all but left side\n    4: [0,1,1,0,0,1,1],  # both right, upper left, and middle\n    5: [1,0,1,1,0,1,1],  # all but top right and bottom left\n    6: [1,0,1,1,1,1,1],  # all but top right\n    7: [1,1,1,0,0,0,0],  # top and both right segments\n    8: [1,1,1,1,1,1,1],  # all segments\n    9: [1,1,1,1,0,1,1]   # all but bottom left\n}\n\n# Color definitions (RGB)\nON_COLOR = (10, 10, 10)  # Dim white\nOFF_COLOR = (0, 0, 0)    # Off\n\ndef set_segment_pixels(start_idx, segment_pattern):\n    \"\"\"Set three pixels for a segment based on pattern\"\"\"\n    for i in range(3):\n        strip[start_idx + i] = ON_COLOR if segment_pattern else OFF_COLOR\n\ndef display_digit(digit, start_pixel):\n    \"\"\"Display a single digit starting at the specified pixel\"\"\"\n    if digit not in DIGITS:\n        return\n\n    pattern = DIGITS[digit]\n    # Map the array positions to the physical segments in correct order\n    segments = [\n        start_pixel + 0,   # a: top (0,1,2)\n        start_pixel + 3,   # b: top right (3,4,5)\n        start_pixel + 6,   # c: bottom right (6,7,8)\n        start_pixel + 9,   # d: bottom (9,10,11)\n        start_pixel + 12,  # e: bottom left (12,13,14)\n        start_pixel + 15,  # f: upper left (15,16,17)\n        start_pixel + 18   # g: middle (18,19,20)\n    ]\n\n    # Set pixels for each segment based on pattern\n    for segment_index, segment_on in enumerate(pattern):\n        set_segment_pixels(segments[segment_index], segment_on)\n\n    # Set pixels for each segment based on pattern\n    for segment_index, segment_on in enumerate(pattern):\n        set_segment_pixels(segments[segment_index], segment_on)\n\ndef set_colon(on=True):\n    \"\"\"Set colon pixels (42 and 43)\"\"\"\n    color = ON_COLOR if on else OFF_COLOR\n    strip[42] = color\n    strip[43] = color\n\ndef display_time(hour, minute, colon_on):\n    \"\"\"Display time on the LED strip\"\"\"\n    # Convert 24-hour to 12-hour format\n    hour = hour if hour &lt;= 12 else hour - 12\n    if hour == 0:\n        hour = 12\n\n    # Set hours \"1\" digit if needed (pixels 65-73)\n    if hour &gt;= 10:\n        for i in range(65, 74):\n            strip[i] = ON_COLOR\n    else:\n        for i in range(65, 74):\n            strip[i] = OFF_COLOR\n\n    # Display ones digit of hours (pixels 44-64)\n    display_digit(hour % 10, 44)\n\n    # Display tens digit of minutes (pixels 21-41)\n    display_digit(minute // 10, 21)\n\n    # Display ones digit of minutes (pixels 0-20)\n    display_digit(minute % 10, 0)\n\n    # Set colon (pixels 42-43)\n    set_colon(colon_on)\n\n    strip.write()\n\ndef clear_display():\n    \"\"\"Turn off all pixels\"\"\"\n    for i in range(NUMBER_PIXELS):\n        strip[i] = OFF_COLOR\n    strip.write()\n\n# Main loop\ncolon_state = True\nclear_display()\n\nwhile True:\n    current_time = localtime()\n    hour = current_time[3]\n    minute = current_time[4]\n    if hour &gt; 12:\n        display_hour = hour - 12   \n    display_time(hour, minute, colon_state)\n    colon_state = not colon_state\n    print(f'{display_hour}:{minute}')\n    sleep(1)\n</code></pre>"},{"location":"kits/oled-large/","title":"Large OLED Kit","text":"<p>The Large OLED Kit is one of our most versatile kits.</p> <p>It uses a bright monochrome 128x64 SSD1306 OLED with the Raspberry Pi Pico W and a DS3231 real-time clock to keep time accurate to within 2 seconds per month.</p> <p>The OLEDs are mounted on a piece of acrylic (Plexiglass) with a half-size breadboard.</p> <p></p> <p>Each board has three buttons so you can adjust the time and alarm clock settings manually if you are not getting the time from your WiFi network.</p>"},{"location":"kits/oled-large/#component-list","title":"Component List","text":"<ul> <li>Raspberry Pi W</li> <li>128x64 SSD1306 OLED display on SPI bus</li> <li>DS3231 real-time clock on I2C bus</li> <li>3 momentary push buttons</li> </ul>"},{"location":"kits/oled-large/#kit-assembly","title":"Kit Assembly","text":"<p>If you have received a clock kit you can proceed directly to the Assembly Instructions.</p> <p>Once your kit is assembled you can the start to program your clock.</p>"},{"location":"kits/oled-large/#programming","title":"Programming","text":""},{"location":"kits/oled-large/#step-1-setting-up-your-desktop-and-loading-micropython","title":"Step 1: Setting up your Desktop and Loading MicroPython","text":"<p>We cover the desktop setup and loading MicroPython in our Desktop Setup</p>"},{"location":"kits/oled-large/#blink-the-builtin-led","title":"Blink the Builtin LED","text":"<p>Go to the Blink Lab</p>"},{"location":"kits/oled-large/#hello-world","title":"Hello World","text":"<p>Your first program is our \"Hello World!\" program for this kit. This is a great way to tell if your display connections are all working.  We have one version that prints to the Thonny console and one version that prints to the OLED display.</p> <p>Go to the Hello World! Program</p>"},{"location":"kits/oled-large/#display-config","title":"Display Config","text":"<p>Most of our sample programs read the hardware settings from a configuration file called <code>config.py</code>.  This program shows you how to show the configuration parameters on the display.</p> <p>Go to the Display Config Lab</p>"},{"location":"kits/oled-large/#display-raw-localtime","title":"Display Raw Localtime","text":"<p>Date and time information is stored in a set of 6-8 integers.  This first program just shows the raw integers on the display from the  <code>localtime()</code> function.  Not very pretty, but the program is pretty short and simple.</p> <p>Go to the Display Localtime Raw</p>"},{"location":"kits/oled-large/#set-the-rtc-from-localtime","title":"Set the RTC from Localtime","text":"<p>Once you add your RTC to the kit you will need to set the time inside the RTC memory.  The best way to do this is to just grab the time from the MicroPython localtime() which is set from your local computer when you connect your Pico using Thonny.</p> <p>Set the RTC from Localtime</p> <p>After you run this program your clock will be accurate to within two seconds per month.  The backup lithium battery will remember the time even when the clock is not plugged in or there is a power outage.  The battery will last about 8 years.</p>"},{"location":"kits/oled-large/#display-single-large-digit","title":"Display Single Large Digit","text":"<p>Display Single Digit</p>"},{"location":"kits/oled-large/00-blink/","title":"Blink The Onboard LED","text":"<p>Our first program will just blink the on-board LED on the Raspberry Pi Pico. It is a great way to tell if you got Thonny installed correctly and that your computer can connect to the Raspberry Pi Pico. Use the \"copy\" icon in the upper right corner to copy the code below into your pastebuffer.  Then open Thonny and paste it into a new file in your Thonny editor (or other Python programming tool). Then press the \"Run\" button.  You should see the small green LED on the Pico flashing on and off every second.</p> <pre><code># Setup - run once\nfrom machine import Pin # Get the Pin function from the machine module.\nfrom time import sleep # Get the sleep library from the time module.\n\n# This is the built-in green LED on the standard Pico.\n# BUILT_IN_LED_PIN = 25\n# On the Pico \"W\" we use the symbolic \"name\" of \"LED\", not a pin number\nBUILT_IN_LED_PIN = Pin(\"LED\", Pin.OUT)\n\n# The line below indicates we are configuring this as an output (not input)\nled = Pin(BUILT_IN_LED_PIN, Pin.OUT)\n\n# Main loop: Repeat the forever...\nwhile True:\n    led.high() # turn on the LED\n    sleep(0.5) # leave it on for 1/2 second\n    led.low()  # Turn off the LED\n    sleep(0.5) # leave it off for 1/2 second\n</code></pre> <p>When you run this program, the built-in LED on the Pico will blink every second.</p> <p>Challenges</p> <ol> <li>Change the delay time to be <code>0.25</code> seconds on and <code>0.25</code> second off.</li> <li>How fast can you make the LED blink?</li> <li>Go to the original MicroPython for Kids website and search for the term \"blink\" in the search form in the upper right.  What variations of blink are there in other kits?</li> <li>If you have any LEDs and 330 ohm resistors, try adding them to the breadboard and getting the external LED to blink.  See this lab for sample code.</li> </ol>"},{"location":"kits/oled-large/00-blink/#debugging-tips","title":"Debugging Tips.","text":"<p>If you are not getting any response when you click the \"Run\" button, try checking that your desktop computer is communicating with the Raspberry Pi Pico through the USB cable.</p> <p>See the Setup Desktop Debugging Tips page for tips on how to make sure your connection is working.</p>"},{"location":"kits/oled-large/01-assembly/","title":"Large OLED Assembly","text":"<p>Here are your assembly instructions for the Large OLED clock kit. This kit comes with a Raspberry Pi W, a nice large 2.24\" OLED display and a DS3132 real-time clock.  You can also optionally mount a speaker for an alarm clock. Time can be set using three buttons (mode-set, increment (+) and decrement (-))</p>"},{"location":"kits/oled-large/01-assembly/#kit-parts-list","title":"Kit Parts List","text":"<ol> <li>Plexiglass base with holes in front</li> <li>4 felt pads for the feet</li> <li>Breadboard - 1/2 size - 30 rows - 400 ties</li> <li>Raspberry Pi Pico W with header pins installed</li> <li>OLED display (2.42\" 128X64)</li> <li>7 wire display cable (20cm M-F)</li> <li>Real time clock (DS3132)</li> <li>CR2032 coin-cell battery</li> <li>4-wire real-time clock cable (20cm M-F)</li> <li>3 momentary push buttons - long for set, short for +/-</li> <li>5 black ground wires for buttons</li> <li>3 button wires (yellow, blue and green)</li> <li>1 red power jumper (3.3 to bus)</li> <li>3 cable ties</li> <li>USB connector (A to micro)</li> <li>5-volt USB power adapter</li> </ol>"},{"location":"kits/oled-large/01-assembly/#assembly-steps","title":"Assembly Steps","text":""},{"location":"kits/oled-large/01-assembly/#prepare-plexiglass-base","title":"Prepare Plexiglass Base","text":"<p>Peal the protective backing off of both sides of the plexiglass base. You might need to use your fingernails or a knife to peal up the corner.</p>"},{"location":"kits/oled-large/01-assembly/#attach-felt-pads-to-base","title":"Attach Felt Pads to Base","text":"<p>Attach the 4 felt pads to the corners of the base  by pealing the release liner off each pad and placing  each one in each corner.  If you are using cable ties on the display, make sure you leave room for the cable ties and positions the felt pads in about 1/4 of an  inch from the side edges.</p> <p>This will be the bottom of your clock.</p> <p></p>"},{"location":"kits/oled-large/01-assembly/#attach-breadboard-to-base","title":"Attach Breadboard to Base","text":"<p>Peal off the release liner for the solderless 1/2 breadboard and place it  in the center of the top base with row 1 on the right and row 30 on the left as you face from the front of the clock.  Note that the top of the breadboard is row 1 and the bottom is row 30.</p>"},{"location":"kits/oled-large/01-assembly/#install-pico-w-on-breadboard","title":"Install Pico W on Breadboard","text":"<p>Put the Raspberry Pi Pico W into the breadboard making sure that USB  connector is at the top of the breadboard (row 1) and the pins are  aligned like the diagram.  The header pins on the Raspberry Pi Pico W will be in columns \"c\" and \"h\".</p>"},{"location":"kits/oled-large/01-assembly/#33-v-red-bus-jumper","title":"3.3 V Red Bus Jumper","text":"<p>Use the red jumper wire to connect right row 5 (3.3 OUT) to the red power bus on the right. Both the OLED display and the real-time clock will connect their power to this right power rail.</p>"},{"location":"kits/oled-large/01-assembly/#black-ground-jumper","title":"Black Ground Jumper","text":"<p>Attach the black jumper wire from row 8 on the right to the blue bus GND. Note all rows that end in the digit <code>3</code> or <code>8</code> are <code>GND</code> (3,8,13,18). Your breadboard may have a black mark on the breadboard on these rows. This connection allows the entire left power rail to be GND.</p>"},{"location":"kits/oled-large/01-assembly/#add-buttons","title":"Add Buttons","text":"<p>Place the three buttons on the breadboard over the center trough oriented so that the  legs of the buttons are on opposite sides of the center trough and closing  the switch will close the connection between the rows of the breadboard when pressed.</p> <p>The internal connections of the buttons is shown below:</p> <p></p>"},{"location":"kits/oled-large/01-assembly/#wire-buttons","title":"Wire Buttons","text":"<p>We are now ready to wire the three buttons up.  Their job is to connect the pins on the lower left corner of the Pico W to GND when they are pressed.  Each button has GND on the lower-left pin and signal on the upper-left corner of the button.  The signal of the top button will go to row 17, the middle button to row 19  and the bottom button will go to row 20.</p> <p>A logical diagram of the button circuit is shown below:</p> <p></p> <p>Here are the pin assignments will use in later labs:</p> Breadboard Row GPIO Pin Function Row 17 GPIO 13 Set (Mode) Row 19 GPIO 14 Increment Row 20 GPIO 15 Decrement <p>Note</p> <p>If you have your software loaded, you can run the 'buttons-test-print.py' to verify that the buttons are all connected correctly.  This program will print the name of the button being pressed to the console.  This is a great way to tell if you have missed any button connections.</p>"},{"location":"kits/oled-large/01-assembly/#display-cable-to-oled","title":"Display Cable to OLED","text":"<p>Locate the 7-wire display cable harness.  It has female pins on one end and make pins on the other end.  The female pins will go into the OLED display.  Note that you must hoop up the black wire to the GND connection and the purple wire to the CS connection.  It is very easy to get this connection reversed, so double check the orientation.</p> <p></p>"},{"location":"kits/oled-large/01-assembly/#display-cable-to-breadboard","title":"Display Cable to Breadboard","text":"<p>Attached the display cable to the breadboard in the left side from rows 3 to 9. The orange wire should be in row 4, yellow in 5, green in 6, blue in 7, black in 8 and purple in 9.</p> <p>Next, connect the red wire to the right side red power rail (3.3 volts)</p> <p>Double check that the black wire is on the GND pin (row 8). Make sure that the red wire is attached to right red positive power rail.</p>"},{"location":"kits/oled-large/01-assembly/#install-the-coin-cell-battery-in-the-rtc","title":"Install the Coin Cell Battery in the RTC","text":"<p>Place the CR2032 coin cell battery in the real-time clock (RTC) making sure the  positive side is on the top.  The coin cell battery needs to be tucked under the metal connector and pressed down.  You may need a small screw driver to pry the batter back up to change it.  Most </p>"},{"location":"kits/oled-large/01-assembly/#rtc-cable-to-rtc","title":"RTC Cable to RTC","text":"<p>Attach the 4-wire cable to there real time clock making sure that the black GND and the red VCC are connect to the correct pins, SDA is yellow and SCL is orange.  The SQW and 32K pins are not used.</p>"},{"location":"kits/oled-large/01-assembly/#rtc-cable-to-breadboard","title":"RTC Cable to Breadboard","text":"<p>Attach the other of the 4-wire real-time clock cable to the breadboard. Connect yellow to row 1 on the left (GPIO 0) and orange on row 2 on the left (GPIO 1). Connect the red wire to the red power rail on the right and the black  wire to the GND on the right.</p>"},{"location":"kits/oled-large/01-assembly/#cable-ties","title":"Cable Ties","text":"<p>(Optional) You can use cable ties or twist ties to connect  the display and the RTC to the base through the holes. If you are planning to build your own case you can skip this step.</p>"},{"location":"kits/oled-large/01-assembly/#final-tests","title":"Final Tests","text":"<p>After you assemble your clock kit you will be abel to test the connections using MicroPython.  Here are some of the tests you will run:</p> <ol> <li> <p>Use the blink to verify that your USB connection is not blocked by your PC/Mac and you have downloaded the correct version of the MicroPython runtime.</p> </li> <li> <p>Use the i2c scanner to verify that your real-time clock is connected correctly.</p> </li> <li> <p>Use the hello world program to test if your display is connected correctly.</p> </li> <li> <p>Use the button test program to test to see if your buttons are connected correctly.</p> </li> </ol>"},{"location":"kits/oled-large/01-assembly/#troubleshooting","title":"Troubleshooting","text":"<p>You can use generative AI tool like ChatGPT or Anthropic Claude to help you debug the clock.  Make sure you give a complete description of your problem using the following prompt template.</p> <p>Prompt</p> <p>Please help me diagnose a problem I am having with MicroPython program running on the Raspberry Pi Pico W.  I am using a Mac to connect to the Pico with Thonny.  I am using Thonny version 4.1.6 and Mac OS 15.0.1. When I run <code>ls /dev/cu*</code> I can see the device listed.  When I press the Stop/Restart backend button I see the MicroPython version X on the console.</p> <p>However, when I run X I get the following error: ...</p>"},{"location":"kits/oled-large/01-hello-world/","title":"Hello World","text":""},{"location":"kits/oled-large/01-hello-world/#displaying-hello-world-on-your-console","title":"Displaying \"Hello World!\" on your console","text":"<p>Here is the classic \"Hello World\" in MicroPython</p> <pre><code>print(\"Hello World!\")\n</code></pre> <p>You can type this program into Thonny and run it to see if your USB is connected and the MicroPython runtime is loaded correctly.</p>"},{"location":"kits/oled-large/01-hello-world/#displaying-hello-word-on-your-display","title":"Displaying Hello Word On your Display","text":"<p>To get started, let's just draw the string \"Hello world!\" on the display.</p> <p></p> <p>Here is the code:</p> <pre><code>import machine\nimport ssd1306\n\n# customize these numbers if your hardware config is different\nSCL=machine.Pin(2) # SPI CLock\nSDA=machine.Pin(3) # SPI Data\nRES = machine.Pin(4) # Reset\nDC = machine.Pin(5) # Data/command\nCS = machine.Pin(6) # Chip Select\n\nspi=machine.SPI(0, sck=SCL, mosi=SDA)\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\n# erase the entire screen with black (0=black)\noled.fill(0)\n\n# place a hello message at point (0,0) in white (1=white text)\noled.text(\"Hello world!\", 0, 0, 1)\n\n# send the entire frame buffer to the display via the SPI bus\noled.show()\n</code></pre> <p>Challenges</p> <ol> <li>Can you change the message from \"Hello world!\" to have your name in it?</li> <li>Can you change the location of the text on the screen by changing the location point from (0,0) to another place on the screen?  The screen is 128 pixels wide by 64 pixels high.</li> <li>How far down can you display the message without going off the screen?</li> <li>How many characters wide can a message be before it goes off the right edge of the dipsplay?</li> <li>Can you display multiple messages on different lines?</li> </ol>"},{"location":"kits/oled-large/02-display-config/","title":"Display Configuration File Data","text":"<p>This program will display the configuration file (config.py) parameters on your display.</p> <pre><code>from machine import Pin\nimport ssd1306\nimport config\n\nSCL=Pin(config.SPI_SCL_PIN)\nSDA=Pin(config.SPI_SDA_PIN)\nDC = Pin(config.SPI_DC_PIN)\nRES = Pin(config.SPI_RESET_PIN)\nCS = Pin(config.SPI_CS_PIN)\nSPI_BUS = config.SPI_BUS\nWIDTH = config.DISPLAY_WIDTH\nHEIGHT = config.DISPLAY_HEIGHT\n\nspi=machine.SPI(SPI_BUS, sck=SCL, mosi=SDA, baudrate=1000000)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\n# place a hello message at point (0,0) in white\noled.text(\"Config:\", 0, 0, 1)\n\n# row 2\noled.text(\"SCL:\" + str(config.SPI_SCL_PIN), 0, 10, 1)\noled.text(\"SDA:\" + str(config.SPI_SDA_PIN), 50, 10, 1)\n\n# row 3\noled.text(\"DC:\" + str(config.SPI_DC_PIN),     0, 20, 1)\noled.text(\"RES:\" + str(config.SPI_RESET_PIN), 50, 20, 1)\n\n# row 4\noled.text(\"CS:\" + str(config.SPI_CS_PIN), 0, 30, 1)\noled.text(\"SPI BUS:\" + str(config.SPI_BUS), 50, 30, 1)\n\n# row 5\noled.text(\"Width:\" + str(config.DISPLAY_WIDTH), 0, 40, 1)\noled.text(\"Height:\" + str(config.DISPLAY_HEIGHT), 0, 50, 1)\n\noled.show()\n</code></pre>"},{"location":"kits/oled-large/02-i2c-scanner/","title":"I2C Scanner Test","text":"<p>This program will verify that your RTC clock is connected correctly to your Raspberry Pi Pico.</p> <pre><code>from machine import I2C, Pin\nimport config\n\nDST_PIN = 0\nCLK_PIN = 1\n\nprint(\"Data DST on pin: \", DST_PIN)\nprint(\"Clock CLK on pin: \", CLK_PIN)\n\ni2c = I2C(0, scl=Pin(CLK_PIN), sda=Pin(DST_PIN), freq=800000)\n\nscan_result = i2c.scan()\n\nprint(scan_result)\n\nprint(\"I2C addresses found:\", [hex(device_address) for device_address in i2c.scan()])\n</code></pre> <p>This will return a list of the I2C addresses found on your I2C Bus 0. If your DS3231 real-time clock has an address of 0x68 (hex) which is 104 decimal.</p> <p>You will also see a second I2C address for the EEPROM which is  0x50 (hex) and 80 decimal.  These numbers may vary if you purchased different versions of a real-time clock.</p> <p>For details see the section on Real Time Clocks.</p>"},{"location":"kits/oled-large/02-set-rtc-from-localtime/","title":"Set RTC form the localtime","text":"<p>When you plug your Pico into your PC and use the Thonny IDE, the MicroPython runtime will startup and get the time from your desktop or laptop computer's clock and set the MicroPython runtimes localtime() with this time.</p> <p>Note</p> <p>You can disable the Thonny localtime if you want to test the RTC functions.</p>"},{"location":"kits/oled-large/02-set-rtc-from-localtime/#setting-the-rtc-using-the-ds3231","title":"Setting The RTC using the DS3231","text":"<p>This is a full raw way to set the DS3231 RTC from the MicroPython localtime. You should only need to run this program when you first connect your RTC chip. After you run it the clock should be accurate within 2-seconds per month. In many cases when the clock is at room temperature the accuracy will be higher.</p> <pre><code>from machine import Pin, I2C\nfrom utime import localtime\n\n# Constants\nDS3231_ADDR = 0x68\nSTATUS_REG = 0x0F  # Status register address\n\n# I2C setup\nsda = Pin(0)\nscl = Pin(1)\ni2c = I2C(0, scl=scl, sda=sda, freq=100000)\n\ndef dec2bcd(dec):\n    \"\"\"Convert decimal to binary coded decimal.\"\"\"\n    return (dec // 10) &lt;&lt; 4 | (dec % 10)\n\ndef check_osf():\n    \"\"\"Check the oscillator stop flag.\"\"\"\n    status = i2c.readfrom_mem(DS3231_ADDR, STATUS_REG, 1)[0]\n    return bool(status &gt;&gt; 7)\n\ndef reset_osf():\n    \"\"\"Clear the oscillator stop flag.\"\"\"\n    status = bytearray(1)\n    i2c.readfrom_mem_into(DS3231_ADDR, STATUS_REG, status)\n    i2c.writeto_mem(DS3231_ADDR, STATUS_REG, bytearray([status[0] &amp; 0x7f]))\n\ndef set_ds3231():\n    \"\"\"Set the DS3231 RTC time and ensure oscillator is running.\"\"\"\n    now = localtime()\n    year = now[0] % 100  # Convert to 2-digit year\n    month = now[1]\n    day = now[2]\n    hour = now[3]\n    minute = now[4]\n    second = now[5]\n\n    # First check if oscillator is stopped\n    if check_osf():\n        print(\"Oscillator was stopped. Resetting OSF flag...\")\n        reset_osf()\n\n    data = bytearray([\n        dec2bcd(second),\n        dec2bcd(minute),\n        dec2bcd(hour),\n        dec2bcd(now[6] + 1),  # Convert weekday from 0-6 to 1-7\n        dec2bcd(day),\n        dec2bcd(month),\n        dec2bcd(year)\n    ])\n\n    i2c.writeto_mem(DS3231_ADDR, 0x00, data)\n    print(f\"RTC set to: {month}/{day}/{now[0]} {hour:02d}:{minute:02d}:{second:02d}\")\n\n    # Verify oscillator is running\n    if check_osf():\n        print(\"Warning: Oscillator still shows stopped state!\")\n    else:\n        print(\"Oscillator running normally\")\n\nif __name__ == \"__main__\":\n    set_ds3231()\n</code></pre>"},{"location":"kits/oled-large/02-set-rtc-from-localtime/#setting-the-rtc-using-the-ds1307","title":"Setting the RTC using the DS1307","text":"<pre><code># set the localtime from the DS1307 RTC\nfrom machine import Pin, I2C\nfrom utime import localtime\nfrom ds1307 import DS1307\nimport config\n\nsda = Pin(config.I2C_SDA_PIN)\nscl = Pin(config.I2C_SCL_PIN)\nI2C_BUS = config.I2C_BUS\nRTC_TYPE = config.RTC_TYPE\nRTC_I2C_ADDR = config.RTC_I2C_ADDR\n\n# I2C setup\ni2c = I2C(I2C_BUS, scl=scl, sda=sda, freq=3000000)\nprint(i2c.scan())\nrtc = DS1307(addr=RTC_I2C_ADDR, i2c=i2c)\nprint(\"DS1307 is on I2C address 0x{0:02x}\".format(rtc.addr))\nprint(\"Before setting the time the RTC clock had: \", rtc.datetime)\nprint(\"Localtime: \", localtime())\n\n# Set the local time\nrtc.datetime = localtime()\n\nprint(\"After setting the time from local time the RTC had: \", rtc.datetime)\n\n# Print the date and time in ISO8601 format: 2023-04-18T21:14:22\nprint(\"Today is {:04d}-{:02d}-{:02d}T{:02d}:{:02d}:{:02d} weekday:{}\".format(\n    rtc.year, rtc.month, rtc.day,\n    rtc.hour, rtc.minute, rtc.second, rtc.weekday))\n</code></pre>"},{"location":"kits/oled-large/03-display-localtime-raw/","title":"Display the Raw Localtime","text":"<pre><code>from machine import Pin, SPI\nimport ssd1306\nfrom time import localtime, sleep\nimport config\n\n# get the configuration data\nSCL=Pin(config.SPI_SCL_PIN)\nSDA=Pin(config.SPI_SDA_PIN)\nDC = Pin(config.SPI_DC_PIN)\nRES = Pin(config.SPI_RESET_PIN)\nCS = Pin(config.SPI_CS_PIN)\nSPI_BUS = config.SPI_BUS\nWIDTH = config.DISPLAY_WIDTH\nHEIGHT = config.DISPLAY_HEIGHT\n\nspi=machine.SPI(SPI_BUS, sck=SCL, mosi=SDA, baudrate=1000000)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\nwhile True:\n    # display the raw data from localtime\n    oled.fill(0)\n    oled.text(str(localtime()[0]), 0, 0, 1)\n    oled.text(str(localtime()[1]), 0, 10, 1)\n    oled.text(str(localtime()[2]), 0, 20, 1)\n    oled.text(str(localtime()[3]), 0, 30, 1)\n    oled.text(str(localtime()[4]), 0, 40, 1)\n    oled.text(str(localtime()[5]), 0, 50, 1)\n    oled.show()\n    sleep(1)\n</code></pre> <p>Challenges</p> <ol> <li>What numbers are fixed and what numbers arc chainging?</li> <li>What do you think each of the numbers mean?</li> <li>Why is it hard to read the time using this \"raw\" unformatted way?</li> </ol>"},{"location":"kits/oled-large/04-display-localtime-formatted/","title":"Display Local Time Formatted","text":"<p>That last program did display the correct local time, but it was hard to read.</p> <p>In this version we will extract data time values,  and then display a formatted version of both the date and the time.</p> <pre><code>from machine import Pin, SPI\nimport ssd1306\nfrom time import localtime\nimport config\n\nSCL=Pin(config.SPI_SCL_PIN)\nSDA=Pin(config.SPI_SDA_PIN)\nDC = Pin(config.SPI_DC_PIN)\nRES = Pin(config.SPI_RESET_PIN)\nCS = Pin(config.SPI_CS_PIN)\nSPI_BUS = config.SPI_BUS\nWIDTH = config.DISPLAY_WIDTH\nHEIGHT = config.DISPLAY_HEIGHT\n\nspi=machine.SPI(SPI_BUS, sck=SCL, mosi=SDA, baudrate=1000000)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\nwhile True:\n    year = localtime()[0]\n    month = localtime()[1]\n    day = localtime()[2]\n    hour = localtime()[3]\n    minute = localtime()[4]\n    second = localtime()[5]\n\n    # display in 12 hour time paying special attention with hour == 0 and hour == 12\n    if hour == 0:\n        # Midnight edge case\n        hour = 12\n        am_pm = 'AM'\n    elif hour == 12:\n        # Noon edge case\n        am_pm = 'PM'\n    elif hour &gt; 12:\n        # Afternoon hours\n        hour -= 12\n        am_pm = 'PM'\n    else:\n        # Morning hours\n        am_pm = 'AM'\n\n    oled.fill(0)\n    # display the date on the first line\n    oled.text(str(month) + \"/\" + str(day) + \"/\" + str(year), 0, 0, 1)\n\n    # display the time in hours, minute and seconds on the second line\n    # note that the \":02\" indicates printing in two columns with leading zeros\n    oled.text(f\"{hour}:{minute:02}:{second:02} \" + am_pm, 0, 10, 1)\n\n    oled.show()\n</code></pre>"},{"location":"kits/oled-large/04-display-localtime-formatted/#time-formatting","title":"Time formatting","text":"<p>When we print out minutes and seconds we want to make sure that we print them in two digits with a leading zero.</p> <pre><code>f\"{minute:02}:{second:02}\"\n</code></pre> <p>The python modulo operator <code>%</code> is used to find the remainder of the hour after dividing by 12.  This converts the 24-hour time to 12-hour time.</p>"},{"location":"kits/oled-large/05-button-test/","title":"Testing Your  Buttons","text":"<p>The diagram above shows three buttons below the Pico that will connect GPIO pins 13, 14 and 15 to GND when they are pressed. When they are not pressed the signals on 13, 14 and 15 must be \"pulled up\" to 5 volts using the internal pull-up resistor within the Pico.  We configure this when we setup the code.</p>"},{"location":"kits/oled-large/05-button-test/#sample-code","title":"Sample Code","text":""},{"location":"kits/oled-large/05-button-test/#single-button-test","title":"Single Button Test","text":"<pre><code>from utime import sleep\nfrom machine import Pin\n\n# Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler\n\n# Buttons\nBUTTON_1_PIN = 13\n\nbutton_1_pin = Pin(BUTTON_1_PIN, Pin.IN, Pin.PULL_UP)\n\n# This function gets called every time the button is pressed.  The parameter \"pin\" is not used.\ndef button_1_pressed(pin):\n    print('Button 1 pressed')\n\n# now we register the button handler function using the irq setter method for this pin\nbutton_1_pin.irq(trigger=Pin.IRQ_FALLING, handler = button_1_pressed)\n\nwhile True:\n    sleep(1)\n</code></pre>"},{"location":"kits/oled-large/05-button-test/#three-button-test","title":"Three Button Test","text":"<pre><code>from utime import sleep\nfrom machine import Pin\n\n# Sample Raspberry Pi Pico MicroPython three button press example\n\n# Button Pin GPIO Configuration\nBUTTON_1_PIN = 13\nBUTTON_2_PIN = 14\nBUTTON_3_PIN = 15\n\n# Create 3 button objects as inputs with pullup resistors\nbutton_1_pin = Pin(BUTTON_1_PIN, Pin.IN, Pin.PULL_UP)\nbutton_2_pin = Pin(BUTTON_2_PIN, Pin.IN, Pin.PULL_UP)\nbutton_3_pin = Pin(BUTTON_3_PIN, Pin.IN, Pin.PULL_UP)\n\n# These functions gets called every time a button is pressed.\ndef button_1_pressed(pin):\n    print('Button 1 pressed')\ndef button_2_pressed(pin):\n    print('Button 2 pressed')\ndef button_3_pressed(pin):\n    print('Button 3 pressed')\n\n# now we register the button handler functions using the irq setter method for each pin\nbutton_1_pin.irq(trigger=Pin.IRQ_FALLING, handler = button_1_pressed)\nbutton_2_pin.irq(trigger=Pin.IRQ_FALLING, handler = button_2_pressed)\nbutton_3_pin.irq(trigger=Pin.IRQ_FALLING, handler = button_3_pressed)\n\n# we don't do anything in the main loop but sleep\nwhile True:\n    sleep(1)\n</code></pre>"},{"location":"kits/oled-large/05-rtc/","title":"Working with the DS3232 Real Time Clock","text":""},{"location":"kits/oled-large/05-rtc/#printing-the-raw-time-data","title":"Printing The Raw Time Data","text":"<pre><code>from machine import Pin, I2C\nimport ds3231\n\n# it is more portable to read the pins from the config.py file\ni2c = I2C(0, sda=Pin(0), scl=Pin(1))\nrtc = ds3231.DS3231(i2c)\n\nprint(rtc.datetime())\n</code></pre> <p>Result: <pre><code>(2025, 1, 31, 5, 11, 18, 13, 0)\n</code></pre></p> <p>Note that this is an 8-value tuple format, not the standard 7 values.</p>"},{"location":"kits/oled-large/05-rtc/#using-the-hardware-config-file","title":"Using the Hardware Config File","text":"<pre><code>from machine import Pin, I2C\nimport ds3231\nimport config\n\ni2c = I2C(0, sda=Pin(config.I2C_SDA_PIN), scl=Pin(config.I2C_SCL_PIN))\nrtc = ds3231.DS3231(i2c)\n\nprint(rtc.datetime())\n</code></pre>"},{"location":"kits/oled-large/05-rtc/#formatting-time-in-iso-format","title":"Formatting Time in ISO format","text":"<pre><code>from machine import Pin, I2C\nimport ds3231\nimport config\n\ni2c = I2C(0, sda=Pin(config.I2C_SDA_PIN), scl=Pin(config.I2C_SCL_PIN))\nrtc = ds3231.DS3231(i2c)\n\ndef format_time(datetime_tuple):\n    # Unpack the 8-value tuple\n    year, month, day, hour, minute, second, subseconds, weekday = datetime_tuple\n\n    # Convert to 12-hour format\n    am_pm = \"AM\" if hour &lt; 12 else \"PM\"\n    hour_12 = hour if hour &lt;= 12 else hour - 12\n    if hour_12 == 0:\n        hour_12 = 12\n\n    # Create day and month lookup tables\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    months = ['January', 'February', 'March', 'April', 'May', 'June', \n              'July', 'August', 'September', 'October', 'November', 'December']\n\n    # Use 'd' instead of '02d' for hours to remove leading zero\n    return f\"{days[weekday]}, {months[month-1]} {day}, {year} {hour_12}:{minute:02d}:{second:02d} {am_pm}\"\n\ndatetime = rtc.datetime()\nprint(format_time(datetime))\n</code></pre>"},{"location":"kits/oled-large/05-rtc/#setting-the-ds3232-trc-from-localtime","title":"Setting the DS3232 TRC from Localtime","text":"<p>Prompt</p> <p>Please write a detailed step-by-step explanation of the set-ds3231-rtc-from-localtime.py program.  Assume your reader is a junior high student that is just learning Python for the first time.</p> <p>I'll explain how this program works step by step, focusing on what each part does in simple terms.</p>"},{"location":"kits/oled-large/05-rtc/#1-setting-up-the-rtc-real-time-clock","title":"1. Setting Up the RTC (Real-Time Clock):","text":"<p><pre><code>from machine import Pin, I2C\nimport ds3231\nimport config\nfrom time import localtime\n\ni2c = I2C(config.I2C_BUS, sda=Pin(config.I2C_SDA_PIN), scl=Pin(config.I2C_SCL_PIN))\nrtc = ds3231.DS3231(i2c)\n</code></pre> This part connects to a special clock chip called DS3231 using two wires (I2C communication). Think of it like plugging in a digital clock.</p>"},{"location":"kits/oled-large/05-rtc/#2-the-format_time-function","title":"2. The <code>format_time</code> Function:","text":"<p><pre><code>def format_time(datetime_tuple):\n    year, month, day, weekday, hour, minute, second, subseconds = datetime_tuple\n</code></pre> This function takes time information and makes it look nice for humans to read. For example, instead of showing \"1\" for January, it shows \"January\".</p> <p>The function converts 24-hour time to 12-hour time with AM/PM: <pre><code>am_pm = \"AM\" if hour &lt; 12 else \"PM\"\nhour_12 = hour if hour &lt;= 12 else hour - 12\nif hour_12 == 0:\n    hour_12 = 12\n</code></pre> So 13:00 becomes 1:00 PM.</p>"},{"location":"kits/oled-large/05-rtc/#3-the-verify_time-function","title":"3. The <code>verify_time</code> Function:","text":"<p><pre><code>def verify_time(local_time):\n    l_year, l_month, l_day, l_hour, l_min, l_sec, l_wday, l_yday = local_time\n</code></pre> This function is like a safety check. It makes sure the time makes sense: - Years must be between 2000 and 2099 - Months must be between 1 and 12 - Hours must be between 0 and 23 - And so on</p>"},{"location":"kits/oled-large/05-rtc/#4-setting-the-time","title":"4. Setting the Time:","text":"<p><pre><code>local = localtime()\nprint(\"\\nSystem local time:\")\nprint(f\"Year: {local[0]}, Month: {local[1]}, Day: {local[2]}\")\n</code></pre> The program gets the current time from your computer or microcontroller and shows it to you.</p>"},{"location":"kits/oled-large/05-rtc/#5-final-step-updating-the-rtc","title":"5. Final Step - Updating the RTC:","text":"<pre><code>if verify_time(local):\n    rtc_weekday = local[6] + 1\n    new_time = (\n        local[0],     # year\n        local[1],     # month\n        local[2],     # day\n        local[3],     # hour\n        local[4],     # minute\n        local[5],     # second\n        rtc_weekday   # weekday (1-7, Monday=1)\n    )\n    rtc.datetime(new_time)\n</code></pre> <p>If all the safety checks pass, it updates the RTC chip with the new time. The program then shows you the new time to confirm it worked.</p> <p>This program is like setting a digital clock, but instead of pressing buttons, it automatically sets the time using your computer's time. The RTC chip will keep tracking time even if you unplug your project, just like how a digital clock keeps time even when unplugged (it uses a small battery).</p>"},{"location":"kits/oled-large/05-rtc/#full-program-listing","title":"Full Program Listing","text":"<pre><code>from machine import Pin, I2C\nimport ds3231\nimport config\nfrom time import localtime\n\n# Initialize I2C and RTC\ni2c = I2C(config.I2C_BUS, sda=Pin(config.I2C_SDA_PIN), scl=Pin(config.I2C_SCL_PIN))\nrtc = ds3231.DS3231(i2c)\n\ndef format_time(datetime_tuple):\n    # Unpack the 8-value tuple returned by rtc.datetime()\n    # Format is: year, month, day, weekday, hour, minutes, seconds, subseconds\n    year, month, day, weekday, hour, minute, second, subseconds = datetime_tuple\n\n    # Convert to 12-hour format\n    am_pm = \"AM\" if hour &lt; 12 else \"PM\"\n    hour_12 = hour if hour &lt;= 12 else hour - 12\n    if hour_12 == 0:\n        hour_12 = 12\n\n    # Create day and month lookup tables\n    # weekday in RTC is 1-7 (Monday=1, Sunday=7)\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    months = ['January', 'February', 'March', 'April', 'May', 'June', \n              'July', 'August', 'September', 'October', 'November', 'December']\n\n    # Adjust weekday to 0-based index for days list\n    weekday_index = weekday - 1\n\n    return f\"{days[weekday_index]}, {months[month-1]} {day}, {year} {hour_12}:{minute:02d}:{second:02d} {am_pm}\"\n\ndef verify_time(local_time):\n    \"\"\"\n    Verify that local_time values are within acceptable bounds\n    Returns: True if time appears valid, False otherwise\n    \"\"\"\n    # Unpack tuple\n    l_year, l_month, l_day, l_hour, l_min, l_sec, l_wday, l_yday = local_time\n\n    # Basic bounds checking\n    if not (2000 &lt;= l_year &lt;= 2099):\n        print(\"Error: Year out of range (2000-2099)\")\n        return False\n    if not (1 &lt;= l_month &lt;= 12):\n        print(\"Error: Month out of range (1-12)\")\n        return False\n    if not (1 &lt;= l_day &lt;= 31):\n        print(\"Error: Day out of range (1-31)\")\n        return False\n    if not (0 &lt;= l_hour &lt;= 23):\n        print(\"Error: Hour out of range (0-23)\")\n        return False\n    if not (0 &lt;= l_min &lt;= 59):\n        print(\"Error: Minute out of range (0-59)\")\n        return False\n    if not (0 &lt;= l_sec &lt;= 59):\n        print(\"Error: Second out of range (0-59)\")\n        return False\n\n    return True\n\n# Get current RTC time and print it\nprint(\"\\nCurrent RTC time before setting:\")\ncurrent_rtc_time = rtc.datetime()\nprint(format_time(current_rtc_time))\n\n# Get local time\nlocal = localtime()\nprint(\"\\nSystem local time:\")\nprint(f\"Year: {local[0]}, Month: {local[1]}, Day: {local[2]}\")\nprint(f\"Hour: {local[3]}, Minute: {local[4]}, Second: {local[5]}\")\nprint(f\"Weekday: {local[6]} (0=Monday, 6=Sunday)\")\n\n# Verify the time data\nif verify_time(local):\n    # Convert weekday from localtime (0-6, Monday=0) to RTC format (1-7, Monday=1)\n    rtc_weekday = local[6] + 1\n\n    # Create datetime tuple in correct order for rtc.datetime()\n    # According to the driver docstring:\n    # datetime : tuple, (0-year, 1-month, 2-day, 3-hour, 4-minutes[, 5-seconds[, 6-weekday]])\n    new_time = (\n        local[0],     # year\n        local[1],     # month\n        local[2],     # day\n        local[3],     # hour\n        local[4],     # minute\n        local[5],     # second\n        rtc_weekday   # weekday (1-7, Monday=1)\n    )\n\n    # Set the RTC\n    rtc.datetime(new_time)\n    print(\"\\nRTC time set successfully!\")\n\n    # Read back and print the new time\n    print(\"\\nNew RTC time after setting:\")\n    new_rtc_time = rtc.datetime()\n    print(format_time(new_rtc_time))\nelse:\n    print(\"\\nError: Time verification failed. RTC not set.\")\n</code></pre>"},{"location":"kits/oled-large/06-display-single-digit/","title":"Display a Single 7-Segment Digit","text":"<pre><code># Seven segment display configuration\nsegment_mapping = [\n    [1, 1, 1, 1, 1, 1, 0],  # 0\n    [0, 1, 1, 0, 0, 0, 0],  # 1\n    [1, 1, 0, 1, 1, 0, 1],  # 2\n    [1, 1, 1, 1, 0, 0, 1],  # 3\n    [0, 1, 1, 0, 0, 1, 1],  # 4\n    [1, 0, 1, 1, 0, 1, 1],  # 5\n    [1, 0, 1, 1, 1, 1, 1],  # 6\n    [1, 1, 1, 0, 0, 0, 0],  # 7\n    [1, 1, 1, 1, 1, 1, 1],  # 8\n    [1, 1, 1, 1, 0, 1, 1]   # 9\n]\n\ndef draw_digit(digit, x, y, width, height, thickness, color):\n    if digit &lt; 0:\n        return\n    segment_on = segment_mapping[digit]\n\n    # Horizontal segments\n    for i in [0, 3, 6]:\n        if segment_on[i]:\n            if i == 0:  # top\n                y_offset = 0\n            elif i == 3:  # bottom\n                y_offset = height - thickness\n            else:  # middle\n                y_offset = height // 2 - thickness // 2\n            oled.fill_rect(x, y + y_offset, width, thickness, color)\n\n    # Vertical segments\n    for i in [1, 2, 4, 5]:\n        if segment_on[i]:\n            if i == 1 or i == 5:  # upper\n                start_y = y\n                end_y = y + height // 2\n            else:  # lower\n                start_y = y + height // 2\n                end_y = y + height\n            x_offset = 0 if (i == 4 or i == 5) else width - thickness\n            oled.fill_rect(x + x_offset, start_y, thickness, end_y - start_y, color)\n</code></pre> <pre><code># Clock Lab 20: Draw Seven Segments\n# this lab uses the fill_rect function to draw the segments\nfrom machine import Pin\nimport utime\nimport ssd1306\nfrom utime import sleep, localtime\nimport config\n\nled = machine.Pin(25, machine.Pin.OUT)\n\nSCL=machine.Pin(config.SPI_SCL_PIN) # SPI CLock\nSDA=machine.Pin(config.SPI_SDA_PIN) # SPI Data\n\nRES = machine.Pin(config.SPI_RESET_PIN) # Reset\nDC = machine.Pin(config.SPI_DC_PIN) # Data/command\nCS = machine.Pin(config.SPI_CS_PIN) # Chip Select\n\nWIDTH = config.DISPLAY_WIDTH\nHEIGHT = config.DISPLAY_HEIGHT\nspi=machine.SPI(config.SPI_BUS, sck=SCL, mosi=SDA, baudrate=100000)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n\n# digit is the numer to display\n# x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thickness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thickness, color):\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottom, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thickness # bottom element\n      if (i==6):\n          yOffset = height // 2 - thickness // 2# bottom\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thickness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + height // 2\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thickness\n\n      oled.fill_rect(x+xOffset, startY, thickness, endY-startY, color)\n\noled.fill(0)\nw = 40 # digit width\nh = 64 # digit height\nx = (WIDTH // 2) - w // 2 # center - width\ny = 0 # upper left corner y\nt = 8\n\nwhile True:\n    for i in range(0, 10):\n        print(i)\n        # create an outline on px away from the drawing region\n        # oled.rect(x-2, y-2, w+4, h+4, 1)\n        # draw one digit\n        drawDigit(i, x, y, w, h, t, 1)\n        # draw a second digit\n        #drawDigit(i, x + w + 4, w, h, t, 1)\n        oled.text(str(i), 0, 54, 1)\n        oled.show()\n        sleep(2)\n        oled.fill(0)\n</code></pre>"},{"location":"kits/oled-large/07-set-rtc-time-with-buttons/","title":"Set the DS3231 RTC using Buttons","text":"<p>Prompt</p> <p>Please create a new program that allows the user to set the time in the DS3231 RTC using the three buttons. Use the main-v1.py as your starting point and merge in the code from 08-button-mode-with-debounce.py to change the mode from:</p> <p>mode 0 - clock running mode 1 - set hour with hour digits on screen flashing every 500ms mode 2 - set minute with minute digits on screen flashing every 500ms mode 3 - set am/pm with am/pm text flashing every 500ms</p>"},{"location":"kits/oled-large/07-set-rtc-time-with-buttons/#response","title":"Response","text":"<p>Key changes made:</p> <ol> <li>Integrated button handling with debounce from 08-button-mode-with-debounce.py</li> <li>Added flashing display elements based on current mode </li> <li>Modified time adjustment logic to work with RTC</li> <li>Simplified display code while maintaining core functionality</li> <li>Added proper button pin configuration from config.py</li> </ol> <p>Test the code by:</p> <ol> <li>Connect buttons to specified GPIO pins</li> <li>Press mode button to cycle through modes</li> <li>Use increment/decrement buttons to adjust time</li> <li>Verify display flashing in each mode</li> </ol> <p>```python</p>"},{"location":"kits/oled-large/10-clock-hands/","title":"Clock Hands","text":"<p>Now lets display the hands on a clock.  We will need to do a little math to calculate were on the clock face to draw the hands to from the center.</p> <pre><code>import machine\nimport ssd1306\nimport config\nfrom time import sleep, localtime\nimport math\n\nSCL=machine.Pin(config.SCL_PIN) # SPI CLock\nSDA=machine.Pin(config.SDA_PIN) # SPI Data\n\nRES = machine.Pin(config.RESET_PIN) # Reset\nDC = machine.Pin(config.DC_PIN) # Data/command\nCS = machine.Pin(config.CS_PIN) # Chip Select\n\nspi=machine.SPI(config.SPI_BUS, sck=SCL, mosi=SDA, baudrate=100000)\noled = ssd1306.SSD1306_SPI(config.WIDTH, config.HEIGHT, spi, DC, RES, CS)\nTWO_PI = 3.14159 * 2\n\nLENGTH = config.HEIGHT // 2\nCENTER_X = config.WIDTH // 2\nCENTER_Y = config.HEIGHT // 2\n\noled.fill(0)\n\nfor i in range(0,61):\n    radians = (i/60)*TWO_PI\n    x = int(math.sin(radians)*LENGTH)\n    y = -int(math.cos(radians)*LENGTH)\n    # print(i, radians, x, y, x, y)  \n    oled.line(CENTER_X, CENTER_Y, CENTER_X + x, CENTER_Y + y, 1)\n    oled.show()\n    sleep(.1)\n    oled.line(CENTER_X, CENTER_Y, CENTER_X + x, CENTER_Y + y, 0)\n</code></pre>"},{"location":"kits/oled-large/10-draw-seven-segments/","title":"Draw Seven Segments","text":""},{"location":"kits/oled-large/10-draw-seven-segments/#dight-to-segment-data","title":"Dight to Segment Data","text":"<pre><code>segmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n</code></pre>"},{"location":"kits/oled-large/10-draw-seven-segments/#draw-segment-function","title":"Draw Segment Function","text":"<p>Parameters:</p> <ol> <li>The digit to display - an integer in the range 0-9</li> <li>x of the upper left corner</li> <li>y of the upper left corner</li> <li>the width of the digit (about 20 is a good value)</li> <li>the height of the digit</li> <li>the thickness of each segment (3 or 4 are good values)</li> <li>the color (0=black, 1=white)</li> </ol> <pre><code># x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thickness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thickness, color):\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottem, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top row\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thickness # bottem element\n      if (i==6):\n          yOffset = height // 2 - thickness // 2# bottum\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thickness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + height // 2\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thickness\n\n      oled.fill_rect(x+xOffset, startY, thickness, endY-startY, color)\n</code></pre>"},{"location":"kits/oled-large/10-draw-seven-segments/#full-program","title":"Full Program","text":"<pre><code># Clock Lab 20: Draw Seven Segments\n# this lab uses the fill_rect function to draw the segments\nimport machine\nimport utime\nimport ssd1306\nfrom utime import sleep, localtime\nled = machine.Pin(25, machine.Pin.OUT)\n\nSCL=machine.Pin(2) # SPI CLock\nSDA=machine.Pin(3) # SPI Data\nspi=machine.SPI(0, sck=SCL, mosi=SDA, baudrate=100000)\n\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n\n# x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thickness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thickness, color):\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottem, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thickness # bottem element\n      if (i==6):\n          yOffset = height // 2 - thickness // 2# bottum\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thickness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + height // 2\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thickness\n\n      oled.fill_rect(x+xOffset, startY, thickness, endY-startY, color)\n\noled.fill(0)\noled.text('Lab 12: rect', 0, 0, 1)\nx = 10 # upper left corner x\ny = 10 # upper left corner y\nw = 20 # digit width\nh = 30 # digit height\nt = 3\n\nwhile True:\n    for i in range(0, 10):\n\n        print(i)\n        # create an outline on px away from the drawing region\n        oled.rect(x-2, y-2, w+4, h+4, 1)\n        # draw one digit\n        drawDigit(i, x, y, w, h, t, 1)\n        # draw a second digit\n        #drawDigit(i, x + w + 4, w, h, t, 1)\n        oled.text(str(i), 0, 54, 1)\n        oled.show()\n        sleep(2)\n        oled.fill(0)\n</code></pre>"},{"location":"kits/oled-large/11-draw-thickness/","title":"Draw Seven Segments with Thickness","text":""},{"location":"kits/oled-large/13-three-button-set/","title":"Three Button Set","text":""},{"location":"kits/oled-large/13-three-button-set/#set-time-modes","title":"Set Time Modes","text":"<pre><code>mode_names = ['run', 'set hour', 'set minute', 'set AM/PM']\n</code></pre> <p>We will create a new temporary array of date time values called <code>current_time</code>. This is a tuple of the values that the rtc.datetime() function needs to set a new time.  We will change it as the user presses the increment and decrement buttons.</p>"},{"location":"kits/oled-large/13-three-button-set/#update-strategy","title":"Update Strategy","text":"<p>Remember that I2C communication is very slow.  I2C calls should never be allowed in an IRQ context.  IRQ job is to set globals and finish without delay.  Moving update_rtc() from within an IRQ to the main loop is better than calling it in the IRQ. By setting a <code>pending_update</code> flag in the IRQ and checking it in the main loop, we can manage updates without blocking operations like this:</p> <pre><code># main loop\nwhile True:\n    # If we're in run mode and there's a pending update, update the RTC\n    if mode == 0 and pending_update:\n        update_rtc()  # This will update the RTC and clear the flag\n</code></pre> <p>We ONLY should update the RTC when we are going from mode=3 to mode=0 and we know that the user changed the hour, minute or AM/PM.  If these were not changed then we don't update the RTC.</p> <p>The code to update the RTC is in the <code>update_rtc()</code> which has access to two global variables, the current_time and another Boolean variable called <code>pending_update</code>.  When any of the hour, minute or AM/PM is changed, the <code>pending_update</code> is set to <code>True</code>.  Calling <code>update_rtc()</code> if pending_update is <code>False</code> does not change the RTC.</p> <p>Note that the format of the data coming OUT of the RTC is different than the format of the data we use to set the RTC.  To set the clock correctly we need to rearrange the tuple to match the expected format:</p> <ul> <li>From: (year, month, day, weekday, hour, minutes, seconds, subseconds)</li> <li>To:   (year, month, day, hour, minutes, seconds, weekday)</li> </ul> <pre><code>def update_rtc():\n    \"\"\"Update RTC with current time state\"\"\"\n    global current_time, pending_update\n    if pending_update:\n        # Rearrange the tuple to match the expected format:\n        # From: (year, month, day, weekday, hour, minutes, seconds, subseconds)\n        # To:   (year, month, day, hour, minutes, seconds, weekday)\n        rtc_tuple = (\n            current_time[0],  # year\n            current_time[1],  # month\n            current_time[2],  # day\n            current_time[4],  # hour\n            current_time[5],  # minutes\n            current_time[6],  # seconds\n            current_time[3]   # weekday\n        )\n        rtc.datetime(rtc_tuple)\n        pending_update = False\n</code></pre>"},{"location":"kits/oled-large/13-three-button-set/#mode-button-pressed-irq","title":"Mode Button Pressed IRQ","text":"<pre><code>def mode_button_pressed(pin):\n    global mode, last_mode_press, pending_update\n    current_ms = ticks_ms()\n    if ticks_diff(current_ms, last_mode_press) &gt; DEBOUNCE_TIME_MS:\n        last_mode_press = current_ms\n\n        # Increment the mode first\n        mode = (mode + 1) % len(mode_names)\n\n        print(f\"Mode button pressed - New mode: {mode_names[mode]}\")\n</code></pre> <p>Warning</p> <p>There should be no calls to functions with I2C calls like <code>update_rtc()</code> which calls <code>rtc.datetime()</code> which is a I2C call.</p>"},{"location":"kits/oled-large/13-three-button-set/#flash-digits-being-set","title":"Flash Digits Being Set","text":"<p><code>flash_state</code> is a Boolean that tells us if the digit is flashing. During normal running <code>flash_state = False</code></p> <pre><code># in the update_screen function\n    # Draw digits with flashing based on mode\n    if mode != 1 or flash_state:\n        if hour_ten &gt; 0:  # Only show tens digit if non-zero\n            draw_digit(hour_ten, left_margin, y_offset, digit_width, digit_height, digit_thickness, 1)\n        draw_digit(hour_one, left_margin + digit_spacing - 2, y_offset, digit_width, digit_height, digit_thickness, 1)\n\n    if mode != 2 or flash_state:\n        draw_digit(minute_ten, left_margin + 2 * digit_spacing, y_offset, digit_width, digit_height, digit_thickness, 1)\n        draw_digit(minute_one, left_margin + 3 * digit_spacing, y_offset, digit_width, digit_height, digit_thickness, 1)\n\n    # Draw AM/PM indicator\n    if mode != 3 or flash_state:\n        oled.text(\"PM\" if is_pm(hour) else \"AM\", 112, 55, 1)\n</code></pre>"},{"location":"kits/oled-large/13-three-button-set/#full-listing","title":"Full Listing","text":"<pre><code>from machine import Pin, I2C, SPI\nfrom utime import sleep, ticks_ms, ticks_diff\nfrom ds3231 import DS3231\nimport ssd1306\nimport config\n\n# Display setup\nSCL = Pin(config.SPI_SCL_PIN)\nSDA = Pin(config.SPI_SDA_PIN)\nDC = Pin(config.SPI_DC_PIN)\nRES = Pin(config.SPI_RESET_PIN)\nCS = Pin(config.SPI_CS_PIN)\nspi = SPI(config.SPI_BUS, sck=SCL, mosi=SDA, baudrate=1000000)\noled = ssd1306.SSD1306_SPI(config.DISPLAY_WIDTH, config.DISPLAY_HEIGHT, spi, DC, RES, CS)\n\n# RTC setup\ni2c = I2C(config.I2C_BUS, sda=Pin(config.I2C_SDA_PIN), scl=Pin(config.I2C_SCL_PIN))\nrtc = DS3231(i2c)\n\n# Button setup\nmode_button = Pin(config.BUTTON_MODE_PIN, Pin.IN, Pin.PULL_UP)\nincrement_button = Pin(config.BUTTON_INCREMENT_PIN, Pin.IN, Pin.PULL_UP)\ndecrement_button = Pin(config.BUTTON_DECREMENT_PIN, Pin.IN, Pin.PULL_UP)\n\n# Global variables\nmode = 0  # 0=run, 1=set hour, 2=set minute, 3=set AM/PM\nlast_mode_press = 0\nlast_increment_press = 0\nlast_decrement_press = 0\nDEBOUNCE_TIME_MS = 200\nmode_names = ['run', 'set hour', 'set minute', 'set AM/PM']\nflash_state = False\nlast_flash_toggle = 0\nFLASH_INTERVAL_MS = 500\n\n# Current time state\ncurrent_time = list(rtc.datetime())\npending_update = False\n\n# Seven segment display configuration\nsegment_mapping = [\n    [1, 1, 1, 1, 1, 1, 0],  # 0\n    [0, 1, 1, 0, 0, 0, 0],  # 1\n    [1, 1, 0, 1, 1, 0, 1],  # 2\n    [1, 1, 1, 1, 0, 0, 1],  # 3\n    [0, 1, 1, 0, 0, 1, 1],  # 4\n    [1, 0, 1, 1, 0, 1, 1],  # 5\n    [1, 0, 1, 1, 1, 1, 1],  # 6\n    [1, 1, 1, 0, 0, 0, 0],  # 7\n    [1, 1, 1, 1, 1, 1, 1],  # 8\n    [1, 1, 1, 1, 0, 1, 1]   # 9\n]\n\ndef update_rtc():\n    \"\"\"Update RTC with current time state\"\"\"\n    global current_time, pending_update\n    if pending_update:\n        # Rearrange the tuple to match the expected format:\n        # From: (year, month, day, weekday, hour, minutes, seconds, subseconds)\n        # To:   (year, month, day, hour, minutes, seconds, weekday)\n        rtc_tuple = (\n            current_time[0],  # year\n            current_time[1],  # month\n            current_time[2],  # day\n            current_time[4],  # hour\n            current_time[5],  # minutes\n            current_time[6],  # seconds\n            current_time[3]   # weekday\n        )\n        rtc.datetime(rtc_tuple)\n        pending_update = False\n\ndef refresh_time():\n    \"\"\"Read current time from RTC\"\"\"\n    global current_time\n    current_time = list(rtc.datetime())\n\ndef convert_to_12h(hour):\n    \"\"\"Convert 24h hour to 12h hour\"\"\"\n    if hour == 0:\n        return 12  # Midnight is 12 AM\n    elif hour &gt; 12:\n        return hour - 12\n    return hour\n\ndef is_pm(hour):\n    \"\"\"Check if hour is PM in 24h format\"\"\"\n    return hour &gt;= 12\n\ndef toggle_am_pm(hour):\n    \"\"\"Toggle between AM and PM for a given hour\"\"\"\n    if hour &lt; 12:\n        return hour + 12\n    return hour - 12\n\ndef draw_digit(digit, x, y, width, height, thickness, color):\n    if digit &lt; 0:\n        return\n    segment_on = segment_mapping[digit]\n\n    # Horizontal segments\n    for i in [0, 3, 6]:\n        if segment_on[i]:\n            if i == 0:  # top\n                y_offset = 0\n            elif i == 3:  # bottom\n                y_offset = height - thickness\n            else:  # middle\n                y_offset = height // 2 - thickness // 2\n            oled.fill_rect(x, y + y_offset, width, thickness, color)\n\n    # Vertical segments\n    for i in [1, 2, 4, 5]:\n        if segment_on[i]:\n            if i == 1 or i == 5:  # upper\n                start_y = y\n                end_y = y + height // 2\n            else:  # lower\n                start_y = y + height // 2\n                end_y = y + height\n            x_offset = 0 if (i == 4 or i == 5) else width - thickness\n            oled.fill_rect(x + x_offset, start_y, thickness, end_y - start_y, color)\n\n\ndef update_screen():\n    global flash_state, current_time\n    oled.fill(0)\n\n    # Display settings\n    left_margin = -28\n    y_offset = 11\n    digit_width = 33\n    digit_height = 40\n    digit_spacing = 41\n    digit_thickness = 5\n\n    hour = current_time[4]\n    minute = current_time[5]\n    second = current_time[6]\n\n    # Convert to 12-hour format for display\n    display_hour = convert_to_12h(hour)\n\n    # Calculate digits for display\n    hour_ten = display_hour // 10 if display_hour &gt;= 10 else -1\n    hour_one = display_hour % 10\n    minute_ten = minute // 10\n    minute_one = minute % 10\n\n    print(f\"Debug display - Raw Hour:{hour} Display Hour:{display_hour} Min:{minute} \" + \n          f\"Digits: {hour_ten}|{hour_one} : {minute_ten}|{minute_one} {('AM', 'PM')[is_pm(hour)]}\")\n\n    # Draw digits with flashing based on mode\n    if mode != 1 or flash_state:\n        if hour_ten &gt; 0:  # Only show tens digit if non-zero\n            draw_digit(hour_ten, left_margin, y_offset, digit_width, digit_height, digit_thickness, 1)\n        draw_digit(hour_one, left_margin + digit_spacing - 2, y_offset, digit_width, digit_height, digit_thickness, 1)\n\n    if mode != 2 or flash_state:\n        draw_digit(minute_ten, left_margin + 2 * digit_spacing, y_offset, digit_width, digit_height, digit_thickness, 1)\n        draw_digit(minute_one, left_margin + 3 * digit_spacing, y_offset, digit_width, digit_height, digit_thickness, 1)\n\n    # Draw colon (flashing)\n    if second % 2:\n        oled.fill_rect(47, 20, 3, 3, 1)\n        oled.fill_rect(47, 20 + 14, 3, 3, 1)\n\n    # Draw AM/PM indicator\n    if mode != 3 or flash_state:\n        oled.text(\"PM\" if is_pm(hour) else \"AM\", 112, 55, 1)\n\n    # Draw seconds\n    oled.text(f\"{second:02d}\", 0, 54, 1)\n    oled.show()\n\ndef mode_button_pressed(pin):\n    global mode, last_mode_press, pending_update\n    current_ms = ticks_ms()\n    if ticks_diff(current_ms, last_mode_press) &gt; DEBOUNCE_TIME_MS:\n        last_mode_press = current_ms\n\n        # Increment the mode first\n        mode = (mode + 1) % len(mode_names)\n\n        print(f\"Mode button pressed - New mode: {mode_names[mode]}\")\n\ndef increment_button_pressed(pin):\n    global last_increment_press, current_time, pending_update\n    current_ms = ticks_ms()\n    if ticks_diff(current_ms, last_increment_press) &gt; DEBOUNCE_TIME_MS:\n        last_increment_press = current_ms\n        print(\"Increment button pressed\")\n\n        if mode == 1:  # Hour\n            hour = current_time[4]\n            new_hour = (hour + 1) if hour &lt; 23 else 0\n            current_time[4] = new_hour\n            pending_update = True\n            print(f\"Hour adjusted to: {new_hour}\")\n\n        elif mode == 2:  # Minute\n            minute = current_time[5]\n            new_minute = (minute + 1) if minute &lt; 59 else 0\n            current_time[5] = new_minute\n            current_time[6] = 0  # Reset seconds when setting minutes\n            pending_update = True\n            print(f\"Minute adjusted to: {new_minute}\")\n\n        elif mode == 3:  # AM/PM\n            hour = current_time[4]\n            new_hour = toggle_am_pm(hour)\n            current_time[4] = new_hour\n            pending_update = True\n            print(f\"Hour adjusted to: {new_hour} ({('AM', 'PM')[is_pm(new_hour)]})\")\n\ndef decrement_button_pressed(pin):\n    global last_decrement_press, current_time, pending_update\n    current_ms = ticks_ms()\n    if ticks_diff(current_ms, last_decrement_press) &gt; DEBOUNCE_TIME_MS:\n        last_decrement_press = current_ms\n        print(\"Decrement button pressed\")\n\n        if mode == 1:  # Hour\n            hour = current_time[4]\n            new_hour = (hour - 1) if hour &gt; 0 else 23\n            current_time[4] = new_hour\n            pending_update = True\n            print(f\"Hour adjusted to: {new_hour}\")\n\n        elif mode == 2:  # Minute\n            minute = current_time[5]\n            new_minute = (minute - 1) if minute &gt; 0 else 59\n            current_time[5] = new_minute\n            current_time[6] = 0  # Reset seconds when setting minutes\n            pending_update = True\n            print(f\"Minute adjusted to: {new_minute}\")\n\n        elif mode == 3:  # AM/PM\n            hour = current_time[4]\n            new_hour = toggle_am_pm(hour)\n            current_time[4] = new_hour\n            pending_update = True\n            print(f\"Hour adjusted to: {new_hour} ({('AM', 'PM')[is_pm(new_hour)]})\")\n\n# Setup button interrupts\nmode_button.irq(trigger=Pin.IRQ_FALLING, handler=mode_button_pressed)\nincrement_button.irq(trigger=Pin.IRQ_FALLING, handler=increment_button_pressed)\ndecrement_button.irq(trigger=Pin.IRQ_FALLING, handler=decrement_button_pressed)\n\nprint(\"Clock started in mode: run\")\n\n# Initialize time state\nrefresh_time()\n\n# Main loop\n# Main loop\nwhile True:\n    current_ms = ticks_ms()\n\n    # Update flash state every FLASH_INTERVAL_MS\n    if ticks_diff(current_ms, last_flash_toggle) &gt;= FLASH_INTERVAL_MS:\n        flash_state = not flash_state\n        last_flash_toggle = current_ms\n\n    # If we're in run mode and there's a pending update, update the RTC\n    if mode == 0 and pending_update:\n        update_rtc()  # This will update the RTC and clear the flag\n\n    # In run mode, use RTC for timekeeping only\n    if mode == 0 and not pending_update:\n        current_time = list(rtc.datetime())\n\n    # Update display\n    update_screen()\n    sleep(0.5)\n</code></pre>"},{"location":"kits/oled-large/15-digital-clock/","title":"OLED Digital Clock Display","text":"<p>In this section we will do a full walk through of a program that uses the real-time clock to get the time and displays the time using the four-digit drawing function we created.</p> <p>Note that if you don't have your real-time clock connected or working you can still use this program to display the time using the <code>localtime()</code> function.</p> <p>Change the following line:</p> <p>From: ```python now = rtc.</p>"},{"location":"kits/oled-large/16-adding-temperature/","title":"Adding Ambient Room Temperature","text":"<p>The DS3231 RTC has one nice feature in that it can also display the ambient temperature of the area it is in.</p> <p>To do this we need to access the registers that hold the temperature information through the I2C bus.  Note that the DS3231 driver that we are using does not support getting access to the temperature.</p>"},{"location":"kits/oled-large/16-adding-temperature/#sample-code","title":"Sample Code","text":"<pre><code>def read_temperature():\n    \"\"\"Read temperature from DS3231 RTC with 0.25\u00b0C resolution.\"\"\"\n    try:\n        # Read temperature registers\n        temp_msb = i2c.readfrom_mem(DS3231_ADDR, 0x11, 1)[0]\n        temp_lsb = i2c.readfrom_mem(DS3231_ADDR, 0x12, 1)[0]\n\n        # Handle signed temperature value (2's complement)\n        temp_c = temp_msb\n        if temp_msb &amp; 0x80:  # Negative value\n            temp_c = -((~temp_msb + 1) &amp; 0xFF)\n\n        # Add fractional part (0.25\u00b0C resolution)\n        temp_c += ((temp_lsb &gt;&gt; 6) * 0.25)\n\n        # Convert to Fahrenheit\n        temp_f = (temp_c * 9/5) + 32\n        print(f\"Raw temp data - MSB: 0x{temp_msb:02X}, LSB: 0x{temp_lsb:02X}\")\n        print(f\"Temperature: {temp_c:.2f}\u00b0C, {temp_f:.2f}\u00b0F\")\n        return temp_f\n\n    except Exception as e:\n        print(\"Error reading temperature:\", e)\n        return None\n</code></pre> <p>This function will read directly from the DS3231 I2C memory <code>readfrom_mem</code>.</p> <p>Let's go through it step by step:</p>"},{"location":"kits/oled-large/16-adding-temperature/#function-definition","title":"Function Definition","text":"<p>First, we have a function called <code>read_temperature()</code> that's designed to read the temperature with pretty good accuracy (up to 0.25\u00b0C).  It returns the temperature in degrees Fahrenheit.</p>"},{"location":"kits/oled-large/16-adding-temperature/#reading-memory-via-the-i2c-functions","title":"Reading Memory Via the I2C Functions","text":"<p>Inside the function, it first tries to read two pieces of data:</p> <pre><code>temp_msb = i2c.readfrom_mem(DS3231_ADDR, 0x11, 1)[0]\ntemp_lsb = i2c.readfrom_mem(DS3231_ADDR, 0x12, 1)[0]\n</code></pre> <ul> <li>This is reading two adjacent memory locations from the DS3231 chip using the I2C protocol:</li> <li>The first address (0x11) contains the main temperature number</li> <li>The second box (0x12) contains extra detail for more accurate readings</li> </ul>"},{"location":"kits/oled-large/16-adding-temperature/#converting-formats","title":"Converting Formats","text":"<p>Then it handles something called \"2's complement\" which is just a fancy way of dealing with negative temperatures:</p> <pre><code>temp_c = temp_msb\nif temp_msb &amp; 0x80:  # Negative value\n    temp_c = -((~temp_msb + 1) &amp; 0xFF)\n</code></pre> <p>If the number shows it's negative (like when it's below freezing), this code converts it properly</p>"},{"location":"kits/oled-large/16-adding-temperature/#getting-the-fraction","title":"Getting The Fraction","text":"<p>Next, it adds the fractional part to get more precise readings:</p> <pre><code>temp_c += ((temp_lsb &gt;&gt; 6) * 0.25)\n</code></pre> <p>This gives us those in-between temperatures, like 20.25\u00b0C or 20.75\u00b0C</p>"},{"location":"kits/oled-large/16-adding-temperature/#converting-celsius-to-fahrenheit","title":"Converting Celsius to Fahrenheit","text":"<p>Then it converts the temperature from Celsius to Fahrenheit:</p> <p><pre><code>temp_f = (temp_c * 9/5) + 32\n</code></pre> This is the same formula you might use in math class: \u00b0F = (\u00b0C \u00d7 9/5) + 32</p>"},{"location":"kits/oled-large/16-adding-temperature/#printing-and-returning","title":"Printing and Returning","text":"<p>Finally, it prints out both the raw data and the converted temperatures:</p> <p><pre><code>print(f\"Raw temp data - MSB: 0x{temp_msb:02X}, LSB: 0x{temp_lsb:02X}\")\nprint(f\"Temperature: {temp_c:.2f}\u00b0C, {temp_f:.2f}\u00b0F\")\n</code></pre> - It shows both Celsius and Fahrenheit with two decimal places - The raw data is shown in hexadecimal (that's what the '0x' means)</p> <p>If anything goes wrong while reading the temperature, it will run the following:</p> <p><pre><code>except Exception as e:\n    print(\"Error reading temperature:\", e)\n    return None\n</code></pre> - Print out what went wrong - Return <code>None</code> to indicate there was an error</p> <p>Think of this like a digital thermometer that can read temperatures very precisely and give you the reading in both Celsius and Fahrenheit. The code is just the instructions for how to get that reading from the chip.</p>"},{"location":"kits/oled-wireless/","title":"OLED Wireless Weather Kit","text":""},{"location":"kits/sh1106/","title":"SH1108 OLED Driver Kit","text":""},{"location":"kits/sh1106/#testing-the-oled-connections","title":"Testing the OLED Connections","text":"<pre><code>from machine import Pin, I2C\nfrom sh1106 import SH1106_I2C\n\n# OLED DATA Pin on GPIO 0\nOLED_SH11306_SDA_PIN = 0\n# OLED Clock Pin on GPIO 1\nOLED_SH11306_SCL_PIN = 1\n\nsda=Pin(OLED_SH11306_SDA_PIN, Pin.OUT)\nscl=Pin(OLED_SH11306_SCL_PIN, Pin.OUT)\n\n# freq=198000 to 3600000 seem to work.  Use 3000000 as a safe option.\ni2c = I2C(0, scl=scl, sda=sda, freq=100000)\n\n# Initialize display (128x64 pixels)\noled = SH1106_I2C(128, 64, i2c)\noled.rotate(180)\n\n# Clear display\noled.fill(0)\n\n# Write text\noled.text(\"MicroPython\", 0, 0)\noled.text(\"Rocks!\", 20, 20)\n\n# Show the display\noled.show()\n</code></pre>"},{"location":"kits/sh1106/#displaying-clock-digits","title":"Displaying Clock Digits","text":"<p>Note that the pins are on the bottom, so for our example we had to do a <code>oled.rotate(180)</code></p> <pre><code>from machine import Pin, I2C\nfrom sh1106 import SH1106_I2C\nfrom utime import sleep, localtime\n\n# OLED DATA Pin on GPIO 0\nOLED_SH11306_SDA_PIN = 0\n# OLED Clock Pin on GPIO 1\nOLED_SH11306_SCL_PIN = 1\n\nsda=Pin(OLED_SH11306_SDA_PIN, Pin.OUT)\nscl=Pin(OLED_SH11306_SCL_PIN, Pin.OUT)\n\n# freq=30000 (30K) to 4000000 (4M) seem to work.  Use 3000000 (3M) as a safe option.\ni2c = I2C(0, scl=scl, sda=sda, freq=3000000)\n\n# Initialize display (128x64 pixels)\noled = SH1106_I2C(128, 64, i2c)\noled.rotate(180)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n\n\n# x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thinkness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thinkness, color):\n  if digit &lt; 0:\n      return\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottem, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thinkness # bottem element\n      if (i==6):\n          yOffset = height // 2 - thinkness // 2# bottum\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thinkness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + height // 2\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thinkness\n\n      oled.fill_rect(x+xOffset, startY, thinkness, endY-startY, color)\n\ndef update_screen(year, month, day, hour, minute, am_pm, colon_on):   \n\n    ## Adjust these to fit the display\n    left_margin = -28\n    y_offset = 11\n    digit_width = 33\n    digit_height = 40\n    digit_spacing = 41\n    digit_thickness = 5\n    oled.fill(0)\n    date_str = f\"{month}/{day}/{year}\"\n    oled.text(date_str, 0, 0, 1)\n    if hour &gt; 12:\n        hour = hour - 12\n    if hour &gt; 10:\n        hour_ten = 1\n    else:\n        hour_ten = -1\n    hour_right = hour % 10\n\n    minute_ten = minute // 10\n    minute_right = minute % 10\n\n    # left digit will be 1 or blank\n    drawDigit(hour_ten, left_margin,  y_offset, digit_width, digit_height, digit_thickness, 1)\n    drawDigit(hour_right, left_margin + 1*digit_spacing-2,  y_offset, digit_width, digit_height, digit_thickness, 1)\n    drawDigit(minute_ten, left_margin + 2*digit_spacing,  y_offset, digit_width, digit_height, digit_thickness, 1)\n    drawDigit(minute_right, left_margin + 3*digit_spacing, y_offset, digit_width, digit_height, digit_thickness, 1)\n\n    if colon_on:\n        draw_colon(47,20)\n\n    pm_xoffset = 106\n    pm_yoffset = 55\n\n    oled.text(am_pm, pm_xoffset, pm_yoffset, 1)\n\n    oled.show()\n\ndef draw_colon(x,y):\n    oled.fill_rect(x, y,    3, 3, 1)\n    oled.fill_rect(x, y+14, 3, 3, 1)\n\ncounter = 0\nwhile True:\n    now = localtime()\n    year = now[0]\n    month = now[1]\n    day = now[2]\n    hour = now[3]\n    if hour &gt; 12:\n        am_pm = \"PM\"\n    else:\n        am_pm = \"AM\"\n    minute = now[4]\n\n    update_screen(year, month, day, hour, minute, am_pm, True)\n    sleep(1)\n    update_screen(year, month, day, hour, minute, am_pm, False)\n    sleep(1)\n    counter += 1\n    if counter &gt; 9:\n        counter = 0\n</code></pre>"},{"location":"kits/shift-register-clock/","title":"74HC595 Shift Register Clock","text":"<p>The display has five wires.  In addition to power and ground we have:</p> <pre><code>ser_pin=2,    # DIO\nsrclk_pin=1,  # SCLK\nrclk_pin=0    # RCLK\n</code></pre> <p>The shift register takes in a set of 16 bit commands. The first byte is the segment information with one bit for each of the 7 segments and one bit for the colon. The second bit indicates what digit should be turned on.</p> <p>Note that for a segment to be on, the bit must be \"0\".</p> <p>Here are the letters associated with each of the 7 segments:</p> <pre><code> aaaa\nf    b\nf    b\n gggg\ne    c\ne    c\n dddd\n</code></pre> <pre><code># bit 0 is the right-most significant bit and is used to turn on the colon.\nself.SEGMENTS = {\n    'a': 4,  # bit 4\n    'b': 3,  # bit 3\n    'c': 2,  # bit 2\n    'd': 7,  # bit 7\n    'e': 6,  # bit 6\n    'f': 5,  # bit 5\n    'g': 1   # bit 1\n}\n</code></pre> <p>\"d\" First byte:  00110000 Second byte: 00010000</p> <p>This is where \"a\" is missing.  a is the fourth bit. First byte:  00010000</p> <p>This is where all the segments are on except f.  \"f\" is the 3rd bit First byte:  00100000 \"A\" is First byte:  10000000</p>"},{"location":"kits/shift-register-clock/#sample-test","title":"Sample Test","text":"<p>The following program will cycle through the digits 0 to 9 on the right most digit to the left most digit.</p> <pre><code>from machine import Pin\nfrom sr74hc595 import SR74HC595_BITBANG\nfrom utime import sleep, localtime\n\nclass FourDigitClock:\n    # Class constants\n    ALL_OFF = 0xFF            # All segments off (inverted logic)\n    SECOND_BYTE = 0b00010000  # Keep bit 4 set in second byte\n\n    def __init__(self, ser_pin, srclk_pin, rclk_pin):\n        # Initialize pins\n        self.ser = Pin(ser_pin, Pin.OUT)      # Serial data\n        self.srclk = Pin(srclk_pin, Pin.OUT)  # Shift register clock\n        self.rclk = Pin(rclk_pin, Pin.OUT)    # Storage register clock\n\n        self.sr = SR74HC595_BITBANG(self.ser, self.srclk, self.rclk)\n\n        # Segment bit positions (0 turns segment on)\n        # a is the top, b in the upper right, c is the lower right\n        # d is the bottom, e is the lower left, f is the upper right\n        # g is the middle segment\n        self.SEGMENTS = {\n            'a': 4,  # bit 4\n            'b': 3,  # bit 3\n            'c': 2,  # bit 2\n            'd': 7,  # bit 7\n            'e': 6,  # bit 6\n            'f': 5,  # bit 5\n            'g': 1   # bit 1\n        }\n\n        # Define segments needed for each digit\n        self.DIGIT_SEGMENTS = {\n            0: 'abcdef',   # 0 needs all but g\n            1: 'bc',       # 1 needs just b and c\n            2: 'abged',    # 2 needs all but c and f\n            3: 'abgcd',    # 3 needs all but e and f\n            4: 'fbcg',     # 4 needs these four\n            5: 'afgcd',    # 5 needs all but e and b\n            6: 'afedcg',   # 6 needs all but b\n            7: 'abc',      # 7 needs just these three\n            8: 'abcdefg',  # 8 needs all segments\n            9: 'abfgcd'    # 9 needs all but e\n        }\n\n        # Pre-calculate patterns for all digits\n        self.DIGIT_PATTERNS = {\n            digit: self.create_pattern(segments) \n            for digit, segments in self.DIGIT_SEGMENTS.items()\n        }\n\n    def create_pattern(self, segments):\n        \"\"\"Create bit pattern from segment letters with inverted logic\"\"\"\n        pattern = self.ALL_OFF\n        for segment in segments:\n            if segment in self.SEGMENTS:\n                pattern &amp;= ~(1 &lt;&lt; self.SEGMENTS[segment])\n        return pattern\n\n    def display_pattern(self, first_byte, digit_select_byte):\n        \"\"\"Display a pattern with specified digit selection\"\"\"\n        self.sr.bits(first_byte, 8)\n        self.sr.bits(digit_select_byte, 8)\n        self.sr.latch()\n\n    def test_all_positions(self):\n        \"\"\"Test counting 0-9 on all digit positions\"\"\"\n        print(\"Testing all digit positions...\")\n\n        # Digit selection patterns to try\n        digit_patterns = [\n            (0, 0b00010000, \"Rightmost digit\"),\n            (1, 0b00100000, \"Second digit\"),\n            (2, 0b01000000, \"Third digit\"),\n            (3, 0b10000000, \"Leftmost digit\")\n        ]\n\n        # Test each digit position\n        for position, digit_select, position_name in digit_patterns:\n            print(f\"\\nTesting {position_name}\")\n\n            # Count 0-9 on this position\n            for number in range(10):\n                print(f\"Displaying {number} on {position_name}\")\n\n                # Display the number\n                self.display_pattern(self.DIGIT_PATTERNS[number], digit_select)\n                sleep(.25)\n\n                # Clear display between numbers\n                self.display_pattern(self.ALL_OFF, self.ALL_OFF)\n                sleep(0.05)\n\n            # Wait for user input before moving to next position\n            #input(f\"Press Enter to test next position...\")\n\ndef run_position_test():\n    \"\"\"Run position testing\"\"\"\n    clock = FourDigitClock(\n        ser_pin=2,    # DIO\n        srclk_pin=1,  # SCLK\n        rclk_pin=0    # RCLK\n    )\n\n    print(\"Starting position tests...\")\n    clock.test_all_positions()\n\n# Run the position test\nif __name__ == '__main__':\n    run_position_test()\n</code></pre>"},{"location":"kits/shift-register-clock/#references","title":"References","text":"<p>74HC595 Shift Register</p> <ul> <li>Kevin McAleer: Raspberry Pi Pico, 7 Segment Displays and 74hc595 shift registers YouTube Video</li> </ul>"},{"location":"kits/shift-register-clock/clock-main/","title":"Clock Main","text":""},{"location":"kits/shift-register-clock/clock-main/#details","title":"Details","text":"<p>This program use 12 hour time and also flashes the colon ever 1/2 second. It also is designed to work with a real-time clock that might take a bit of time to startup with the Pico first powers up.</p> <pre><code>from machine import Pin, RTC \nfrom sr74hc595 import SR74HC595_BITBANG\nfrom utime import sleep, localtime, ticks_ms\n\ndef wait_for_rtc():\n    print(\"Waiting for RTC to be ready...\")\n    rtc = RTC()\n    while True:\n        current_time = rtc.datetime()\n        # On Pico, default RTC starts at (2021, 1, 1, 0, 0, 0, 0, 0)\n        # So we check if it's been set to something else\n        if current_time[0] != 2021 or current_time[1] != 1 or current_time[2] != 1:\n            print(\"RTC is ready!\")\n            return\n        print(\"RTC not ready yet...\")\n        sleep(1)  # Check every second\n\nclass FourDigitClock:\n    ALL_OFF = 0xFF  # All segments off (inverted logic)\n\n    def __init__(self, ser_pin, srclk_pin, rclk_pin):\n        self.ser = Pin(ser_pin, Pin.OUT)\n        self.srclk = Pin(srclk_pin, Pin.OUT) \n        self.rclk = Pin(rclk_pin, Pin.OUT)\n        self.sr = SR74HC595_BITBANG(self.ser, self.srclk, self.rclk)\n\n        self.SEGMENTS = {\n            'a': 4, 'b': 3, 'c': 2, \n            'd': 7, 'e': 6, 'f': 5, 'g': 1\n        }\n        self.DIGIT_SEGMENTS = {\n            0: 'abcdef', 1: 'bc', 2: 'abged', 3: 'abgcd',\n            4: 'fbcg', 5: 'afgcd', 6: 'afedcg', \n            7: 'abc', 8: 'abcdefg', 9: 'abfgcd'\n        }\n        self.DIGIT_PATTERNS = {\n            digit: self.create_pattern(segments)\n            for digit, segments in self.DIGIT_SEGMENTS.items()\n        }\n        self.DIGIT_SELECT = [\n            0b00010000,  # Rightmost digit\n            0b00100000,  # Second digit \n            0b01000000,  # Third digit\n            0b10000000   # Leftmost digit  \n        ]\n\n    def create_pattern(self, segments):\n        pattern = self.ALL_OFF\n        for segment in segments:\n            if segment in self.SEGMENTS:\n                pattern &amp;= ~(1 &lt;&lt; self.SEGMENTS[segment]) \n        return pattern\n\n    def display_digit(self, digit, position, dp=False):\n        pattern = self.DIGIT_PATTERNS[digit]\n        if dp:\n            pattern &amp;= ~(1 &lt;&lt; 0)  # Turn on decimal point\n        self.sr.bits(pattern, 8)\n        self.sr.bits(self.DIGIT_SELECT[position], 8)\n        self.sr.latch()\n\n    def display_time(self, hour, minute, colon_state):\n        # Convert to 12-hour format\n        if hour &gt; 12:\n            hour -= 12\n        elif hour == 0:  \n            hour = 12\n\n        digits = [hour // 10, hour % 10, minute // 10, minute % 10]\n\n        for position, digit in enumerate(reversed(digits)):\n            self.display_digit(digit, position, dp=(position == 1 and colon_state))\n            sleep(0.002)  # Reduced persistence timing\n\n\ndef run_clock():\n    # wait for a good time to come from localtime()\n    wait_for_rtc()\n\n    clock = FourDigitClock(ser_pin=2, srclk_pin=1, rclk_pin=0)\n    print(\"Starting clock...\")\n\n    last_second = -1\n    colon_state = True\n    last_toggle = ticks_ms()\n\n    while True:\n        current_time = localtime()\n        hour = current_time[3]\n        minute = current_time[4]\n        current_second = current_time[5]\n\n        if ticks_ms() - last_toggle &gt;= 500:\n            colon_state = not colon_state\n            last_toggle = ticks_ms()\n\n        clock.display_time(hour, minute, colon_state)\n\n\nif __name__ == '__main__':\n    run_clock()\n</code></pre>"},{"location":"kits/shift-register-clock/sample-prompt/","title":"Sample ChatGPT Prompt","text":"<p>Prompt</p> <p>Please help me write a micropython program for a 4-digit clock.  I have a digital clock display with 4 digits I purchased on eBay.  Each of the 4 digits has 7 segments and there is also a colon between the 2nd and 3rd digits.  The part says they use 74hc595 shift registers.  The names of the connectors are:</p> <ol> <li>GND</li> <li>VCC</li> <li>RCLK</li> <li>SCLK</li> <li>DIO</li> </ol> <p>I found a micropython driver called: sr74hc595.  When I run a test program the various segments do light up, but I don't see a pattern.  Can you give me some suggestions on how to write a driver that writes the correct time like 12:34?</p> <p>Here is the code that is working:</p> <pre><code># SPDX-FileCopyrightText: 2021 Mike Causer &lt;https://github.com/mcauser&gt;\n# SPDX-License-Identifier: MIT\n\n\"\"\"\nMicroPython 74HC595 8-Bit Shift Register\nhttps://github.com/mcauser/micropython-74hc595\n\"\"\"\n\nfrom machine import Pin\n# from sr74hc595 import SR74HC595_BITBANG\nfrom sr74hc595 import SR74HC595_BITBANG\nfrom utime import sleep\n\nser = Pin(2, Pin.OUT)\nrclk = Pin(0, Pin.OUT)\nsrclk = Pin(1, Pin.OUT)\n\n# construct without optional pins\nsr = SR74HC595_BITBANG(ser, srclk, rclk)\n\n#sr.clear()  # raises RuntimeError because you haven't provide srclr pin\n#sr.enable()  # raises RuntimeError because you haven't provide oe pin\n\n# reconstruct with all pins\noe = Pin(3, Pin.OUT, value=0)  # low enables output\nsrclr = Pin(3, Pin.OUT, value=1)  # pulsing low clears data\n\nsr = SR74HC595_BITBANG(ser, srclk, rclk, srclr, oe)\n\nwhile True:\n\n    sr.bit(1)  # send high bit, do not latch yet\n    sr.bit(0)  # send low bit, do not latch yet\n    sr.latch()  # latch outputs, outputs=0000_0010\n\n    sr.bit(1, 1)  # send high bit and latch, outputs=0000_0101\n    sr.bit(0, 1)  # send low bit and latch, outputs=0000_1010\n\n    sr.bits(0xFF, 4)  # send 4 lowest bits of 0xff (sends 0x0f), outputs=1010_1111\n    sr.clear(0)  # clear the memory but don't latch yet\n    sr.latch()  # next latch shows the outputs have been reset\n    sr.bits(0b1010_1010, 8)  # write some bits\n    sr.clear()  # clear the memory and latch, outputs have been reset\n\n    sr.enable()  # outputs enabled\n    sr.enable(0)  # outputs disabled\n\n    sleep(1)\n\n    sr.bits(0b1111_1111, 8)  # write some bits\n    sr.clear()  # clear the memory and latch, outputs have been reset\n\n    sr.enable()  # outputs enabled\n    sr.enable(0)  # outputs disabled\n\n    sleep(1)\n\n    sr.bits(0b0000_0011, 8)  # write some bits\n    sr.clear()  # clear the memory and latch, outputs have been reset\n\n    sr.enable()  # outputs enabled\n    sr.enable(0)  # outputs disabled\n    sleep(1)\n</code></pre>"},{"location":"kits/ssd1306-i2c/","title":"A Tiny SSD1306 OLED Clock on an I2C Interface","text":"<p>This clock is an ideal starter clock since you can get the displays for just $3-4 for the small 1\" displays. Because they have a simple four-wire I2C connection they are also easy to wire up.</p> <p>Note that the I2C bus can be slower than the faster SPI bus. However, for a clock that only updates once per second, this is not usually an issue since we don't need the 20 frames per second updates for real-time animation.</p>"},{"location":"kits/ssd1306-i2c/#testing-the-i2c-bus","title":"Testing the I2C Bus","text":"<p>We start by putting SDA on pin 0 and clock on pin 1. We can leave the freq parameter out or we can set the clock to a frequency of 3M or 3000000. I have found values from freq=198000 to 3600000 seem to work. Use 3000000 as a safe option.</p> <pre><code>from machine import I2C, Pin\n\n# OLED DATA Pin\nOLED_SSD1306_SDA_PIN = 0\n# OLED Clock Pin\nOLED_SSD1306_SCL_PIN = 1\n\nsda=Pin(OLED_SSD1306_SDA_PIN, Pin.OUT)\nscl=Pin(OLED_SSD1306_SCL_PIN, Pin.OUT)\n\ni2c = I2C(0, scl=scl, sda=sda, freq=3000000)\nfirst_device = i2c.scan()[0]\n# print(\"dec:\", first_device, \"hex:\", hex(first_device))\n\nif first_device == 60:\n    print(\"PASS: OLED Found on dec: 60 hex: 0x3c\")\nelse:\n    print(\"FAIL: OLED not found on expected address dec: 60 hex: 0x3c\")\n</code></pre>"},{"location":"kits/ssd1306-i2c/#testing-the-oled-driver-and-connections","title":"Testing the OLED Driver and Connections","text":"<pre><code>from machine import Pin, I2C\nfrom ssd1306 import SSD1306_I2C\n\n# OLED DATA Pin on GPIO 0\nOLED_SSD1306_SDA_PIN = 0\n# OLED Clock Pin on GPIO 1\nOLED_SSD1306_SCL_PIN = 1\n\nsda=Pin(OLED_SSD1306_SDA_PIN, Pin.OUT)\nscl=Pin(OLED_SSD1306_SCL_PIN, Pin.OUT)\n\n# freq=198000 to 3600000 seem to work.  Use 3000000 as a safe option.\ni2c = I2C(0, scl=scl, sda=sda, freq=3000000)\n\n# Initialize display (128x64 pixels)\noled = SSD1306_I2C(128, 64, i2c)\n\n# Clear display\noled.fill(0)\n\n# Write text\noled.text(\"MicroPython\", 0, 0)\noled.text(\"Rocks!\", 20, 20)\n\n# Show the display\noled.show()\n</code></pre>"},{"location":"kits/ssd1306-i2c/#display-the-localtime","title":"Display the Localtime","text":"<pre><code>from machine import Pin, I2C\nfrom ssd1306 import SSD1306_I2C\nfrom utime import localtime\n\n# OLED DATA Pin on GPIO 0\nOLED_SSD1306_SDA_PIN = 0\n# OLED Clock Pin on GPIO 1\nOLED_SSD1306_SCL_PIN = 1\n\nsda=Pin(OLED_SSD1306_SDA_PIN, Pin.OUT)\nscl=Pin(OLED_SSD1306_SCL_PIN, Pin.OUT)\n\n# freq=198000 to 3600000 seem to work.  Use 3000000 as a safe option.\ni2c = I2C(0, scl=scl, sda=sda, freq=3000000)\n\n# Initialize display (128x64 pixels)\noled = SSD1306_I2C(128, 64, i2c)\n\n# Clear display\noled.fill(0)\n\nyear = localtime()[0]\nmonth = localtime()[1]\nday = localtime()[2]\nhour = localtime()[3]\nminute = localtime()[4]\n\n# display the time in hour and minute on the first line\noled.text(str(hour) + \":\" + str(minute), 0, 0, 1)\n\n# display the date on the second line\noled.text(str(month) + \"/\" + str(day) + \"/\" + str(year), 20, 20, 1)\noled.show()\n</code></pre>"},{"location":"kits/ssd1306-i2c/adjusting-digit-display/","title":"Adjusting the Clock Digit Layout","text":"<p>You have the ability to adjust the clock digit layouts by changing the following parameters:</p> <ol> <li>left_margin - were the left-most digit drawing starts</li> <li>y_offset - how far down the screen to begin to draw the top line of the digits</li> <li>digit_width - how wide each digit is</li> <li>digit_height - how high each digit is</li> <li>digit_spacing - the spacing between the left edges of each digit - not the space between the digits</li> <li>digit_thickness - how wide each bar of each segment is</li> </ol> <p>In addition you can change the placement of the colon and the AM/PM indicator.</p> <pre><code>from machine import Pin, I2C\nfrom ssd1306 import SSD1306_I2C\nfrom utime import localtime, sleep\n\n# OLED DATA Pin on GPIO 0\nOLED_SSD1306_SDA_PIN = 0\n# OLED Clock Pin on GPIO 1\nOLED_SSD1306_SCL_PIN = 1\n\nsda=Pin(OLED_SSD1306_SDA_PIN, Pin.OUT)\nscl=Pin(OLED_SSD1306_SCL_PIN, Pin.OUT)\n\n# freq=198000 to 3600000 seem to work.  Use 3000000 as a safe option.\ni2c = I2C(0, scl=scl, sda=sda, freq=3000000)\n\n# Initialize display (128x64 pixels)\noled = SSD1306_I2C(128, 64, i2c)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n\n\n# x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thinkness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thinkness, color):\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottem, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thinkness # bottem element\n      if (i==6):\n          yOffset = height // 2 - thinkness // 2# bottum\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thinkness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + height // 2\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thinkness\n\n      oled.fill_rect(x+xOffset, startY, thinkness, endY-startY, color)\n\ndef update_screen(digit_val):\n    global counter\n\n    ## Adjust these to fit the display\n    left_margin = -15\n    y_offset = 16\n    digit_width = 30\n    digit_height = 37\n    digit_spacing = 36\n    digit_thickness = 6\n    oled.fill(0)\n    oled.text('Clock Digits Lab', 0, 0, 1)\n\n    # left digit will be 1 or blank\n    drawDigit(1, left_margin,  y_offset, digit_width, digit_height, digit_thinkness, 1)\n    drawDigit(digit_val, left_margin + 1*digit_spacing,  y_offset, digit_width, digit_height, digit_thickness, 1)\n    drawDigit(digit_val, left_margin + 2*digit_spacing,  y_offset, digit_width, digit_height, digit_thickness, 1)\n    drawDigit(digit_val, left_margin + 3*digit_spacing, y_offset, digit_width, digit_height, digit_thickness, 1)\n\n    draw_colon(53,26)\n\n    pm_xoffset = 103\n    pm_yoffset = 55\n    if (counter % 2):\n        # 112 is the max right for the am/pm text\n        oled.text(\"am\", pm_xoffset, pm_yoffset, 1)\n\n    else:\n        oled.text(\"pm\", pm_xoffset, pm_yoffset, 1)\n    oled.text(str(digit_val), 0, 54, 1)\n\n    oled.show()\n\ndef draw_colon(x,y):\n    oled.fill_rect(x, y, 2, 2,1)\n    oled.fill_rect(x, y+8, 2, 2,1)\n\ncounter = 0\nwhile True:\n    update_screen(counter)\n    sleep(1)\n    counter += 1\n    if counter &gt; 9:\n        counter = 0\n</code></pre>"},{"location":"kits/ssd1306-i2c/integrating-localtime/","title":"Integrating the Local Time","text":"<pre><code>from machine import Pin, I2C\nfrom ssd1306 import SSD1306_I2C\nfrom utime import localtime, sleep\n\n# OLED DATA Pin on GPIO 0\nOLED_SSD1306_SDA_PIN = 0\n# OLED Clock Pin on GPIO 1\nOLED_SSD1306_SCL_PIN = 1\n\nsda=Pin(OLED_SSD1306_SDA_PIN, Pin.OUT)\nscl=Pin(OLED_SSD1306_SCL_PIN, Pin.OUT)\n\n# freq=198000 to 3600000 seem to work.  Use 3000000 as a safe option.\ni2c = I2C(0, scl=scl, sda=sda, freq=3000000)\n\n# Initialize display (128x64 pixels)\noled = SSD1306_I2C(128, 64, i2c)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n\n\n# x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thinkness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thinkness, color):\n  if digit &lt; 0:\n      return\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottem, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thinkness # bottem element\n      if (i==6):\n          yOffset = height // 2 - thinkness // 2# bottum\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thinkness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + height // 2\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thinkness\n\n      oled.fill_rect(x+xOffset, startY, thinkness, endY-startY, color)\n\ndef update_screen(year, month, day, hour, minute, am_pm, colon_on):   \n\n    ## Adjust these to fit the display\n    left_margin = -15\n    y_offset = 16\n    digit_width = 30\n    digit_height = 37\n    digit_spacing = 36\n    digit_thickness = 5\n    oled.fill(0)\n    date_str = f\"{month}/{day}/{year}\"\n    oled.text(date_str, 0, 0, 1)\n    if hour &gt; 12:\n        hour = hour - 12\n    if hour &gt; 10:\n        hour_ten = 1\n    else:\n        hour_ten = -1\n    hour_right = hour % 10\n\n    minute_ten = minute // 10\n    minute_right = minute % 10\n\n    # left digit will be 1 or blank\n    drawDigit(hour_ten, left_margin,  y_offset, digit_width, digit_height, digit_thickness, 1)\n    drawDigit(hour_right, left_margin + 1*digit_spacing,  y_offset, digit_width, digit_height, digit_thickness, 1)\n    drawDigit(minute_ten, left_margin + 2*digit_spacing,  y_offset, digit_width, digit_height, digit_thickness, 1)\n    drawDigit(minute_right, left_margin + 3*digit_spacing, y_offset, digit_width, digit_height, digit_thickness, 1)\n\n    if colon_on:\n        draw_colon(53,26)\n\n    pm_xoffset = 106\n    pm_yoffset = 55\n\n    oled.text(am_pm, pm_xoffset, pm_yoffset, 1)\n\n    oled.show()\n\ndef draw_colon(x,y):\n    oled.fill_rect(x, y, 2, 2,1)\n    oled.fill_rect(x, y+8, 2, 2,1)\n\ncounter = 0\nwhile True:\n    now = localtime()\n    year = now[0]\n    month = now[1]\n    day = now[2]\n    hour = now[3]\n    if hour &gt; 12:\n        am_pm = \"PM\"\n    else:\n        am_pm = \"AM\"\n    minute = now[4]\n\n    update_screen(year, month, day, hour, minute, am_pm, True)\n    sleep(1)\n    update_screen(year, month, day, hour, minute, am_pm, False)\n    sleep(1)\n    counter += 1\n    if counter &gt; 9:\n        counter = 0\n</code></pre>"},{"location":"kits/ssd1306-i2c/prompt/","title":"Prompt for the SSD1306 I2C Clock","text":""},{"location":"kits/ssd1306-i2c/setting-time/","title":"Manually Setting Time on Power Up","text":"<p>This clock has two buttons on a breadboard for setting the time. When the clock is powered up or reset, the clock goes into a \"Power-Up\" mode where all the digits are flashing.</p> <p>Here are the modes we will need:</p> <ol> <li>Normal Clock Running</li> <li>Setting the Hour</li> <li>Setting the Minute</li> <li>Setting the AM/PM</li> </ol>"},{"location":"kits/st7735/","title":"Digital Clock Using the ST7735 LCD","text":""},{"location":"kits/st7735/#overview","title":"Overview","text":"<p>The ST7735 is a low-cost color LCD with a 160x120 screen resolution.  I found the 1.8 inch version on eBay for about $3.50.  Because of the low-cost it makes an ideal starter clock display for clocks kits under $10.</p> <p></p> <p>The ST7735 uses a standard SPI 7-wire interface with one additional wire for powering the backlight of the display.  It works on 3.3 volts.</p>"},{"location":"kits/st7735/#benefits-of-the-st7735-clock-kit","title":"Benefits of the ST7735 Clock Kit","text":""},{"location":"kits/st7735/#color-display-capabilities","title":"Color Display Capabilities","text":"<ul> <li>The ST7735 offers full RGB color support using 16-bit color (RGB565 format)</li> <li>Allows for attractive color schemes like blue backgrounds with white digits shown in the code</li> <li>Can use different colors for different elements (e.g. TEXT_COLOR vs DIGIT_COLOR)</li> <li>The display can handle custom color combinations through the rgb_to_565() function</li> </ul>"},{"location":"kits/st7735/#flexible-display-options","title":"Flexible Display Options","text":"<ul> <li>Supports multiple rotation modes (0-3) through set_rotation()</li> <li>160x128 resolution provides enough space for:</li> <li>Large, readable digits</li> <li>Date display</li> <li>AM/PM indicator</li> <li>Seconds display</li> <li>Additional status information if needed</li> </ul>"},{"location":"kits/st7735/#hardware-integration","title":"Hardware Integration","text":"<ul> <li>Uses standard SPI interface making it easy to connect to microcontrollers</li> <li>Simple pin configuration (Clock, MOSI, Reset, Data/Command, Chip Select)</li> <li>Works with 3.3V logic level, compatible with many modern microcontrollers</li> <li>Fast refresh rate with 8MHz SPI baudrate support</li> </ul>"},{"location":"kits/st7735/#software-features","title":"Software Features","text":"<ul> <li>Built-in font support for text rendering</li> <li>Efficient drawing primitives for shapes and lines</li> <li>Support for bitmap images</li> <li>Anti-flicker optimization in the clock code through selective updates</li> <li>Segment-based digit drawing for custom numerical displays</li> </ul>"},{"location":"kits/st7735/#cost-effective","title":"Cost-Effective","text":"<ul> <li>Low cost (around $3.50 USD) makes it ideal for budget-friendly clock projects</li> <li>Good balance of features vs price for hobbyist projects</li> <li>Accessible enough for beginner projects while having enough capabilities for advanced features</li> </ul> <p>The code demonstrates these benefits through features like:</p> <ul> <li>Clean digit rendering using seven-segment style display</li> <li>Smooth updates with anti-flicker measures</li> <li>Multiple display elements (time, date, AM/PM) organized clearly on screen</li> <li>Efficient screen updates that only refresh changed portions</li> </ul>"},{"location":"kits/st7735/dirty-drawing/","title":"Dirty Drawing","text":"<p>We need to modify the clock program to minimize flicker by only updating the parts of the display that change. This requires tracking the previous state and only redrawing digits that have changed. Here's how we can improve it:</p> <p>The key improvements in this version include:</p> <ol> <li> <p>State Tracking: Added global variables to track the previous state of all display elements (digits, date, AM/PM, etc.)</p> </li> <li> <p>Selective Updates: Only redraws elements that have changed since the last update:</p> </li> <li>Digits are only redrawn when their values change</li> <li>The date is only updated when it changes</li> <li>AM/PM indicator only updates when switching between AM and PM</li> <li> <p>The colon blinks by only updating its small area</p> </li> <li> <p>Localized Clearing: Instead of clearing the entire screen:</p> </li> <li>Each digit area is cleared individually before redrawing</li> <li> <p>Text areas are cleared in their specific regions before updating</p> </li> <li> <p>Initialization Handling: Added a <code>screen_initialized</code> flag to ensure the background is only drawn once at startup</p> </li> <li> <p>Improved Update Rate: Reduced the sleep time to 0.1 seconds for smoother updates while still maintaining efficiency</p> </li> </ol> <p>These changes should significantly reduce the flicker since we're only updating the parts of the screen that actually change. The blue background will now only be drawn once at startup, and subsequent updates will be localized to the specific areas that need to change.</p> <p>To use this improved version, simply replace the contents of your existing clock-main-with-flicker.py with this new code. The functionality remains the same, but the display should be much more stable with minimal flicker.</p> <p>this is a great example of how selective updates can make a big difference in display quality. Instead of redrawing the entire screen 10 times per second, we're now only updating the specific segments that change. For example, when displaying \"12:59\", only the \":59\" portion will update frequently. The \"12\" will stay static until it changes to \"1:00\". The colons blink by just toggling those few pixels rather than redrawing everything.</p> <p>This technique (known as \"dirty rectangle\" updating in graphics programming) is especially important for displays like the ST7735 where each pixel update takes a non-trivial amount of time. By minimizing the number of pixels we need to update, we get both better performance and a cleaner visual result.</p> <pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport ST7735\nimport config\n\n# Initialize SPI and display\nspi = machine.SPI(config.SPI_BUS, \n                  sck=Pin(config.SPI_SCL_PIN),\n                  mosi=Pin(config.SPI_SDA_PIN),\n                  baudrate=8000000)\n\ndisplay = ST7735.ST7735(spi, \n                        rst=config.SPI_RESET_PIN,\n                        ce=config.SPI_CS_PIN,\n                        dc=config.SPI_DC_PIN)\ndisplay.reset()\ndisplay.begin()\ndisplay.set_rotation(config.DISPLAY_ROTATION)\n\n# Define colors using RGB565 format\nBACKGROUND_COLOR = display.rgb_to_565(0, 0, 255)  # Blue background\nDIGIT_COLOR = display.rgb_to_565(255, 255, 255)   # White for digits\nTEXT_COLOR = display.rgb_to_565(255, 255, 0)      # Yellow for text\n\n# Previous state tracking\nprev_date = \"\"\nprev_hour_ten = -1\nprev_hour_right = -1\nprev_minute_ten = -1\nprev_minute_right = -1\nprev_second = -1\nprev_am_pm = \"\"\nscreen_initialized = False\n\nsegmentMapping = [\n    #a, b, c, d, e, f, g\n    [1, 1, 1, 1, 1, 1, 0], # 0\n    [0, 1, 1, 0, 0, 0, 0], # 1\n    [1, 1, 0, 1, 1, 0, 1], # 2\n    [1, 1, 1, 1, 0, 0, 1], # 3\n    [0, 1, 1, 0, 0, 1, 1], # 4\n    [1, 0, 1, 1, 0, 1, 1], # 5\n    [1, 0, 1, 1, 1, 1, 1], # 6\n    [1, 1, 1, 0, 0, 0, 0], # 7\n    [1, 1, 1, 1, 1, 1, 1], # 8\n    [1, 1, 1, 1, 0, 1, 1]  # 9\n]\n\ndef day_to_str(day_num):\n    \"\"\"Convert a day number (0-6) to a three-letter day abbreviation.\"\"\"\n    days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n    if not 0 &lt;= day_num &lt;= 6:\n        raise ValueError(\"Day number must be between 0 and 6\")\n    return days[day_num]\n\ndef month_to_str(month_num):\n    \"\"\"Convert a month number (1-12) to a three-letter month abbreviation.\"\"\"\n    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', \n             'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    if not 1 &lt;= month_num &lt;= 12:\n        raise ValueError(\"Month number must be between 1 and 12\")\n    return months[month_num - 1]\n\ndef clear_digit_area(x, y, width, height, color):\n    \"\"\"Clear the area where a digit was previously drawn.\"\"\"\n    display.draw_block(x, y, width, height, color)\n\ndef drawDigit(digit, x, y, width, height, thickness, color):\n    \"\"\"Draw a seven-segment digit on the display.\"\"\"\n    if digit &lt; 0:\n        return\n\n    # Clear the area first\n    clear_digit_area(x, y, width, height, BACKGROUND_COLOR)\n\n    segmentOn = segmentMapping[digit]\n\n    # Draw horizontal segments (top, middle, bottom)\n    for i in [0, 3, 6]:\n        if segmentOn[i]:\n            if i == 0:  # top\n                yOffset = 0\n            elif i == 3:  # bottom\n                yOffset = height - thickness\n            else:  # middle\n                yOffset = height // 2 - thickness // 2\n            display.draw_block(x, y + yOffset, width, thickness, color)\n\n    # Draw vertical segments\n    for i in [1, 2, 4, 5]:\n        if segmentOn[i]:\n            if i == 1 or i == 5:  # upper segments\n                startY = y\n                endY = y + height // 2\n            else:  # lower segments\n                startY = y + height // 2\n                endY = y + height\n            xOffset = 0 if (i == 4 or i == 5) else width - thickness\n            display.draw_block(x + xOffset, startY, thickness, endY - startY, color)\n\ndef draw_colon(x, y, color):\n    \"\"\"Draw the blinking colon between hours and minutes.\"\"\"\n    display.draw_block(x, y, 4, 4, color)\n    display.draw_block(x, y + 14, 4, 4, color)\n\ndef update_screen(year, month, day, hour, minute, second, weekday):\n    \"\"\"Update only the changing parts of the display.\"\"\"\n    global prev_date, prev_hour_ten, prev_hour_right, prev_minute_ten\n    global prev_minute_right, prev_second, prev_am_pm, screen_initialized\n\n    # Initialize screen on first run\n    if not screen_initialized:\n        display.fill_screen(BACKGROUND_COLOR)\n        screen_initialized = True\n\n    # Calculate positions\n    left_margin = -15\n    y_offset = 30\n    digit_width = 32\n    digit_height = 50\n    digit_spacing = 42\n    digit_thickness = 6\n\n    # Convert 24-hour to 12-hour format\n    display_hour = hour if hour &lt;= 12 else hour - 12\n    if display_hour == 0:\n        display_hour = 12\n\n    # Format date string\n    date_str = f\"{day_to_str(weekday)} {month_to_str(month)} {day} {year}\"\n\n    # Update date if changed\n    if date_str != prev_date:\n        display._color = TEXT_COLOR\n        # Clear previous date area\n        display.draw_block(4, 4, 160, 10, BACKGROUND_COLOR)\n        display.p_string(4, 4, date_str)\n        prev_date = date_str\n\n    # Split time into digits\n    hour_ten = display_hour // 10 if display_hour &gt;= 10 else -1\n    hour_right = display_hour % 10\n    minute_ten = minute // 10\n    minute_right = minute % 10\n\n    # Update digits only if they've changed\n    if hour_ten != prev_hour_ten:\n        drawDigit(hour_ten, left_margin, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n        prev_hour_ten = hour_ten\n\n    if hour_right != prev_hour_right:\n        drawDigit(hour_right, left_margin + digit_spacing, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n        prev_hour_right = hour_right\n\n    if minute_ten != prev_minute_ten:\n        drawDigit(minute_ten, left_margin + 2*digit_spacing+10, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n        prev_minute_ten = minute_ten\n\n    if minute_right != prev_minute_right:\n        drawDigit(minute_right, left_margin + 3*digit_spacing+10, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n        prev_minute_right = minute_right\n\n    # Handle colon blinking - clear and redraw based on seconds\n    colon_x = left_margin + digit_spacing + digit_width + 8\n    colon_y = y_offset + 15\n    if second % 2:\n        draw_colon(colon_x, colon_y, DIGIT_COLOR)\n    else:\n        draw_colon(colon_x, colon_y, BACKGROUND_COLOR)\n\n    # Update AM/PM indicator if needed\n    am_pm_str = \"PM\" if hour &gt;= 12 else \"AM\"\n    if am_pm_str != prev_am_pm:\n        display._color = TEXT_COLOR\n        display.draw_block(left_margin + 3*digit_spacing + digit_width, y_offset + 60, 20, 10, BACKGROUND_COLOR)\n        display.p_string(left_margin + 3*digit_spacing + digit_width, y_offset + 60, am_pm_str)\n        prev_am_pm = am_pm_str\n\n    # Update seconds display if changed\n    if second != prev_second:\n        display._color = TEXT_COLOR\n        display.draw_block(4, y_offset + digit_height + 10, 20, 10, BACKGROUND_COLOR)\n        display.p_string(4, y_offset + digit_height + 10, f\"{second:02d}\")\n        prev_second = second\n\n# Main loop\nwhile True:\n    now = localtime()\n    year = now[0]\n    month = now[1]\n    day = now[2]\n    hour = now[3]\n    minute = now[4]\n    second = now[5]\n    weekday = now[6]\n\n    update_screen(year, month, day, hour, minute, second, weekday)\n    sleep(0.1)  # Shorter sleep for more responsive updates\n</code></pre>"},{"location":"kits/st7735/drawing-four-digits/","title":"Drawing Digits","text":"<p>Let's now draw four digits on the screen. This will have a lot of flicker which we will clean up in the next version.</p> <pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport ST7735\nimport config\n\n# Initialize SPI and display\nspi = machine.SPI(config.SPI_BUS, \n                  sck=Pin(config.SPI_SCL_PIN),\n                  mosi=Pin(config.SPI_SDA_PIN),\n                  baudrate=8000000)\n\ndisplay = ST7735.ST7735(spi, \n                        rst=config.SPI_RESET_PIN,\n                        ce=config.SPI_CS_PIN,\n                        dc=config.SPI_DC_PIN)\ndisplay.reset()\ndisplay.begin()\ndisplay.set_rotation(config.DISPLAY_ROTATION)\n\n# Define colors using RGB565 format\nBACKGROUND_COLOR = display.rgb_to_565(0, 0, 255)  # Blue background\nDIGIT_COLOR = display.rgb_to_565(255, 255, 255)   # White for digits\nTEXT_COLOR = display.rgb_to_565(255, 255, 0)      # Yellow for text\n\nsegmentMapping = [\n    #a, b, c, d, e, f, g\n    [1, 1, 1, 1, 1, 1, 0], # 0\n    [0, 1, 1, 0, 0, 0, 0], # 1\n    [1, 1, 0, 1, 1, 0, 1], # 2\n    [1, 1, 1, 1, 0, 0, 1], # 3\n    [0, 1, 1, 0, 0, 1, 1], # 4\n    [1, 0, 1, 1, 0, 1, 1], # 5\n    [1, 0, 1, 1, 1, 1, 1], # 6\n    [1, 1, 1, 0, 0, 0, 0], # 7\n    [1, 1, 1, 1, 1, 1, 1], # 8\n    [1, 1, 1, 1, 0, 1, 1]  # 9\n]\n\ndef day_to_str(day_num):\n    \"\"\"Convert a day number (0-6) to a three-letter day abbreviation.\"\"\"\n    days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n    if not 0 &lt;= day_num &lt;= 6:\n        raise ValueError(\"Day number must be between 0 and 6\")\n    return days[day_num]\n\ndef month_to_str(month_num):\n    \"\"\"Convert a month number (1-12) to a three-letter month abbreviation.\"\"\"\n    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', \n             'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    if not 1 &lt;= month_num &lt;= 12:\n        raise ValueError(\"Month number must be between 1 and 12\")\n    return months[month_num - 1]\n\ndef drawDigit(digit, x, y, width, height, thickness, color):\n    \"\"\"Draw a seven-segment digit on the display.\"\"\"\n    if digit &lt; 0:\n        return\n    segmentOn = segmentMapping[digit]\n\n    # Draw horizontal segments (top, middle, bottom)\n    for i in [0, 3, 6]:\n        if segmentOn[i]:\n            if i == 0:  # top\n                yOffset = 0\n            elif i == 3:  # bottom\n                yOffset = height - thickness\n            else:  # middle\n                yOffset = height // 2 - thickness // 2\n            display.draw_block(x, y + yOffset, width, thickness, color)\n\n    # Draw vertical segments\n    for i in [1, 2, 4, 5]:\n        if segmentOn[i]:\n            if i == 1 or i == 5:  # upper segments\n                startY = y\n                endY = y + height // 2\n            else:  # lower segments\n                startY = y + height // 2\n                endY = y + height\n            xOffset = 0 if (i == 4 or i == 5) else width - thickness\n            display.draw_block(x + xOffset, startY, thickness, endY - startY, color)\n\ndef draw_colon(x, y, color):\n    \"\"\"Draw the blinking colon between hours and minutes.\"\"\"\n    display.draw_block(x, y, 4, 4, color)\n    display.draw_block(x, y + 14, 4, 4, color)\n\ndef update_screen(year, month, day, hour, minute, second, weekday):\n    \"\"\"Update the entire display with the current time and date.\"\"\"\n    # Clear screen with background color\n    display.fill_screen(BACKGROUND_COLOR)\n\n    # Set text color for the date\n    display._color = TEXT_COLOR\n\n    # Display the date at the top\n    date_str = f\"{day_to_str(weekday)} {month_to_str(month)} {day} {year}\"\n    display.p_string(4, 4, date_str)\n\n    # Convert 24-hour to 12-hour format\n    display_hour = hour if hour &lt;= 12 else hour - 12\n    if display_hour == 0:\n        display_hour = 12\n\n    # Calculate digit positions\n    left_margin = -15\n    y_offset = 30\n    digit_width = 32\n    digit_height = 50\n    digit_spacing = 42\n    digit_thickness = 6\n\n    # Split hours and minutes into digits\n    hour_ten = display_hour // 10 if display_hour &gt;= 10 else -1\n    hour_right = display_hour % 10\n    minute_ten = minute // 10\n    minute_right = minute % 10\n\n    # Draw all digits\n    drawDigit(hour_ten, left_margin, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n    drawDigit(hour_right, left_margin + digit_spacing, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n    drawDigit(minute_ten, left_margin + 2*digit_spacing+10, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n    drawDigit(minute_right, left_margin + 3*digit_spacing+10, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n\n    # Draw the colon if it's an even second (for blinking effect)\n    if second % 2:\n        draw_colon(left_margin + digit_spacing + digit_width + 8, y_offset + 15, DIGIT_COLOR)\n\n    # Display AM/PM indicator\n    display._color = TEXT_COLOR\n    am_pm_str = \"PM\" if hour &gt;= 12 else \"AM\"\n    display.p_string(left_margin + 3*digit_spacing + digit_width, y_offset + 60, am_pm_str)\n\n    # Display seconds\n    display.p_string(4, y_offset + digit_height + 10, f\"{second}\")\n\n# Main loop\nwhile True:\n    now = localtime()\n    year = now[0]\n    month = now[1]\n    day = now[2]\n    hour = now[3]\n    minute = now[4]\n    second = now[5]\n    weekday = now[6]\n\n    update_screen(year, month, day, hour, minute, second, weekday)\n    sleep(1)\n</code></pre>"},{"location":"kits/st7735/hello-world/","title":"Hello World","text":"<pre><code># ST7735 LCD Test\nimport machine\nimport ST7735\n\n# SCL=2 and SDK=3 implied for bus 0\nspi = machine.SPI(0, baudrate=8000000)\nd = ST7735.ST7735(spi, rst=4, ce=6, dc=5)\nd.reset()\nd.begin()\nd.set_rotation(1)\nd._bground = 0xffff\n# white\nd.fill_screen(d._bground)\n# make background all white\nd._color = 0x0000 # black ink\nd.p_string(10,10,'Hello World!')\n</code></pre>"},{"location":"kits/st7735/hello-world/#config-file","title":"Config File","text":"<pre><code># Hardware configuration file for ST7735 clock\n\nSPI_BUS = 0\nSPI_SCL_PIN = 2 # Clock\nSPI_SDA_PIN = 3 # labeled SDI(MOSI) on the back of the display\nSPI_RESET_PIN = 4 # Reset\nSPI_DC_PIN = 5 # Data/command\nSPI_CS_PIN = 6 # Chip Select\n\n# Screen Dimensions\nDISPLAY_WIDTH=160\nDISPLAY_HEIGHT=128\nDISPLAY_ROTATION = 1\n\n# Use builtin pull ups\nMODE_PIN = 14 # one up from lower-left corner\nINCREMENT_PIN = 15 # lower left corner with USB on top\nDECREMENT_PIN = 16 # lower left corner with USB on top\n</code></pre>"},{"location":"kits/st7735/multiple-fonts/","title":"Multiple Fonts","text":"<p>Looking at the provided code, I can help explain the font situation and suggest some improvements for working with larger fonts on the ST7735 display.</p> <p>Currently, the code is using a basic 5x7 pixel font (\"font5x7.fnt\") which is indeed quite small and pixelated. There are several ways to handle larger, better-looking fonts on this display:</p>"},{"location":"kits/st7735/multiple-fonts/#1-bdfpcf-fonts","title":"1. BDF/PCF Fonts:","text":"<p>You could convert standard BDF/PCF fonts into a custom format that works with your display. Here's how we could implement this:</p> <p>To use this improved font system, you would:</p> <ol> <li>Convert a BDF font to our binary format using the <code>convert_bdf_to_binary()</code> function</li> <li>Load and use the font in your main code like this:</li> </ol> <pre><code>from custom_font_handler import FontHandler\n\n# Initialize your display as before\nspi = machine.SPI(0, baudrate=8000000)\nd = ST7735.ST7735(spi, rst=4, ce=6, dc=5)\nd.reset()\nd.begin()\n\n# Create font handler and load font\nfont_handler = FontHandler(d)\nfont_handler.load_font('your_converted_font.bin')\n\n# Use the font\nfont_handler.text(10, 10, \"Hello World!\", d.rgb_to_565(255, 255, 255))\n</code></pre>"},{"location":"kits/st7735/multiple-fonts/#2-bitmap-fonts","title":"2. Bitmap Fonts:","text":"<p>Another approach would be to store pre-rendered characters as bitmap images and display them using your existing <code>bmp()</code> function. This would give you the best quality but would use more storage space.</p>"},{"location":"kits/st7735/multiple-fonts/#3-vector-fonts","title":"3. Vector Fonts:","text":"<p>While more complex, you could implement basic vector font rendering. This would give you scalable text but would require more processing power.</p> <p>For the best balance of quality and performance, I recommend going with the BDF font approach (option 1). You can find many BDF fonts online, including larger sizes that would look better on your display. Some good fonts to start with would be:</p> <ul> <li>Terminus (has sizes from 6x12 to 20x40)</li> <li>ProFont (clean and readable at various sizes)</li> <li>GNU Unifont (comprehensive character coverage)</li> </ul> <p>To get started, you would:</p> <ol> <li>Download a BDF font</li> <li>Convert it using the provided converter</li> <li>Copy the binary font file to your Pico</li> <li>Use the FontHandler class to render text</li> </ol> <p>Would you like me to provide an example using a specific BDF font, or would you prefer help implementing one of the other approaches?</p>"},{"location":"kits/st7735/scaling-fonts/","title":"Scaling Fonts","text":"<p>We can modify the code to use a larger font for the date. Looking at the ST7735.py code, I notice it's using a built-in font5x7 font, but there's no built-in option for larger fonts. However, we can draw larger text by scaling up each character.</p> <pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport ST7735\nimport config\n\n# Initialize SPI and display\nspi = machine.SPI(config.SPI_BUS, \n                  sck=Pin(config.SPI_SCL_PIN),\n                  mosi=Pin(config.SPI_SDA_PIN),\n                  baudrate=8000000)\n\ndisplay = ST7735.ST7735(spi, \n                        rst=config.SPI_RESET_PIN,\n                        ce=config.SPI_CS_PIN,\n                        dc=config.SPI_DC_PIN)\ndisplay.reset()\ndisplay.begin()\ndisplay.set_rotation(config.DISPLAY_ROTATION)\n\n# Define colors using RGB565 format\nBACKGROUND_COLOR = display.rgb_to_565(0, 0, 255)  # Blue background\nDIGIT_COLOR = display.rgb_to_565(255, 255, 255)   # White for digits\nTEXT_COLOR = display.rgb_to_565(255, 255, 0)      # Yellow for text\n\n# Scaled text drawing functions\ndef draw_scaled_char(display, x, y, ch, scale=1):\n    \"\"\"Draw a single character at the specified scale\"\"\"\n    fp = (ord(ch)-0x20) * 5\n    f = open('font5x7.fnt','rb')\n    f.seek(fp)\n    b = f.read(5)\n    char_buf = bytearray(b)\n    char_buf.append(0)\n\n    # Scale up the character\n    char_image = bytearray()\n    for bit in range(8):\n        # Repeat each row scale times\n        for _ in range(scale):\n            for c in range(6):\n                # Repeat each pixel scale times\n                pixel = ((char_buf[c]&gt;&gt;bit) &amp; 1)&gt;0\n                for _ in range(scale):\n                    if pixel:\n                        char_image.append(display._color &gt;&gt; 8)\n                        char_image.append(display._color &amp; 0xff)\n                    else:\n                        char_image.append(display._bground &gt;&gt; 8)\n                        char_image.append(display._bground &amp; 0xff)\n    display.draw_bmp(x, y, 6*scale, 8*scale, char_image)\n    f.close()\n\ndef draw_scaled_string(display, x, y, text, scale=1):\n    \"\"\"Draw a string of text at the specified scale\"\"\"\n    for ch in text:\n        draw_scaled_char(display, x, y, ch, scale)\n        x += 6 * scale\n\n# Previous state tracking\nprev_date = \"\"\nprev_hour_ten = -1\nprev_hour_right = -1\nprev_minute_ten = -1\nprev_minute_right = -1\nprev_second = -1\nprev_am_pm = \"\"\nscreen_initialized = False\n\nsegmentMapping = [\n    #a, b, c, d, e, f, g\n    [1, 1, 1, 1, 1, 1, 0], # 0\n    [0, 1, 1, 0, 0, 0, 0], # 1\n    [1, 1, 0, 1, 1, 0, 1], # 2\n    [1, 1, 1, 1, 0, 0, 1], # 3\n    [0, 1, 1, 0, 0, 1, 1], # 4\n    [1, 0, 1, 1, 0, 1, 1], # 5\n    [1, 0, 1, 1, 1, 1, 1], # 6\n    [1, 1, 1, 0, 0, 0, 0], # 7\n    [1, 1, 1, 1, 1, 1, 1], # 8\n    [1, 1, 1, 1, 0, 1, 1]  # 9\n]\n\ndef day_to_str(day_num):\n    \"\"\"Convert a day number (0-6) to a three-letter day abbreviation.\"\"\"\n    days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n    if not 0 &lt;= day_num &lt;= 6:\n        raise ValueError(\"Day number must be between 0 and 6\")\n    return days[day_num]\n\ndef month_to_str(month_num):\n    \"\"\"Convert a month number (1-12) to a three-letter month abbreviation.\"\"\"\n    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', \n             'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    if not 1 &lt;= month_num &lt;= 12:\n        raise ValueError(\"Month number must be between 1 and 12\")\n    return months[month_num - 1]\n\ndef clear_digit_area(x, y, width, height, color):\n    \"\"\"Clear the area where a digit was previously drawn.\"\"\"\n    display.draw_block(x, y, width, height, color)\n\ndef drawDigit(digit, x, y, width, height, thickness, color):\n    \"\"\"Draw a seven-segment digit on the display.\"\"\"\n    if digit &lt; 0:\n        return\n\n    # Clear the area first\n    clear_digit_area(x, y, width, height, BACKGROUND_COLOR)\n\n    segmentOn = segmentMapping[digit]\n\n    # Draw horizontal segments (top, middle, bottom)\n    for i in [0, 3, 6]:\n        if segmentOn[i]:\n            if i == 0:  # top\n                yOffset = 0\n            elif i == 3:  # bottom\n                yOffset = height - thickness\n            else:  # middle\n                yOffset = height // 2 - thickness // 2\n            display.draw_block(x, y + yOffset, width, thickness, color)\n\n    # Draw vertical segments\n    for i in [1, 2, 4, 5]:\n        if segmentOn[i]:\n            if i == 1 or i == 5:  # upper segments\n                startY = y\n                endY = y + height // 2\n            else:  # lower segments\n                startY = y + height // 2\n                endY = y + height\n            xOffset = 0 if (i == 4 or i == 5) else width - thickness\n            display.draw_block(x + xOffset, startY, thickness, endY - startY, color)\n\ndef draw_colon(x, y, color):\n    \"\"\"Draw the blinking colon between hours and minutes.\"\"\"\n    display.draw_block(x, y, 4, 4, color)\n    display.draw_block(x, y + 14, 4, 4, color)\n\ndef update_screen(year, month, day, hour, minute, second, weekday):\n    \"\"\"Update only the changing parts of the display.\"\"\"\n    global prev_date, prev_hour_ten, prev_hour_right, prev_minute_ten\n    global prev_minute_right, prev_second, prev_am_pm, screen_initialized\n\n    # Initialize screen on first run\n    if not screen_initialized:\n        display.fill_screen(BACKGROUND_COLOR)\n        screen_initialized = True\n\n    # Calculate positions\n    left_margin = -15\n    y_offset = 30\n    digit_width = 32\n    digit_height = 50\n    digit_spacing = 42\n    digit_thickness = 6\n\n    # Convert 24-hour to 12-hour format\n    display_hour = hour if hour &lt;= 12 else hour - 12\n    if display_hour == 0:\n        display_hour = 12\n\n    # Format date string - use 2-digit year to save space\n    date_str = f\"{day_to_str(weekday)} {month_to_str(month)} {day} {str(year)[2:]}\"\n\n    # Update date if changed\n    if date_str != prev_date:\n        display._color = TEXT_COLOR\n        # Clear previous date area (increased height for larger font)\n        display.draw_block(4, 4, 160, 20, BACKGROUND_COLOR)\n        draw_scaled_string(display, 4, 4, date_str, scale=2)  # Scale up the date text\n        prev_date = date_str\n\n    # Split time into digits\n    hour_ten = display_hour // 10 if display_hour &gt;= 10 else -1\n    hour_right = display_hour % 10\n    minute_ten = minute // 10\n    minute_right = minute % 10\n\n    # Update digits only if they've changed\n    if hour_ten != prev_hour_ten:\n        drawDigit(hour_ten, left_margin, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n        prev_hour_ten = hour_ten\n\n    if hour_right != prev_hour_right:\n        drawDigit(hour_right, left_margin + digit_spacing, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n        prev_hour_right = hour_right\n\n    if minute_ten != prev_minute_ten:\n        drawDigit(minute_ten, left_margin + 2*digit_spacing+10, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n        prev_minute_ten = minute_ten\n\n    if minute_right != prev_minute_right:\n        drawDigit(minute_right, left_margin + 3*digit_spacing+10, y_offset, digit_width, digit_height, digit_thickness, DIGIT_COLOR)\n        prev_minute_right = minute_right\n\n    # Handle colon blinking - clear and redraw based on seconds\n    colon_x = left_margin + digit_spacing + digit_width + 8\n    colon_y = y_offset + 15\n    if second % 2:\n        draw_colon(colon_x, colon_y, DIGIT_COLOR)\n    else:\n        draw_colon(colon_x, colon_y, BACKGROUND_COLOR)\n\n    # Update AM/PM indicator if needed\n    am_pm_str = \"PM\" if hour &gt;= 12 else \"AM\"\n    if am_pm_str != prev_am_pm:\n        display._color = TEXT_COLOR\n        display.draw_block(left_margin + 3*digit_spacing + digit_width, y_offset + 60, 20, 10, BACKGROUND_COLOR)\n        display.p_string(left_margin + 3*digit_spacing + digit_width, y_offset + 60, am_pm_str)\n        prev_am_pm = am_pm_str\n\n    # Update seconds display if changed\n    if second != prev_second:\n        display._color = TEXT_COLOR\n        display.draw_block(4, y_offset + digit_height + 10, 20, 10, BACKGROUND_COLOR)\n        display.p_string(4, y_offset + digit_height + 10, f\"{second:02d}\")\n        prev_second = second\n\n# Main loop\nwhile True:\n    now = localtime()\n    year = now[0]\n    month = now[1]\n    day = now[2]\n    hour = now[3]\n    minute = now[4]\n    second = now[5]\n    weekday = now[6]\n\n    update_screen(year, month, day, hour, minute, second, weekday)\n    sleep(0.1)  # Shorter sleep for more responsive updates\n</code></pre> <p>We have made several changes to support larger text:</p> <ul> <li>Modified the p_char method to support scaling characters by repeating pixels</li> <li>Updated the p_string method to accept a scale parameter</li> <li>Increased the clearing area for the date to accommodate the larger text</li> <li>Set the date text to scale=2 (twice the normal size)</li> </ul> <p>Now the date should be displayed at double the original size. The scaling works by multiplying each pixel in the original font, so a scale of 2 means each pixel becomes a 2x2 block of pixels, making the text larger while maintaining its proportions.</p> <p>You can adjust the scale factor by changing the scale=2 parameter in the p_string call. For example:</p> <p>scale=1 is the original size scale=2 doubles the size scale=3 triples the size</p>"},{"location":"kits/st7735/set-mode-buttons/","title":"Set the Mode Buttons","text":"<p>We need a way to monitor the Set/Mode, Increment and Decrement buttons to manually set the time.  Here is a program that will monitor the three buttons and change the mode.</p> <pre><code>from utime import sleep, ticks_ms, ticks_diff\nfrom machine import Pin\n\n# Global Variable Default Settings\nmode = 0\nhour = 6\nminute = 30\npm_indicator = True\nmode_names = ['run', 'set hour', 'set minute', 'set AM/PM']\nmode_count = len(mode_names)\n\n# Button Pin GPIO Configuration\nCHANGE_MODE_PIN = 13\nINCREMENT_PIN = 14\nDECREMENT_PIN = 15\nDEBOUNCE_TIME_MS = 200\n\n# Create 3 button objects as inputs with pullup resistors\nchange_mode_pin = Pin(CHANGE_MODE_PIN, Pin.IN, Pin.PULL_UP)\nincrement_pin = Pin(INCREMENT_PIN, Pin.IN, Pin.PULL_UP)\ndecrement_pin = Pin(DECREMENT_PIN, Pin.IN, Pin.PULL_UP)\n\n# Variables to track last button press times for debouncing\nlast_mode_press = 0\nlast_increment_press = 0\nlast_decrement_press = 0\n\n# These functions gets called every time a button is pressed\ndef mode_button_pressed(pin):\n    global mode, last_mode_press\n    current_time = ticks_ms()\n    if ticks_diff(current_time, last_mode_press) &gt; DEBOUNCE_TIME_MS:\n        mode += 1\n        mode = mode % mode_count\n        last_mode_press = current_time\n\ndef increment_button_pressed(pin):\n    global mode, hour, minute, pm_indicator, last_increment_press\n    current_time = ticks_ms()\n    if ticks_diff(current_time, last_increment_press) &gt; DEBOUNCE_TIME_MS:\n        if mode == 1:\n            hour = (hour % 12) + 1  # Increment hour from 1-12 properly\n        if mode == 2:\n            minute += 1\n            minute = minute % 60  # Fixed: minute should go from 0 to 59\n        if mode == 3:\n            pm_indicator = not pm_indicator\n        last_increment_press = current_time\n\ndef decrement_button_pressed(pin):\n    global mode, hour, minute, pm_indicator, last_decrement_press\n    current_time = ticks_ms()\n    if ticks_diff(current_time, last_decrement_press) &gt; DEBOUNCE_TIME_MS:\n        if mode == 1:\n            hour -= 1\n            if hour &lt;= 0:  # Handle wrapping from 1 to 12\n                hour = 12\n        if mode == 2:\n            minute -= 1\n            if minute &lt; 0:  # Handle wrapping from 0 to 59\n                minute = 59\n        if mode == 3:\n            pm_indicator = not pm_indicator\n        last_decrement_press = current_time\n\n# Register the button handler functions using the irq setter method for each pin\nchange_mode_pin.irq(trigger=Pin.IRQ_FALLING, handler=mode_button_pressed)\nincrement_pin.irq(trigger=Pin.IRQ_FALLING, handler=increment_button_pressed)\ndecrement_pin.irq(trigger=Pin.IRQ_FALLING, handler=decrement_button_pressed)\n\n# Only print on change - these variables store the old values\nlast_mode = mode\nlast_hour = hour\nlast_minute = minute\nlast_pm_indicator = pm_indicator\nprint(\"Default values: mode:\", mode, \"hour:\", hour, \"minute:\", minute, \"pm indicator:\", pm_indicator)\n\nwhile True:\n    if mode != last_mode:\n        print(\"new mode:\", mode, mode_names[mode])\n        last_mode = mode\n    if hour != last_hour:\n        print(\"new hour:\", hour)\n        last_hour = hour\n    if minute != last_minute:\n        print(\"new minute:\", minute)\n        last_minute = minute\n    if pm_indicator != last_pm_indicator:\n        print(\"new pm indicator:\", pm_indicator)\n        last_pm_indicator = pm_indicator\n    # sleep(.01)\n</code></pre>"},{"location":"kits/st7735/single-digit/","title":"Draw a Single Digit on the ST7735 LCD","text":"<pre><code># Draw a single digit on the ST7735 LCD\nimport machine\nimport ST7735\nfrom utime import sleep\n\n# Initialize SPI and display\nspi = machine.SPI(0, baudrate=8000000)\nd = ST7735.ST7735(spi, rst=4, ce=6, dc=5)\nd.reset()\nd.begin()\nd.set_rotation(1)  # Rotate to landscape mode\n\n# Define colors using RGB565 format\nBLUE_BACKGROUND = d.rgb_to_565(0, 0, 255)  # Blue background\nWHITE_DIGIT = d.rgb_to_565(255, 255, 255)  # White for digits\n\nsegmentMapping = [\n    #a, b, c, d, e, f, g\n    [1, 1, 1, 1, 1, 1, 0], # 0\n    [0, 1, 1, 0, 0, 0, 0], # 1\n    [1, 1, 0, 1, 1, 0, 1], # 2\n    [1, 1, 1, 1, 0, 0, 1], # 3\n    [0, 1, 1, 0, 0, 1, 1], # 4\n    [1, 0, 1, 1, 0, 1, 1], # 5\n    [1, 0, 1, 1, 1, 1, 1], # 6\n    [1, 1, 1, 0, 0, 0, 0], # 7\n    [1, 1, 1, 1, 1, 1, 1], # 8\n    [1, 1, 1, 1, 0, 1, 1]  # 9\n]\n\ndef drawDigit(digit, x, y, width, height, thickness, color):\n    # Get segments that are on for this digit\n    segmentOn = segmentMapping[digit]\n\n    # Draw horizontal segments (top, bottom, middle)\n    for i in [0, 3, 6]:\n        if segmentOn[i]:\n            if i == 0:  # top\n                yOffset = 0\n            elif i == 3:  # bottom\n                yOffset = height - thickness\n            else:  # middle\n                yOffset = height // 2 - thickness // 2\n\n            d.draw_block(x, y + yOffset, width, thickness, color)\n\n    # Draw vertical segments (upper right, lower right, lower left, upper left)\n    for i in [1, 2, 4, 5]:\n        if segmentOn[i]:\n            # Set vertical position\n            if i == 1 or i == 5:  # upper segments\n                startY = y\n                endY = y + height // 2\n            else:  # lower segments\n                startY = y + height // 2\n                endY = y + height\n\n            # Set horizontal position\n            if i == 4 or i == 5:  # left segments\n                xOffset = 0\n            else:  # right segments\n                xOffset = width - thickness\n\n            d.draw_block(x + xOffset, startY, thickness, endY - startY, color)\n\ndef update_screen(digit_val):\n    # Clear screen with blue background\n    d.fill_screen(BLUE_BACKGROUND)\n\n    # Draw the digit in white\n    drawDigit(digit_val, 50, 40, 40, 60, 8, WHITE_DIGIT)\n\n    # Add text label\n    d._color = WHITE_DIGIT  # Set text color to white\n    d.p_string(10, 10, f'Digit: {digit_val}')\n\n# Main loop\ncounter = 0\nwhile True:\n    update_screen(counter)\n    sleep(1)\n    counter = (counter + 1) % 10\n</code></pre>"},{"location":"kits/stopwatch/","title":"Stopwatch","text":""},{"location":"kits/stopwatch/#overview","title":"Overview","text":"<p>Here is a two-button stopwatch that uses the OLED display. The first button is called the Start/Stop button.  When you first press start it starts to add up the time since it was pressed.  Pressing it again will stop collecting time but still remember the total accumulated time while the stopwatch was running.</p> <p>The second button is the Reset button.  When you press Reset the total time accumulated will be reset back to 0.</p>"},{"location":"kits/stopwatch/#the-microsimulation","title":"The MicroSimulation","text":""},{"location":"kits/stopwatch/#program-structure","title":"Program Structure","text":"<p>Let me break down this stopwatch program in a way that's easy to understand!</p> <p>Let's think of this like building a digital stopwatch step by step:</p>"},{"location":"kits/stopwatch/#step-1-the-parts-hardware-setup","title":"STEP 1 - The Parts (\"Hardware Setup\")","text":"<ul> <li>We're using a small computer called a Raspberry Pi Pico</li> <li>It has two buttons connected to it: one for Start/Stop and one for Reset</li> <li>There's a small screen (called an OLED display) that shows us the time</li> <li>The display connects to the Pico using special pins, like plugging in a cable</li> </ul>"},{"location":"kits/stopwatch/#step-2-setting-up-our-variables-global-variables","title":"STEP 2 - Setting Up Our Variables (\"Global Variables\")","text":"<ul> <li>Think of these like creating storage boxes for important information</li> <li>We have boxes for:</li> <li>Whether the stopwatch is running or stopped</li> <li>When we started timing</li> <li>How much time has passed in total</li> <li>When we last pressed a button (to avoid accidental double-presses)</li> </ul>"},{"location":"kits/stopwatch/#step-3-the-startstop-button-function","title":"STEP 3 - The Start/Stop Button Function","text":"<ul> <li>When you press the Start/Stop button:</li> <li>If the stopwatch was stopped \u2192 it starts running and remembers the start time</li> <li>If it was running \u2192 it stops and saves how much time has passed</li> <li>It's like pressing the start/stop on a real stopwatch!</li> </ul>"},{"location":"kits/stopwatch/#step-4-the-reset-button-function","title":"STEP 4 - The Reset Button Function","text":"<ul> <li>When you press Reset:</li> <li>It stops the stopwatch</li> <li>Sets all the saved time back to zero</li> <li>Like clearing your stopwatch to start fresh</li> </ul>"},{"location":"kits/stopwatch/#step-5-making-time-look-nice-format_time","title":"STEP 5 - Making Time Look Nice (\"format_time\")","text":"<ul> <li>This part takes the raw time (which is in milliseconds) and makes it look readable</li> <li>Instead of showing \"12500 milliseconds\", it shows \"00:12.500\" (12.5 seconds)</li> <li>It's like converting 60 minutes into 1 hour - just more precise!</li> </ul>"},{"location":"kits/stopwatch/#step-6-updating-the-display","title":"STEP 6 - Updating the Display","text":"<ul> <li>This happens many times per second</li> <li>If the stopwatch is running:</li> <li>It takes the current time and subtracts the start time</li> <li>Adds any time saved from previous runs</li> <li>Shows this on the screen</li> <li>If the stopwatch is stopped:</li> <li>It just shows the saved time</li> </ul>"},{"location":"kits/stopwatch/#step-7-the-main-program-loop","title":"STEP 7 - The Main Program Loop","text":"<ul> <li>This is like the heartbeat of the program</li> <li>Every 1/10th of a second:</li> <li>It checks if any buttons were pressed</li> <li>Updates the time on the display</li> <li>Keeps everything running smoothly</li> </ul> <p>Think of it like this: Imagine you're timing a race with a regular stopwatch. You: 1. Press start when the race begins (Start button) 2. Press stop when someone finishes (Stop button) 3. Can pause and restart for multiple racers (Start/Stop button again) 4. Clear it to zero for a new race (Reset button)</p> <p>This program does all that, but digitally! The main difference is that it's much more precise - it can measure down to milliseconds (thousandths of a second), which would be impossible with a regular handheld stopwatch.</p>"},{"location":"kits/stopwatch/#sample-code","title":"Sample Code","text":"<pre><code>from mp_button import Button\nfrom machine import Pin, SPI\nimport ssd1306\nfrom utime import sleep, ticks_ms, ticks_diff\n\n# lower right corner - button closes path to GND\n# HARDWARE PIN CONFIGURATION\n# LEDs\nPICO_ONBOARD_LED_PIN = 25\n# Button pins\nSTOPWATCH_START_STOP_PIN = 14\nSTOPWATCH_RESET_PIN = 15\n# Display pins\nDISPLAY_SCL_PIN = 2\nDISPLAY_SDA_PIN = 3\nDISPLAY_RES_PIN = 4\nDISPLAY_DC_PIN = 5\nDISPLAY_CS_PIN = 6\n\n# configure the pins\nstart_stop_pin = Pin(STOPWATCH_START_STOP_PIN, Pin.IN, Pin.PULL_UP)\nreset_pin = Pin(STOPWATCH_RESET_PIN, Pin.IN, Pin.PULL_UP)\n\nled = machine.Pin(PICO_ONBOARD_LED_PIN, machine.Pin.OUT)\n\nSCL=Pin(DISPLAY_SCL_PIN)\nSDA=Pin(DISPLAY_SDA_PIN)\nspi=SPI(0, sck=SCL, mosi=SDA)\nRES = Pin(DISPLAY_RES_PIN)\nDC = Pin(DISPLAY_DC_PIN)\nCS = machine.Pin(DISPLAY_CS_PIN)\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\n# Global variables\nSTOPPED = const(0)\nRUNNING = const(1)\nstopwatch_state = STOPPED\nstopwatch_starttime = 0\nstopwatch_elapsed_time = 0  # Renamed from stopwatch_resume_time for clarity\nlast_start_stop_press = 0\nlast_reset_press = 0\nDEBOUNCE_MS = 250\n\ndef start_stop_irq(pin):\n    global last_start_stop_press, stopwatch_state, stopwatch_starttime, stopwatch_elapsed_time\n    current_time = ticks_ms()\n    if ticks_diff(current_time, last_start_stop_press) &gt; DEBOUNCE_MS:\n        last_start_stop_press = current_time\n\n        if stopwatch_state == STOPPED:\n            stopwatch_state = RUNNING\n            stopwatch_starttime = ticks_ms()\n        else:\n            # Calculate the time elapsed since last start\n            stopwatch_elapsed_time += ticks_diff(ticks_ms(), stopwatch_starttime)\n            stopwatch_state = STOPPED\n\ndef reset_irq(pin):\n    global last_reset_press, stopwatch_state, stopwatch_elapsed_time\n    current_time = ticks_ms()\n    if ticks_diff(current_time, last_reset_press) &gt; DEBOUNCE_MS:\n        last_reset_press = current_time\n        stopwatch_state = STOPPED\n        stopwatch_elapsed_time = 0\n\n# Here are the Interupt handlers\nstart_stop_pin.irq(trigger=Pin.IRQ_RISING, handler=start_stop_irq)\nreset_pin.irq(trigger=Pin.IRQ_FALLING, handler=reset_irq)\n\n\ndef format_time(milliseconds):\n    \"\"\"Convert milliseconds to formatted time string (MM:SS.mmm)\"\"\"\n    seconds = milliseconds // 1000\n    ms = milliseconds % 1000\n    minutes = seconds // 60\n    seconds = seconds % 60\n    return f\"{minutes:02d}:{seconds:02d}.{ms:03d}\"\n\ndef update_screen(state, elapsed_time):\n    global stopwatch_starttime\n    oled.fill(0)\n    oled.text(\"stopwatch lab\", 0, 0, 1)\n    state_text = \"RUNNING\" if state == RUNNING else \"STOPPED\"\n    oled.text(state_text, 0, 20, 1)\n\n    if state == RUNNING:\n        current_time = elapsed_time + ticks_diff(ticks_ms(), stopwatch_starttime)\n        oled.text(format_time(current_time), 0, 40, 1)\n    else:\n        oled.text(format_time(elapsed_time), 0, 40, 1)\n    oled.show()\n\n# Main loop\nwhile True:\n    update_screen(stopwatch_state, stopwatch_elapsed_time)\n    sleep(0.1)\n</code></pre>"},{"location":"kits/tm1637/","title":"TM1637 LED Display","text":"<p>Setting the Time</p> <p></p> <p>The TM1637 LED digital display is an incredibly popular and cost-effective 4-digit 7-segment display module widely used in hobbyist electronics and educational projects. At around 30 cents per unit when purchased in bulk, it offers exceptional value for clock projects, counters, and basic numeric displays.</p> <p>Key features: - 4 digits with decimal points - Built-in controller chip that handles multiplexing - Simple 2-wire interface (clock and data) - 3.3V or 5V compatible - Brightness control - Colon indicator for clock displays</p> <p>What makes the TM1637 particularly appealing for MicroPython projects is its straightforward programming interface. Using just two pins (clock and data), you can control all segments and digits through a simple serial protocol. The module handles all the multiplexing internally, making it much easier to use than raw 7-segment displays.</p> <p>The TM1637 LED Clock is a low-cost way to get started.  It is simple to setup and use and only requires the user to make 4 connections.</p> <p></p>"},{"location":"kits/tm1637/#parts-list","title":"Parts List","text":"<ol> <li>1/2 Size 400 tie solderless Breadboard</li> <li>4 Male-Female 20cm jumper wires (Dupont Cables)</li> <li>Raspberry Pi Pico (or Pico W)</li> <li>TM1637 LED Clock display</li> <li>Real time clock</li> </ol>"},{"location":"kits/tm1637/#connection-diagram","title":"Connection Diagram","text":""},{"location":"kits/tm1637/#the-micropython-preamble","title":"The MicroPython Preamble","text":"<pre><code>import tm1637\nfrom machine import Pin, RTC\nfrom utime import sleep, localtime, ticks_ms\n\n# Initialize display\ntm = tm1637.TM1637(clk=Pin(0), dio=Pin(1))\n</code></pre> <p>Here's some example MicroPython code to test various display features using your preamble:</p> <pre><code># Basic number display\ntm.numbers(12, 59)  # Display 12:59\nsleep(1)\n\n# Show temperature with decimal\ntm.temperature(23.4)  # Display 23.4\nsleep(1)\n\n# Control brightness (0-7)\ntm.brightness(2)  # Set to medium brightness\n\n# Blank the display\ntm.show('    ')\nsleep(1)\n\n# Show individual digits\ntm.write([0, 1, 2, 3])  # Display 0123\nsleep(1)\n\n# Toggle colon\ntm.show('1234', True)  # Show 12:34 with colon\nsleep(1)\ntm.show('1234', False)  # Show 1234 without colon\nsleep(1)\n\n# Scroll some numbers\nfor i in range(10):\n    tm.number(i * 111)\n    sleep(0.5)\n\n# Test all segments\ntm.write([0x7f, 0x7f, 0x7f, 0x7f])  # All segments on\nsleep(1)\n</code></pre> <p>Given its popularity, there are several MicroPython libraries available for the TM1637. The example above uses one of the most common libraries. The display's simplicity and reliability have made it a staple in DIY electronics, particularly for clock projects, temperature displays, and basic counters. You'll find it used in countless Arduino and Raspberry Pi Pico projects, making it one of the most recognizable LED display modules in the maker community.</p>"},{"location":"kits/tm1637/manual-time-setting/","title":"Manually Setting the Time","text":"<p>Setting the Time</p> <p>Next, we will create a complete program that implements a clock with  manual time setting using the three buttons. This is a great practical  example that teaches state management and user input handling.</p> <pre><code>import tm1637\nfrom machine import Pin, RTC\nfrom utime import sleep, localtime, ticks_ms\n\n# Initialize display and RTC\ntm = tm1637.TM1637(clk=Pin(0), dio=Pin(1))\nrtc = RTC()\n\n# Initialize buttons with pull-up resistors\nmode_btn = Pin(2, Pin.IN, Pin.PULL_UP)\nnext_btn = Pin(3, Pin.IN, Pin.PULL_UP)\nprev_btn = Pin(4, Pin.IN, Pin.PULL_UP)\n\n# Clock modes\nRUNNING = 0\nSET_HOUR = 1\nSET_MINUTE = 2\nSET_AMPM = 3\n\nclass Clock:\n    def __init__(self):\n        self.mode = RUNNING\n        self.hours = 12\n        self.minutes = 0\n        self.is_pm = False\n        self.colon_on = True\n        self.last_button_time = ticks_ms()\n        self.button_debounce = 200  # milliseconds\n        self.load_time_from_rtc()\n\n    def load_time_from_rtc(self):\n        \"\"\"Get current time from RTC\"\"\"\n        _, _, _, _, hours, minutes, _, _ = rtc.datetime()\n        self.hours = hours % 12\n        if self.hours == 0:\n            self.hours = 12\n        self.is_pm = hours &gt;= 12\n        self.minutes = minutes\n\n    def save_time_to_rtc(self):\n        \"\"\"Save current time to RTC\"\"\"\n        current_time = list(rtc.datetime())\n        hours = self.hours\n        if self.is_pm and hours != 12:\n            hours += 12\n        elif not self.is_pm and hours == 12:\n            hours = 0\n        current_time[4] = hours  # Set hours\n        current_time[5] = self.minutes  # Set minutes\n        rtc.datetime(tuple(current_time))\n\n    def debounce(self):\n        \"\"\"Handle button debouncing\"\"\"\n        current_time = ticks_ms()\n        if current_time - self.last_button_time &lt; self.button_debounce:\n            return False\n        self.last_button_time = current_time\n        return True\n\n    def handle_buttons(self):\n        \"\"\"Process button inputs\"\"\"\n        if not self.debounce():\n            return\n\n        # Mode button cycles through modes\n        if mode_btn.value() == 0:  # Button pressed (active low)\n            self.mode = (self.mode + 1) % 4\n            if self.mode == RUNNING:\n                self.save_time_to_rtc()\n\n        # Next/Previous buttons modify current setting\n        elif next_btn.value() == 0 or prev_btn.value() == 0:\n            increment = -1 if prev_btn.value() == 0 else 1\n\n            if self.mode == SET_HOUR:\n                self.hours = ((self.hours + increment - 1) % 12) + 1\n            elif self.mode == SET_MINUTE:\n                self.minutes = (self.minutes + increment) % 60\n            elif self.mode == SET_AMPM:\n                self.is_pm = not self.is_pm\n\n    def update_display(self):\n        \"\"\"Update the TM1637 display based on current mode and time\"\"\"\n        if self.mode == RUNNING:\n            # Normal time display with blinking colon\n            self.colon_on = not self.colon_on\n        else:\n            # Setting mode - flash the active component\n            flash_on = (ticks_ms() // 500) % 2 == 0\n\n            if self.mode == SET_HOUR:\n                if not flash_on:\n                    tm.show('    ')\n                    return\n            elif self.mode == SET_MINUTE:\n                if not flash_on:\n                    tm.numbers(self.hours, 0)\n                    return\n            elif self.mode == SET_AMPM:\n                if flash_on:\n                    tm.show(' ' + ('P' if self.is_pm else 'A') + ' ')\n                    return\n\n        # Update display\n        tm.numbers(self.hours, self.minutes, colon=self.colon_on)\n\n    def run(self):\n        \"\"\"Main clock loop\"\"\"\n        tm.brightness(2)  # Set initial brightness\n\n        while True:\n            self.handle_buttons()\n\n            if self.mode == RUNNING:\n                self.load_time_from_rtc()\n\n            self.update_display()\n            sleep(0.1)  # Small delay to prevent display flicker\n\n# Create and run the clock\nif __name__ == '__main__':\n    clock = Clock()\n    print(\"Starting clock... Use buttons to set time:\")\n    print(\"Mode: Switch between run/set hour/set minute/set AM,PM\")\n    print(\"Next/Prev: Adjust current setting\")\n    clock.run()\n</code></pre> <p>Key concepts and features of this implementation:</p> <ol> <li>Button Handling</li> <li>Uses pull-up resistors (buttons connect to ground when pressed)</li> <li>Implements debouncing to prevent multiple triggers</li> <li> <p>Buttons are active-low (0 when pressed, 1 when released)</p> </li> <li> <p>Mode System</p> </li> <li>RUNNING: Normal clock operation</li> <li>SET_HOUR: Adjust hours (1-12)</li> <li>SET_MINUTE: Adjust minutes (0-59)</li> <li> <p>SET_AMPM: Toggle between AM and PM</p> </li> <li> <p>Visual Feedback</p> </li> <li>Selected component flashes when being set</li> <li>Colon blinks in running mode</li> <li> <p>Special AM/PM display during setting</p> </li> <li> <p>Time Management</p> </li> <li>Maintains time in 12-hour format internally</li> <li>Converts to/from 24-hour format for RTC</li> <li> <p>Handles midnight/noon edge cases</p> </li> <li> <p>State Management</p> </li> <li>Uses a class to organize state and behavior</li> <li>Separates display, button handling, and time management</li> </ol> <p>Common challenges students might encounter:</p> <ol> <li>Button Debouncing</li> <li>Understanding why debouncing is necessary</li> <li> <p>Adjusting debounce timing for reliable operation</p> </li> <li> <p>Time Format Conversion</p> </li> <li>Converting between 12/24 hour formats</li> <li> <p>Handling edge cases (12 AM/PM)</p> </li> <li> <p>Display Updates</p> </li> <li>Managing display refresh rate</li> <li>Creating smooth visual feedback</li> </ol> <p>Suggested exercises for students:</p> <ol> <li>Add a temperature display mode</li> <li>Implement a brightness adjustment feature</li> <li>Add an alarm setting mode</li> <li>Save settings to flash memory</li> <li>Add a battery backup indicator</li> </ol> <p>Would you like me to explain any part in more detail or provide examples of these extensions?</p>"},{"location":"kits/tm1637/running-clock/","title":"Full Running Clock Using the TM1637","text":"<p>I'll create a detailed example of a running clock using the TM1637 display. This builds on some of the concepts shown in the clock-driver.py file you shared, but simplified for the TM1637.</p> <pre><code>import tm1637\nfrom machine import Pin, RTC\nfrom utime import sleep, localtime\n\n# Initialize the display\ntm = tm1637.TM1637(clk=Pin(0), dio=Pin(1))\n\n# Initialize the RTC (Real Time Clock)\nrtc = RTC()\n\ndef set_initial_time():\n    \"\"\"\n    Set an initial time if RTC isn't configured.\n    In a real project, you'd sync this with a time server or user input.\n    \"\"\"\n    # Format: (year, month, day, weekday, hours, minutes, seconds, subseconds)\n    rtc.datetime((2024, 12, 28, 5, 12, 0, 0, 0))\n\ndef format_time(hours, minutes):\n    \"\"\"\n    Convert 24-hour time to 12-hour format\n    Returns hours and whether it's PM\n    \"\"\"\n    is_pm = hours &gt;= 12\n    if hours &gt; 12:\n        hours -= 12\n    elif hours == 0:\n        hours = 12\n    return hours, is_pm\n\ndef run_clock():\n    # Set initial brightness (0-7)\n    tm.brightness(2)\n\n    # Track colon state for blinking\n    colon_on = True\n\n    while True:\n        # Get current time from RTC\n        year, month, day, weekday, hours, minutes, seconds, _ = rtc.datetime()\n\n        # Convert to 12-hour format\n        display_hours, is_pm = format_time(hours, minutes)\n\n        # Toggle colon every second\n        if seconds != prev_seconds:\n            colon_on = not colon_on\n            prev_seconds = seconds\n\n        # Display the time\n        tm.numbers(display_hours, minutes, colon=colon_on)\n\n        # Brief pause to prevent display flicker\n        sleep(0.1)\n\nif __name__ == '__main__':\n    set_initial_time()  # Only needed if RTC isn't set\n    print(\"Starting clock...\")\n    run_clock()\n</code></pre>"},{"location":"kits/tm1637/running-clock/#core-concepts","title":"Core Concepts","text":"<p>Let's break down the key concepts students need to understand:</p>"},{"location":"kits/tm1637/running-clock/#1-real-time-clock-rtc","title":"1. Real-Time Clock (RTC)","text":"<ul> <li>The RTC is a hardware component that keeps track of time</li> <li>It continues running even when the microcontroller is reset</li> <li>Time is stored as a tuple: (year, month, day, weekday, hours, minutes, seconds, subseconds)</li> <li>Students should understand why RTCs are important for accurate timekeeping</li> </ul>"},{"location":"kits/tm1637/running-clock/#2-time-formats","title":"2. Time Formats","text":"<ul> <li>24-hour vs 12-hour time conversion</li> <li>Why we need to handle special cases (midnight = 0 hours \u2192 12, noon = 12 stays 12)</li> <li>The concept of AM/PM</li> </ul>"},{"location":"kits/tm1637/running-clock/#3-display-multiplexing","title":"3. Display Multiplexing","text":"<ul> <li>How LED displays show multiple digits (though the TM1637 handles this internally)</li> <li>Why we need a brief sleep to prevent display flicker</li> <li>How brightness control works with PWM (Pulse Width Modulation)</li> </ul>"},{"location":"kits/tm1637/running-clock/#4-state-management","title":"4. State Management","text":"<ul> <li>Tracking the colon state for blinking</li> <li>Maintaining previous second value to detect changes</li> <li>Why we use global variables in this context</li> </ul>"},{"location":"kits/tm1637/running-clock/#5-program-structure","title":"5. Program Structure","text":"<ul> <li>Main loop design</li> <li>Function organization</li> <li>Error handling (not shown but important in real applications)</li> </ul>"},{"location":"kits/tm1637/running-clock/#common-challenges","title":"Common challenges","text":"<p>Here are some challenges students might encounter:</p>"},{"location":"kits/tm1637/running-clock/#1-time-drift","title":"1. Time Drift","text":"<ul> <li>The RTC might drift slightly over time</li> <li>In real applications, you'd want to sync with an NTP server periodically</li> </ul>"},{"location":"kits/tm1637/running-clock/#2-power-management","title":"2. Power Management","text":"<ul> <li>Display brightness affects power consumption</li> <li>Consider dimming display in low light conditions</li> <li>Think about battery life in portable applications</li> </ul>"},{"location":"kits/tm1637/running-clock/#3-user-interface","title":"3. User Interface","text":"<ul> <li>Adding buttons to set the time</li> <li>Handling time zone changes</li> <li>Adding features like alarms or timers</li> </ul>"},{"location":"kits/tm1637/running-clock/#extensions","title":"Extensions","text":"<p>Here are some additional projects that students could try:</p> <ol> <li>Add a temperature display that alternates with the time</li> <li>Implement automatic brightness control using a light sensor</li> <li>Add alarm functionality with a buzzer</li> <li>Create a menu system for setting the time</li> <li>Add a battery backup system</li> </ol> <p>For reference, this code builds on the concepts shown in our <code>clock-driver.py</code> file, but simplifies the implementation thanks to the TM1637's built-in controller. </p>"},{"location":"kits/waveshare-e-paper/","title":"Waveshare E-Paper Display","text":"<p>Black 1.54 inch e-Paper/e-Ink Display Module 152x152 for Arduino,Raspberry Pi</p> <p>1.54inch e-Paper Module (C)</p> <p>Data Sheet</p> <p>BuyDisplay</p>"},{"location":"kits/waveshare-e-paper/#description","title":"Description","text":"<p>ER-EPM0154-1B is e-paper/e-ink display module that is 1.54 inch e-paper display panel attached with a breakout board, 152x152 resolution with white/black color, UC8151C controller,running both 3.3V and 5V power supply,super wide viewing angle,sunlight readable and easily controlled by MCU such as PIC, AVR, ARDUINO,ARM and Raspberry PI. One fantastic aspect of the ePaper display is the fact they don't need any power to keep the image on the screen. Just like a Kindle, you can read whatever is on your screen in daylight without any reflection.  It's optional for 3-wire or 4-wire serial interface. </p> <p>We prepared the library and examples for arduino due,mega 2560,uno,nano and for raspberry pi or raspberry pi zero.</p>"},{"location":"kits/waveshare-e-paper/#waveshare-micropython-driver","title":"Waveshare MicroPython Driver","text":"<ul> <li>Waveshare MicroPython Driver</li> </ul> <p>The device I purchased is 152x152.</p>"},{"location":"kits/waveshare-e-paper/#connections","title":"Connections","text":"Pin Name Description 1 VDD Power Supply (square) 2 VSS Ground (round) 3 SDA Serial Data Pin Input/Output (SPI) 4 SCL Serial Clock Pin Input (SPI) 5 /CS Chip Select Input Pin 6 D/C Data /Command Control Pin 7 /RST Reset Input. Low: Reset. 8 BUSY Busy State Output Pin <pre><code>from machine import Pin\nimport epd1in54b\n\nmosi = Pin(0)\nclk = Pin(1)\nreset = Pin(2)\ndc = Pin(3)\nbusy = Pin(4)\ncs = Pin(5)\n\nepd = epd1in54b.EPD(reset, dc, busy, cs, clk, mosi)\nepd.init()\n\n# initialize the frame buffer\nfb_size = int(epd.width * epd.height / 8)\nframe_black = bytearray(fb_size)\n\nepd.clear_frame(frame_black, frame_red)\n\n# For simplicity, the arguments are explicit numerical coordinates\nepd.draw_rectangle(frame_black, 10, 60, 50, 110, epd1in54b.COLORED)\nepd.draw_line(frame_black, 10, 60, 50, 110, epd1in54b.COLORED)\nepd.draw_line(frame_black, 50, 60, 10, 110, epd1in54b.COLORED)\nepd.draw_circle(frame_black, 120, 80, 30, epd1in54b.COLORED)\n\nepd.display_frame(frame_black)\n</code></pre>"},{"location":"kits/waveshare-lcd/","title":"Waveshare RP2040","text":"<p>The Waveshare RP2040 1.28\" IPS LCD Board is a wonderful developent board with a build in RP2040 processor that currently sells for about $18.  The board has a USB-C connector, a place for a LiPo battery connection and built in Accelerometer &amp; Gyroscope.  It is a great value and a wonderful way to start to learn Python for smart watches!</p> <ol> <li>Waveshare SKU: 22668</li> <li>Waveshare Part Number: RP2040-LCD-1.28</li> <li>Link to Waveshare site</li> </ol> <p>Note that this watch does not have a real-time clock and has no ability to connect to time syhronization using WiFi. However, it is an ideal development tool for learning to program watch displays and integrate sensors.</p>"},{"location":"kits/waveshare-lcd/#micropython-version","title":"MicroPython Version","text":"<p>To use these lessions you much use MicroPython runtime v1.19.1-854-g35524a6fd released on 2023-02-07 or later. This version supports all the native framebuf drawing libraries (ellipse and polygon)</p> <p>See the documentation here: MicroPython Framebuffer Functions</p>"},{"location":"kits/waveshare-lcd/#lessons","title":"Lessons","text":"<ol> <li>Hello world! Lesson</li> <li>Color Lab</li> <li>Drawing Analog Hands</li> <li>5x8 Fonts</li> </ol>"},{"location":"kits/waveshare-lcd/#detailed-components","title":"Detailed Components","text":"Component Description USB Type-C connector USB 1.1 with device and host support ETA6096 high efficiency Lithium battery recharge manager Battery Header MX1.25 header, for 3.7V Lithium battery, allows recharging the battery and powering the board at the same time QMI8658C IMU, includes a 3-axis gyroscope and a 3-axis accelerometer 1.27mm pitch headers Adapting all GPIO and Debug pins W25Q16JVUXIQ 2MB NOR-Flash RP2040 Dual-core processor, up to 133MHz operating frequency RESET Button Reset the processor BOOT Button press it when resetting to enter download mode"},{"location":"kits/waveshare-lcd/#references","title":"References","text":"<p>wiki</p> <p>Instructable by Tony Goodhew - note that this  version does not leverage the built-in drawing libraries that were made available in version 19 of the MicroPython release. See The MicroPython FrameBuf Library</p> <p>Github Gist by Alasdair Allan</p>"},{"location":"kits/waveshare-lcd/01-hello-world/","title":"Waveshare Hello World","text":""},{"location":"kits/waveshare-lcd/01-hello-world/#step-1-load-the-library","title":"Step 1: Load the Library","text":""},{"location":"kits/waveshare-lcd/01-hello-world/#step-2-load-a-test-program","title":"Step 2: Load a Test Program","text":"<pre><code>from LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \nLCD.set_bl_pwm(65535)\n\nLCD.fill(LCD.black)    \nLCD.text(\"Hello world!\", 50, 100, LCD.white)\nLCD.show()\n</code></pre> <p>You should see \"Hello world!\" in a small white font near the center of the screen.</p> <p>Challenges</p> <ol> <li>Can you move the text around the screen by changing the x and y starting position of the text?</li> <li>Can you change the background fill from black to another color?</li> <li>Can you change the color of the text from white to be another color?</li> <li>Can you change the font size? (hint: this is not easy!)</li> </ol>"},{"location":"kits/waveshare-lcd/02-color-test/","title":"Color Tests","text":"<p>Now let's try to make the background screen change colors:</p> <pre><code>from LCD_1inch28 import LCD_1inch28\nfrom utime import sleep\n\nLCD = LCD_1inch28()  \nLCD.set_bl_pwm(65535)\n\nLCD.fill(LCD.black)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.white)\nsleep(1)\nLCD.show()\nLCD.fill(LCD.red)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.green)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.blue)\nLCD.show()\nprint('done')\n</code></pre> <p>What happens when you change the color \"red\" to be \"orange\"?  You shouild see:</p> <pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 10, in &lt;module&gt;\nAttributeError: 'LCD_1inch28' object has no attribute 'orange'\n</code></pre> <p>This shows you that although the driver knows about some basic colors, (black, white, red, green and blue), it has no understanding of other colors.</p> <p>To draw these colors we need to add our own color lists.</p>"},{"location":"kits/waveshare-lcd/02-color-test/#custom-color-lists","title":"Custom Color Lists","text":"<p>In order to get more nuanced colors, we need to define them using the binary of their red, green and blue values.  With this display, we order the bits, blue, red and green.</p> <p>We can use the following binary notation to represent the colors:</p> <pre><code># binary representations of colors B=Blue bits, R=Red bits, G=Green bits\n# color = 0bBBBBBRRRRRGGGGGG\n# Cyan has all the blue and green bits on and the red bits off\ncyan = cyan = 0b1111100000111111\n</code></pre> <pre><code>from machine import Pin,I2C,SPI,PWM,ADC\nfrom time import sleep\nfrom LCD_1inch28 import LCD_1inch28, QMI8658\n\nCENTER = 120\nLCD = LCD_1inch28()\nLCD.set_bl_pwm(65535)\n\n# draw readability\nON = 1\nOFF = 0\nNO_FILL = 0\nFILL = 1\n# hex representation of colors\n# note that the bit order is blue, red, green\nblack = 0x0000\nred   = 0x07E0\ngreen = 0x001f\nblue  = 0xf800\nwhite = 0xffff\n\n# binary representations of colors\n# binary representations of colors B=5 Blue bits, R=5 Red bits, G=6 green bits\n# color = 0bBBBBBRRRRRGGGGGG\nyellow = 0b0000011111111111\norange = 0b0000001111000010\ncyan = 0b1111100000111111\nbrown = 0b0000000001000001\ngold = 0b0000001110011110\npurple = 0b1111111111000000\nmagenta = 0b0000001100011000\npink = 0b0000111111000010\nolive = 0b0000000001000010\ngray = 0b00001000010000100\nlightGreen = 0b0000100001111111\ndarkGreen  = 0b0000000000000001\n\nColorList =  (red,    green,   blue,   white,   yellow,  orange,\n              cyan, brown, gold, purple, magenta, pink, olive, gray, lightGreen, darkGreen)\nColorNames = ('red', 'green', 'blue', 'white', 'yellow', 'orange',\n              'cyan', 'brown', 'gold', 'purple', 'magenta', 'pink', 'olive', 'gray', 'lightGreen', 'darkGreen')\n\nradius = 120\nLCD.fill(LCD.black)\n\nfor i in range(0, len(ColorList)):\n    print(ColorNames[i])\n    # LCD.ellipse(CENTER, CENTER, radius, radius, ColorList[i], FILL)\n    LCD.fill(ColorList[i])\n    LCD.text(ColorNames[i], 100, 100, 1)\n    LCD.text(ColorNames[i], 100, 120, white)\n    LCD.show()\n    sleep(1)\n</code></pre> <p>Note that we are using the fill function to draw on all the pixels on the screen. We could have used the ellipse funtion to draw into the frame buffer, but the fill function is a bit easier.</p>"},{"location":"kits/waveshare-lcd/02-color-test/#converting-rgb888-to-brg556","title":"Converting RGB888 to BRG556","text":"<pre><code>def convert_color_RGB888_RGB565(R,G,B): # Convert RGB888 to RGB565\n    return (((G&amp;0b00011100)&lt;&lt;3) +((B&amp;0b11111000)&gt;&gt;3)&lt;&lt;8) + (R&amp;0b11111000)+((G&amp;0b11100000)&gt;&gt;5)\n</code></pre>"},{"location":"kits/waveshare-lcd/02-display-text/","title":"Display Time and Date in Text","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {} {}, {}\".format(day_name, month_name, now[2], now[0])\n\nwhile(True):\n    now = localtime()\n    # print(now)\n    LCD.fill(LCD.black)    \n    LCD.text(format_time(now), 77, 50, LCD.white)\n    LCD.text(format_date(now), 40, 80, LCD.white)\n    LCD.show()\n    sleep(1)\n</code></pre>"},{"location":"kits/waveshare-lcd/03-drawing-hands/","title":"Drawing Analog Hands","text":"<p>Drawing a analog hand requirs drawing a line from the center of the screen to a point on the edge of the circle.  The point positon varies periodically, just like the sine and cosine functions vary.  We can demonstrate this will a counter that goes from 0 to 360 degrees.</p> <p>Consider the following:</p> <ol> <li>Since the sine(0) = 0 we can use that function for the displacement from the center on the x-axis.</li> <li>Since the cosine(0) = 1, we can use that as the negative Y displacement from the center.  Remember in drawing pixels, (0,0) is in the upper-left corner of the screen.</li> </ol> <p>There is one other bit of math we need to review.  The sine() and cosine() function take in a number called <code>radians</code> which is usually a number between 0 and two times Pi.  They then return a value between 0 and 1.  We need multiple both of these values by the length of the watch hand to get to the right part of the watch face.</p> <pre><code>from utime import sleep\nfrom LCD_1inch28 import LCD_1inch28\nimport math\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nHAND_LENGTH = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nwhile True:\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    print(radians, x, y)\n    LCD.fill(LCD.black)\n    LCD.line(CENTER, CENTER, CENTER+x,CENTER+y, LCD.white)\n    LCD.show()\n    sleep(1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre> <p>You should now see a narrow white line moving much like a second hand on a watch!</p>"},{"location":"kits/waveshare-lcd/03-drawing-hands/#adding-bling-to-your-hands","title":"Adding bling to your hands","text":"<p>Although drawing a single white line is a clean efficent design, many people like to add other features such as an arrow head at the tip of the hand.  To do this we can use the poly function to draw the arrow.  To get this right, we also need to orient the arrow in the right direction.</p>"},{"location":"kits/waveshare-lcd/03-drawing-hands/#drawing-a-triangle","title":"Drawing a Triangle","text":"<p>We can use the MicroPython standard poly function to draw a triangle.  The poly </p> <p><code>`FrameBuffer.poly(x, y, coords, c[, f])</code></p> <p>This will draw an arbitrary polygon at the given x, y location using the given color (c).</p> <p>The coords must be specified as a array of integers, e.g. array('h', [x0, y0, x1, y1, ... xn, yn]).</p> <p>The optional f parameter can be set to True to fill the polygon. Otherwise just a one pixel outline is drawn.</p> <p>Let's start with drawing a basic triangle in the center of the screen like this:</p> <p>LCD.</p> <pre><code># draw a triangle on a blue background\nfrom utime import sleep\nfrom LCD_1inch28 import LCD_1inch28\nimport math\nfrom array import array\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n# draw a blue background\nLCD.fill(LCD.blue)\n\n# distance from the center to the tip of the traiangle\nd = 50\nmy_array = array('B', [CENTER-d,CENTER+d, CENTER,CENTER-d, CENTER+d,CENTER+d])\nLCD.poly(0,0, my_array, LCD.white, FILL)\nLCD.show()\nprint('done')\n</code></pre>"},{"location":"kits/waveshare-lcd/03-drawing-hands/#drawing-a-triangle-rotating","title":"Drawing a Triangle Rotating","text":"<p>Now we will modify the draw triangle program to rotate each of the three points. We do this by passing the CENTER and either a positve or negative value of the x and y which varies as we move around the circle.</p> <p>Here is the line that is the most difficult to understand:</p> <pre><code>my_array = array('B', [CENTER-x,CENTER-y, CENTER+y,CENTER-x, CENTER+x,CENTER+y])\n</code></pre> <p>Note that the first point is in the lower left corner:</p> <pre><code>(CENTER-x, CENTER-y)\n</code></pre> <p>The second point is at the top of the trainagle and the X is initially zero (sine(0) = y)</p> <pre><code>(CENTER+y, CENTER-x)\n</code></pre> <p>The third point is to the lower right where we need to add to both the X and Y:</p> <pre><code>(CENTER+x, CENTER-y)\n</code></pre> <p>Here is the full program:</p> <pre><code># draw rotating triangle\nfrom utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\nfrom array import array\nimport math\nTWO_PI = 3.145175*2\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n\n# distance from the center to the tip of the traiangle\nd = 50\n\ncounter = 0\nwhile True:\n    LCD.fill(LCD.blue)\n    radians = (counter/60)*TWO_PI\n    x = int(math.cos(radians)*d)\n    y = int(math.sin(radians)*d)\n\n    # the three points of the triangle are rotated in a circle\n    my_array = array('B', [CENTER-x,CENTER-y, CENTER+y,CENTER-x, CENTER+x,CENTER+y])\n    print(CENTER-x, CENTER+y)\n\n    LCD.poly(0,0, my_array, LCD.white, FILL)\n    LCD.show()\n    sleep(.1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre> <p>You might have to stare at the code and the drawing for a while to get this figured out.</p>"},{"location":"kits/waveshare-lcd/03-drawing-hands/#create-a-draw-triangle-function","title":"Create a Draw Triangle Function","text":"<p>Now we are ready to package our triangle drawing experiment into a single function to make it easier to use.  We will pass in four parameters:</p> <ol> <li>The center of the triangle's X and Y coordinates</li> <li>The size of the triangle measured from the center to the tip</li> <li>The number of seconds on the clock (0 to 59) which we will convert to radians.  This becomes the agle of the triangle.</li> </ol> <pre><code>def drawTriangle(x, y, size, seconds):\n    radians = (seconds/60)*TWO_PI\n    # calculate the offsets\n    xo = int(math.cos(radians)*size)\n    yo = int(math.sin(radians)*size)\n    # build the array - use B if we have under 255 and h if over 255\n    arr = array('B', [x-xo,y-yo,  x+yo,y-xo,  x+xo,y+yo])\n    LCD.poly(0,0, arr, LCD.white, FILL)\n</code></pre>"},{"location":"kits/waveshare-lcd/03-drawing-hands/#full-program","title":"Full Program","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\nfrom array import array\nimport math\nTWO_PI = 3.145175*2\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\nHAND_LENGTH = 100\nTRIANGLE_SIZE = 10\n\ndef drawTriangle(x, y, size, seconds):\n    radians = (seconds/60)*TWO_PI\n    # calculate the offsets\n    xo = int(math.cos(radians)*size)\n    yo = int(math.sin(radians)*size)\n    # build the array - use B if we have under 255 and h if over 255\n    arr = array('B', [x-xo,y-yo,  x+yo,y-xo,  x+xo,y+yo])\n    LCD.poly(0,0, arr, LCD.white, FILL)\n\ncounter = 0\nwhile True:\n    LCD.fill(LCD.blue)\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    LCD.line(CENTER, CENTER, CENTER+x,CENTER+y, LCD.white)\n    drawTriangle(CENTER+x, CENTER+y, TRIANGLE_SIZE, counter)\n    LCD.show()\n    sleep(.1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0```\n</code></pre>"},{"location":"kits/waveshare-lcd/03-drawing-hands/#drawing-x-and-y-axis","title":"Drawing X and Y Axis","text":"<pre><code># draw thin blue axis lines through the center\n# vertical line\nLCD.line(CENTER, 0, CENTER, 2*CENTER, blue)\n# horizontal line\nLCD.line(0, CENTER, 2*CENTER, CENTER, blue)\n</code></pre>"},{"location":"kits/waveshare-lcd/04-5x8-font/","title":"5x8 Font Test","text":"<p>We can create custom functions for drawing larger fonts.  Here we have a byte array of 5X8 fonts.  The function <code>character()</code> draws individual characters one at a time.</p> <pre><code>from LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\n# Standard ASCII 5x8 font\n# https://gist.github.com/tdicola/229b3eeddc12d58fb0bc724a9062aa05\nFONT_HEIGHT = 8\nFONT_WIDTH = 5\nFONT = bytes([\n    0x00, 0x00, 0x00, 0x00, 0x00, # &lt;space&gt;\n    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,\n    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,\n    0x1C, 0x3E, 0x7C, 0x3E, 0x1C,\n    0x18, 0x3C, 0x7E, 0x3C, 0x18,\n    0x1C, 0x57, 0x7D, 0x57, 0x1C,\n    0x1C, 0x5E, 0x7F, 0x5E, 0x1C,\n    0x00, 0x18, 0x3C, 0x18, 0x00,\n    0xFF, 0xE7, 0xC3, 0xE7, 0xFF,\n    0x00, 0x18, 0x24, 0x18, 0x00,\n    0xFF, 0xE7, 0xDB, 0xE7, 0xFF,\n    0x30, 0x48, 0x3A, 0x06, 0x0E,\n    0x26, 0x29, 0x79, 0x29, 0x26,\n    0x40, 0x7F, 0x05, 0x05, 0x07,\n    0x40, 0x7F, 0x05, 0x25, 0x3F,\n    0x5A, 0x3C, 0xE7, 0x3C, 0x5A,\n    0x7F, 0x3E, 0x1C, 0x1C, 0x08,\n    0x08, 0x1C, 0x1C, 0x3E, 0x7F,\n    0x14, 0x22, 0x7F, 0x22, 0x14,\n    0x5F, 0x5F, 0x00, 0x5F, 0x5F,\n    0x06, 0x09, 0x7F, 0x01, 0x7F,\n    0x00, 0x66, 0x89, 0x95, 0x6A,\n    0x60, 0x60, 0x60, 0x60, 0x60,\n    0x94, 0xA2, 0xFF, 0xA2, 0x94,\n    0x08, 0x04, 0x7E, 0x04, 0x08, # UP\n    0x10, 0x20, 0x7E, 0x20, 0x10, # Down\n    0x08, 0x08, 0x2A, 0x1C, 0x08, # Right\n    0x08, 0x1C, 0x2A, 0x08, 0x08, # Left\n    0x1E, 0x10, 0x10, 0x10, 0x10,\n    0x0C, 0x1E, 0x0C, 0x1E, 0x0C,\n    0x30, 0x38, 0x3E, 0x38, 0x30,\n    0x06, 0x0E, 0x3E, 0x0E, 0x06,\n    0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x5F, 0x00, 0x00,\n    0x00, 0x07, 0x00, 0x07, 0x00,\n    0x14, 0x7F, 0x14, 0x7F, 0x14,\n    0x24, 0x2A, 0x7F, 0x2A, 0x12,\n    0x23, 0x13, 0x08, 0x64, 0x62,\n    0x36, 0x49, 0x56, 0x20, 0x50,\n    0x00, 0x08, 0x07, 0x03, 0x00,\n    0x00, 0x1C, 0x22, 0x41, 0x00,\n    0x00, 0x41, 0x22, 0x1C, 0x00,\n    0x2A, 0x1C, 0x7F, 0x1C, 0x2A,\n    0x08, 0x08, 0x3E, 0x08, 0x08,\n    0x00, 0x80, 0x70, 0x30, 0x00,\n    0x08, 0x08, 0x08, 0x08, 0x08,\n    0x00, 0x00, 0x60, 0x60, 0x00,\n    0x20, 0x10, 0x08, 0x04, 0x02,\n    0x3E, 0x51, 0x49, 0x45, 0x3E,\n    0x00, 0x42, 0x7F, 0x40, 0x00,\n    0x72, 0x49, 0x49, 0x49, 0x46,\n    0x21, 0x41, 0x49, 0x4D, 0x33,\n    0x18, 0x14, 0x12, 0x7F, 0x10,\n    0x27, 0x45, 0x45, 0x45, 0x39,\n    0x3C, 0x4A, 0x49, 0x49, 0x31,\n    0x41, 0x21, 0x11, 0x09, 0x07,\n    0x36, 0x49, 0x49, 0x49, 0x36,\n    0x46, 0x49, 0x49, 0x29, 0x1E,\n    0x00, 0x00, 0x14, 0x00, 0x00,\n    0x00, 0x40, 0x34, 0x00, 0x00,\n    0x00, 0x08, 0x14, 0x22, 0x41,\n    0x14, 0x14, 0x14, 0x14, 0x14,\n    0x00, 0x41, 0x22, 0x14, 0x08,\n    0x02, 0x01, 0x59, 0x09, 0x06,\n    0x3E, 0x41, 0x5D, 0x59, 0x4E,\n    0x7C, 0x12, 0x11, 0x12, 0x7C, # A\n    0x7F, 0x49, 0x49, 0x49, 0x36,\n    0x3E, 0x41, 0x41, 0x41, 0x22,\n    0x7F, 0x41, 0x41, 0x41, 0x3E,\n    0x7F, 0x49, 0x49, 0x49, 0x41,\n    0x7F, 0x09, 0x09, 0x09, 0x01,\n    0x3E, 0x41, 0x41, 0x51, 0x73,\n    0x7F, 0x08, 0x08, 0x08, 0x7F,\n    0x00, 0x41, 0x7F, 0x41, 0x00,\n    0x20, 0x40, 0x41, 0x3F, 0x01,\n    0x7F, 0x08, 0x14, 0x22, 0x41,\n    0x7F, 0x40, 0x40, 0x40, 0x40,\n    0x7F, 0x02, 0x1C, 0x02, 0x7F,\n    0x7F, 0x04, 0x08, 0x10, 0x7F,\n    0x3E, 0x41, 0x41, 0x41, 0x3E,\n    0x7F, 0x09, 0x09, 0x09, 0x06,\n    0x3E, 0x41, 0x51, 0x21, 0x5E,\n    0x7F, 0x09, 0x19, 0x29, 0x46,\n    0x26, 0x49, 0x49, 0x49, 0x32,\n    0x03, 0x01, 0x7F, 0x01, 0x03,\n    0x3F, 0x40, 0x40, 0x40, 0x3F,\n    0x1F, 0x20, 0x40, 0x20, 0x1F,\n    0x3F, 0x40, 0x38, 0x40, 0x3F,\n    0x63, 0x14, 0x08, 0x14, 0x63,\n    0x03, 0x04, 0x78, 0x04, 0x03,\n    0x61, 0x59, 0x49, 0x4D, 0x43,\n    0x00, 0x7F, 0x41, 0x41, 0x41,\n    0x02, 0x04, 0x08, 0x10, 0x20,\n    0x00, 0x41, 0x41, 0x41, 0x7F,\n    0x04, 0x02, 0x01, 0x02, 0x04,\n    0x40, 0x40, 0x40, 0x40, 0x40,\n    0x00, 0x03, 0x07, 0x08, 0x00,\n    0x20, 0x54, 0x54, 0x78, 0x40,\n    0x7F, 0x28, 0x44, 0x44, 0x38,\n    0x38, 0x44, 0x44, 0x44, 0x28,\n    0x38, 0x44, 0x44, 0x28, 0x7F,\n    0x38, 0x54, 0x54, 0x54, 0x18,\n    0x00, 0x08, 0x7E, 0x09, 0x02,\n    0x18, 0xA4, 0xA4, 0x9C, 0x78,\n    0x7F, 0x08, 0x04, 0x04, 0x78,\n    0x00, 0x44, 0x7D, 0x40, 0x00,\n    0x20, 0x40, 0x40, 0x3D, 0x00,\n    0x7F, 0x10, 0x28, 0x44, 0x00,\n    0x00, 0x41, 0x7F, 0x40, 0x00,\n    0x7C, 0x04, 0x78, 0x04, 0x78,\n    0x7C, 0x08, 0x04, 0x04, 0x78,\n    0x38, 0x44, 0x44, 0x44, 0x38,\n    0xFC, 0x18, 0x24, 0x24, 0x18,\n    0x18, 0x24, 0x24, 0x18, 0xFC,\n    0x7C, 0x08, 0x04, 0x04, 0x08,\n    0x48, 0x54, 0x54, 0x54, 0x24,\n    0x04, 0x04, 0x3F, 0x44, 0x24,\n    0x3C, 0x40, 0x40, 0x20, 0x7C,\n    0x1C, 0x20, 0x40, 0x20, 0x1C,\n    0x3C, 0x40, 0x30, 0x40, 0x3C,\n    0x44, 0x28, 0x10, 0x28, 0x44,\n    0x4C, 0x90, 0x90, 0x90, 0x7C,\n    0x44, 0x64, 0x54, 0x4C, 0x44,\n    0x00, 0x08, 0x36, 0x41, 0x00,\n    0x00, 0x00, 0x77, 0x00, 0x00,\n    0x00, 0x41, 0x36, 0x08, 0x00,\n    0x02, 0x01, 0x02, 0x04, 0x02,\n    0x3C, 0x26, 0x23, 0x26, 0x3C,\n    0x1E, 0xA1, 0xA1, 0x61, 0x12, # Extension starts here\n    0x3A, 0x40, 0x40, 0x20, 0x7A,\n    0x38, 0x54, 0x54, 0x55, 0x59,\n    0x21, 0x55, 0x55, 0x79, 0x41,\n    0x22, 0x54, 0x54, 0x78, 0x42, # a-umlaut\n    0x21, 0x55, 0x54, 0x78, 0x40,\n    0x20, 0x54, 0x55, 0x79, 0x40,\n    0x0C, 0x1E, 0x52, 0x72, 0x12,\n    0x39, 0x55, 0x55, 0x55, 0x59,\n    0x39, 0x54, 0x54, 0x54, 0x59,\n    0x39, 0x55, 0x54, 0x54, 0x58,\n    0x00, 0x00, 0x45, 0x7C, 0x41,\n    0x00, 0x02, 0x45, 0x7D, 0x42,\n    0x00, 0x01, 0x45, 0x7C, 0x40,\n    0x7D, 0x12, 0x11, 0x12, 0x7D, # A-umlaut\n    0xF0, 0x28, 0x25, 0x28, 0xF0,\n    0x7C, 0x54, 0x55, 0x45, 0x00,\n    0x20, 0x54, 0x54, 0x7C, 0x54,\n    0x7C, 0x0A, 0x09, 0x7F, 0x49,\n    0x32, 0x49, 0x49, 0x49, 0x32,\n    0x3A, 0x44, 0x44, 0x44, 0x3A, # o-umlaut\n    0x32, 0x4A, 0x48, 0x48, 0x30,\n    0x3A, 0x41, 0x41, 0x21, 0x7A,\n    0x3A, 0x42, 0x40, 0x20, 0x78,\n    0x00, 0x9D, 0xA0, 0xA0, 0x7D,\n    0x3D, 0x42, 0x42, 0x42, 0x3D, # O-umlaut\n    0x3D, 0x40, 0x40, 0x40, 0x3D,\n    0x3C, 0x24, 0xFF, 0x24, 0x24,\n    0x48, 0x7E, 0x49, 0x43, 0x66,\n    0x2B, 0x2F, 0xFC, 0x2F, 0x2B,\n    0xFF, 0x09, 0x29, 0xF6, 0x20,\n    0xC0, 0x88, 0x7E, 0x09, 0x03,\n    0x20, 0x54, 0x54, 0x79, 0x41,\n    0x00, 0x00, 0x44, 0x7D, 0x41,\n    0x30, 0x48, 0x48, 0x4A, 0x32,\n    0x38, 0x40, 0x40, 0x22, 0x7A,\n    0x00, 0x7A, 0x0A, 0x0A, 0x72,\n    0x7D, 0x0D, 0x19, 0x31, 0x7D,\n    0x26, 0x29, 0x29, 0x2F, 0x28,\n    0x26, 0x29, 0x29, 0x29, 0x26,\n    0x30, 0x48, 0x4D, 0x40, 0x20,\n    0x38, 0x08, 0x08, 0x08, 0x08,\n    0x08, 0x08, 0x08, 0x08, 0x38,\n    0x2F, 0x10, 0xC8, 0xAC, 0xBA,\n    0x2F, 0x10, 0x28, 0x34, 0xFA,\n    0x00, 0x00, 0x7B, 0x00, 0x00,\n    0x08, 0x14, 0x2A, 0x14, 0x22,\n    0x22, 0x14, 0x2A, 0x14, 0x08,\n    0x55, 0x00, 0x55, 0x00, 0x55, # 176 (25% block) missing in old code\n    0xAA, 0x55, 0xAA, 0x55, 0xAA, # 50% block\n    0xFF, 0x55, 0xFF, 0x55, 0xFF, # 75% block\n    0x00, 0x00, 0x00, 0xFF, 0x00,\n    0x10, 0x10, 0x10, 0xFF, 0x00,\n    0x14, 0x14, 0x14, 0xFF, 0x00,\n    0x10, 0x10, 0xFF, 0x00, 0xFF,\n    0x10, 0x10, 0xF0, 0x10, 0xF0,\n    0x14, 0x14, 0x14, 0xFC, 0x00,\n    0x14, 0x14, 0xF7, 0x00, 0xFF,\n    0x00, 0x00, 0xFF, 0x00, 0xFF,\n    0x14, 0x14, 0xF4, 0x04, 0xFC,\n    0x14, 0x14, 0x17, 0x10, 0x1F,\n    0x10, 0x10, 0x1F, 0x10, 0x1F,\n    0x14, 0x14, 0x14, 0x1F, 0x00,\n    0x10, 0x10, 0x10, 0xF0, 0x00,\n    0x00, 0x00, 0x00, 0x1F, 0x10,\n    0x10, 0x10, 0x10, 0x1F, 0x10,\n    0x10, 0x10, 0x10, 0xF0, 0x10,\n    0x00, 0x00, 0x00, 0xFF, 0x10,\n    0x10, 0x10, 0x10, 0x10, 0x10,\n    0x10, 0x10, 0x10, 0xFF, 0x10,\n    0x00, 0x00, 0x00, 0xFF, 0x14,\n    0x00, 0x00, 0xFF, 0x00, 0xFF,\n    0x00, 0x00, 0x1F, 0x10, 0x17,\n    0x00, 0x00, 0xFC, 0x04, 0xF4,\n    0x14, 0x14, 0x17, 0x10, 0x17,\n    0x14, 0x14, 0xF4, 0x04, 0xF4,\n    0x00, 0x00, 0xFF, 0x00, 0xF7,\n    0x14, 0x14, 0x14, 0x14, 0x14,\n    0x14, 0x14, 0xF7, 0x00, 0xF7,\n    0x14, 0x14, 0x14, 0x17, 0x14,\n    0x10, 0x10, 0x1F, 0x10, 0x1F,\n    0x14, 0x14, 0x14, 0xF4, 0x14,\n    0x10, 0x10, 0xF0, 0x10, 0xF0, # ok\n    0x00, 0x00, 0x1F, 0x10, 0x1F,\n    0x00, 0x00, 0x00, 0x1F, 0x14,\n#   0x00, 0x00, 0x00, 0xFC, 0x14, # any new after this line breaks\n    0x00, 0x00, 0x00, 0x00, 0x00  # 255 also a &lt;space&gt;\n])\n\ndef convert_color_RGB888_RGB565(R,G,B): # Convert RGB888 to RGB565\n    return (((G&amp;0b00011100)&lt;&lt;3) + ((B&amp;0b11111000)&gt;&gt;3)&lt;&lt;8) + (R&amp;0b11111000) + ((G&amp;0b11100000)&gt;&gt;5)\n\ndef character(asc, xt, yt, sz, r, g, b):  # Single character sz is size: 1 or 2\n    cc = convert_color_RGB888_RGB565(r,g,b)\n    code = asc * 5    # 5 bytes per character\n    for ii in range(5):\n        line = FONT[code + ii]\n        for yy in range(8):\n            if (line &gt;&gt; yy) &amp; 0x1:\n                LCD.pixel(ii*sz+xt,yy*sz+yt,cc) \n                if sz &gt; 1:\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt,cc)\n                    LCD.pixel(ii*sz+xt,yy*sz+yt+1,cc)\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt+1,cc)\n                if sz == 3:\n                    LCD.pixel(ii*sz+xt,  yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt+1,cc)\n\n# Print a string\ndef prnt_st(asci, xx, yy, sz,r,g,b):  # Text string\n    if sz == 1: move = 6\n    if sz == 2: move = 11\n    if sz == 3: move = 17 \n    for letter in(asci):\n        asci = ord(letter)\n        character(asci,xx,yy,sz,r,g,b)\n        xx = xx + move\n\n# Center text string\ndef cntr_st(s,y,sz,r,g,b): # Centres text on line y\n    if sz == 1: w = 6\n    if sz == 2: w = 11\n    if sz == 3: w = 17 \n    gap = int((width - len(s) * w)/2)\n    prnt_st(s,gap,y,sz,r,g,b)\n\nLCD.fill(LCD.black)    \nprnt_st(\"Hello world! Red\", 20, 80, 2, 255, 0, 0)\nprnt_st(\"Hello world! Green\", 20, 100, 2, 0, 255, 0)\nprnt_st(\"Hello world! Blue\", 20, 120, 2, 0, 0, 255)\nprnt_st(\"Hello world! White\", 20, 140, 2, 255, 255, 255)\nLCD.show()\n</code></pre>"},{"location":"lessons/","title":"Building Clocks and Watches with Smart Watch Displays","text":"<p>These lessons are general to all of our kits.  We often use the Pico OLED for many examples since that is the kit we have been using for the longest time.</p> <p>These lessons focus on using functions like the  MicroPython localtime() to get the time in your current timezone.</p> <p>They also focus on drawing scalable numbers on different size displays and drawing times on larger color displays.</p> <p>Here are some sample lesson plans for a 14-week semimester high school course on learning computational thining by using MicroPython to write clock and smartwatch application.  This course assumes no prior knowledge of programming.</p>"},{"location":"lessons/#weeks-1-2-introduction-to-python-and-basic-concepts","title":"Weeks 1-2: Introduction to Python and Basic Concepts","text":""},{"location":"lessons/#lesson-1-introduction-to-python","title":"Lesson 1: Introduction to Python","text":"<ul> <li>What is Python?</li> <li>Why learn Python?</li> <li>Data Science</li> <li>Artificial Intelligence</li> <li>Python Installation and Setup</li> </ul>"},{"location":"lessons/#lesson-2-hello-world","title":"Lesson 2: Hello, World!","text":"<ul> <li>Writing the first Python program</li> <li>Drawing a simple rectangle to the screen</li> <li>Making the rectangle bounce around the screen</li> <li>Understanding Python syntax</li> <li>Using the graphics library for your clock or watch</li> </ul>"},{"location":"lessons/#lesson-3-variables-and-data-types","title":"Lesson 3: Variables and Data Types","text":"<ul> <li>Introduction to variables</li> <li>Common data types (integers, floats, strings, booleans)</li> <li>Drawing with pixels, lines and rectangles</li> <li>Changing color</li> </ul>"},{"location":"lessons/#lesson-4-basic-operations","title":"Lesson 4: Basic Operations","text":"<ul> <li>Arithmetic operations</li> <li>Concatenation and repetition</li> <li>Assignment operators</li> <li>Lists of colors</li> </ul>"},{"location":"lessons/#weeks-3-4-control-structures-and-functions","title":"Weeks 3-4: Control Structures and Functions","text":""},{"location":"lessons/#lesson-5-conditionals","title":"Lesson 5: Conditionals","text":"<ul> <li><code>if</code>, <code>else</code>, and <code>elif</code> statements</li> <li>Alternating the color of your lines</li> <li>Horizontal and radial lines</li> </ul>"},{"location":"lessons/#lesson-6-loops","title":"Lesson 6: Loops","text":"<ul> <li><code>for</code> and <code>while</code> loops</li> <li>Loop control with <code>break</code> and <code>continue</code></li> <li>Draing the tick marks on a watch</li> </ul>"},{"location":"lessons/#lesson-7-functions","title":"Lesson 7: Functions","text":"<ul> <li>Defining and calling functions</li> <li>Arguments and return values</li> </ul>"},{"location":"lessons/#weeks-5-6-working-with-libraries-and-hardware","title":"Weeks 5-6: Working with Libraries and Hardware","text":""},{"location":"lessons/#lesson-8-importing-libraries","title":"Lesson 8: Importing Libraries","text":"<ul> <li>What is a library?</li> <li>Importing and using libraries</li> </ul>"},{"location":"lessons/#lesson-9-introduction-to-hardware-interaction","title":"Lesson 9: Introduction to Hardware Interaction","text":"<ul> <li>Communicating with smart watch displays</li> <li>Sending and receiving data</li> </ul>"},{"location":"lessons/#weeks-7-8-project-1-basic-digital-clock","title":"Weeks 7-8: Project 1: Basic Digital Clock","text":""},{"location":"lessons/#lesson-10-planning-the-project","title":"Lesson 10: Planning the Project","text":"<ul> <li>Project overview</li> <li>Creating a project plan</li> </ul>"},{"location":"lessons/#lesson-11-building-a-basic-digital-clock","title":"Lesson 11: Building a Basic Digital Clock","text":"<ul> <li>Displaying time on the smart watch display</li> <li>Updating the time</li> </ul>"},{"location":"lessons/#weeks-9-10-intermediate-python-concepts","title":"Weeks 9-10: Intermediate Python Concepts","text":""},{"location":"lessons/#lesson-12-lists-and-dictionaries","title":"Lesson 12: Lists and Dictionaries","text":"<ul> <li>Creating and manipulating lists and dictionaries</li> </ul>"},{"location":"lessons/#lesson-13-error-handling","title":"Lesson 13: Error Handling","text":"<ul> <li><code>try</code> and <code>except</code> blocks</li> </ul>"},{"location":"lessons/#weeks-11-12-project-2-analog-clock-display","title":"Weeks 11-12: Project 2: Analog Clock Display","text":""},{"location":"lessons/#lesson-14-planning-the-project","title":"Lesson 14: Planning the Project","text":"<ul> <li>Project overview</li> <li>Creating a project plan</li> </ul>"},{"location":"lessons/#lesson-15-building-an-analog-clock-display","title":"Lesson 15: Building an Analog Clock Display","text":"<ul> <li>Designing an analog clock</li> <li>Rotating clock hands based on the current time</li> </ul>"},{"location":"lessons/#weeks-13-14-advanced-python-concepts-and-optimization","title":"Weeks 13-14: Advanced Python Concepts and Optimization","text":""},{"location":"lessons/#lesson-16-more-about-functions","title":"Lesson 16: More About Functions","text":"<ul> <li>Lambda functions, higher-order functions</li> </ul>"},{"location":"lessons/#lesson-17-optimization-techniques","title":"Lesson 17: Optimization Techniques","text":"<ul> <li>Improving code efficiency</li> </ul>"},{"location":"lessons/#weeks-15-16-final-project-customizable-clockwatch","title":"Weeks 15-16: Final Project: Customizable Clock/Watch","text":""},{"location":"lessons/#lesson-18-planning-the-project","title":"Lesson 18: Planning the Project","text":"<ul> <li>Project overview</li> <li>Creating a project plan</li> </ul>"},{"location":"lessons/#lesson-19-building-a-customizable-clockwatch","title":"Lesson 19: Building a Customizable Clock/Watch","text":"<ul> <li>Adding customization options (color, style, etc.)</li> <li>Implementing user input for customization</li> </ul>"},{"location":"lessons/#lesson-20-final-project-presentations","title":"Lesson 20: Final Project Presentations","text":"<ul> <li>Students present their final projects</li> <li>Review and feedback session</li> </ul>"},{"location":"lessons/#ongoing-reflection-and-feedback","title":"Ongoing: Reflection and Feedback","text":"<ul> <li>After each project, have students reflect on what went well, what they struggled with, and what they learned.</li> <li>Continuously solicit feedback from students to improve the learning experience.</li> </ul> <p>This outline provides a balance between teaching Python concepts and applying them to real-world projects, which can keep students engaged and help them to better retain what they've learned. Tailor this outline to meet the specific needs and pace of your students, and ensure to provide plenty of opportunities for students to practice their skills, ask questions, and get feedback.</p>"},{"location":"lessons/00-hardware-config/","title":"Hardware Configuration Files","text":"<p>All our current displays use the SPI interface.  The alternative microcontroller bus, I2C, is about 10x slower than SPI.  The SPI intrface interface typically uses 7 wires, which can get a little complex.  Just a single wire broken or two wires crossed can will cause the display to not work.</p> <p>We have dozens of sample programs for each kit.  And the exact connections on our kits vary.  Rather than hard-coding the hardware pin numbers in each example, we can move them to a separate config.py file.  We can then just import that file into each of our examples.</p> <p>Here is a sample config.py file:</p> <pre><code># Dan's Robot Labs configuration file for ILI9341 clock project\n# The colors on the SPI bus cable are:\n# 3.3v power - red\n# SCK - orange\n# MISO/Data - yellow\n# DC - green\n# RESET - blue\n# GND - black\n# CS - purple\n\nSCK_PIN = 2\nMISO_PIN = 3 # labeled SDI(MOSI) on the back of the display\nDC_PIN = 4\nRESET_PIN = 5\nCS_PIN = 6\nROTATION = 90\n\nWIDTH=320\nHEIGHT=240\nBUTTON_1_PIN = 14 # one up from lower-left corner\nBUTTON_2_PIN = 15 # lower left corner with USB on top\n</code></pre> <p>To use this configuration file you will need to do two things:</p> <ol> <li>import the config file (don't add the .py extension)</li> <li>Add the prefix <code>config.</code> to each value you would like to reference.</li> </ol> <pre><code>import config\n\nWIDTH=config.WIDTH\n</code></pre>"},{"location":"lessons/01-get-local-time/","title":"Getting Local Time","text":""},{"location":"lessons/01-get-local-time/#lesson-overview","title":"Lesson Overview","text":"<p>In this lesson, we will learn how to get the local date and time from the MicroPython runtime using the standard <code>localtime()</code> function.  We will learn about how to use the eight integers returned by the <code>localtime()</code> functions.</p> <p>MicroPython provides a very convenient function called <code>localtime()</code> that will get the time from the host computer in your local timezone that you connect to via your USB cable.  Your local computer has a clock and knows the time in the local timezone.  This information is usually sent to MicroPython runtime when the computer is connected to the USB cable.</p> <p>Note</p> <p>The <code>gmtime()</code> function returns the time in UTC (Coordinated Universal Time) time.  Use this if you want time stamps that are not dependent on time zone and daylight savings rules.  For example, log files should use this function.</p>"},{"location":"lessons/01-get-local-time/#sample-code","title":"Sample Code","text":"<pre><code>import time\n\nprint(time.localtime())\n</code></pre>"},{"location":"lessons/01-get-local-time/#result","title":"Result","text":"<p>Local time returns a read-only tuple:</p> <pre><code>(2023, 2, 28, 18, 54, 7, 1, 59)\n</code></pre>"},{"location":"lessons/01-get-local-time/#extracting-specific-datetime-components","title":"Extracting Specific Date/Time Components","text":"<pre><code>from time import localtime\n\nnow = localtime()\nprint(now)\n\nprint('year:',    now[0])\nprint('month:',   now[1])\nprint('day:',     now[2])\nprint('hour:',    now[3])\nprint('minute:',  now[4])\nprint('sec:',     now[5])\nprint('weekday:', now[6])\nprint('day of year:', now[7])\n</code></pre>"},{"location":"lessons/01-get-local-time/#format-of-the-localtime","title":"Format of the Localtime","text":"<p>The format is a \"8-tuple\" of integers in the format (year, month, mday, hour, minute, second, weekday, yearday)</p> <p>Most of the values are pretty intuitive to figure out.  There are a few notes.</p> <ol> <li>Hour is the hour in 24-hour format.  If we want to display the hour in 12-hour format we will need to do some formatting.</li> <li>Weekday is a numeric code that runs from 0 for Monday to 6 for Sunday.</li> <li>Yearday is the day of the year.  January 1st is the fist day of the year so it is a 1 (not 0).</li> </ol>"},{"location":"lessons/01-get-local-time/#printing-formatted-dates","title":"Printing Formatted Dates","text":""},{"location":"lessons/01-get-local-time/#sample-code_1","title":"Sample Code","text":"<pre><code>import time\n\nnow = time.localtime()\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\nfor i in range(8):\n    print(label[i], ':', now[i])\n\nprint()\nprint(\"Date: {}/{}/{}\".format(now[1], now[2], now[0]))\nprint(\"Time: {}:{}\".format(now[3], now[4]))\n</code></pre>"},{"location":"lessons/01-get-local-time/#results","title":"Results","text":"<pre><code>year : 2023\nmonth : 2\nmday : 28\nhour : 19\nminute : 20\nsecond : 26\nweekday : 1\nyearday : 59\n\nDate: 2/28/2023\nTime: 19:20\n</code></pre>"},{"location":"lessons/01-get-local-time/#label-formatting","title":"Label Formatting","text":"<p>We can also add labels to make the date and time easier to read.</p> <pre><code>import time\n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\n\nnow = time.localtime()\n\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\nmonth_number = now[1]\nmonth_name = months[month_number]\nweekday_number = now[6]\nday_name = days[weekday_number]\nhour_number = now[3]\nif hour_number &lt; 13:\n    hour_12 = hour_number\n    am_pm = 'am'\nelse:\n    hour_12 = hour_number - 12\n    am_pm = 'pm'\n\nprint()\nprint(\"Date: {} {} {}, {}\".format(day_name, month_name, now[2], now[0]))\nprint(\"Time: {}:{} {}\".format(hour_12, now[4], am_pm))\n</code></pre>"},{"location":"lessons/01-get-local-time/#label-formatted-results","title":"Label Formatted Results","text":"<pre><code>Date: Tuesday March 28, 2023\nTime: 7:46 pm\n</code></pre>"},{"location":"lessons/01-get-local-time/#modifying-the-thonny-parameters","title":"Modifying the Thonny Parameters","text":"<p>By default Thonny syncs the host time at power up.</p> <p></p> <p>However, to test that our code is setting the correct local time we will need to disable this in future labs.</p> <p></p> <p>After we do this, the <code>localtime()</code> will return the number of seconds after midnight on January 1st, 2021.</p> <pre><code>import time\nprint(time.localtime())\n</code></pre> <p><pre><code>(2021, 1, 1, 0, 0, 22, 4, 1)\n</code></pre> This was printed 22 seconds after power up.</p> <p>We will used this when we use a RTC and use the Pico \"W\" to sync with the NTP functions.</p> <pre><code>from mpython import *\nimport ntptime\nimport secrets\n\n# summary\nmywifi=wifi()\nmywifi.connectWiFi(secrets.wifi_ssid, secrets.wifi_pass)\n\nprint(\"Local time before synchronization\uff1a%s\" %str(time.localtime()))\nntptime.settime()\nprint(\"Local time after synchronization\uff1a%s\" %str(time.localtime()))\n</code></pre> <p>Result:</p> <pre><code>Local time before synchronization\uff1a(2021, 1, 1, 0, 3, 31, 4, 1)\nLocal time after synchronization\uff1a(2023, 10, 16, 20, 16, 59, 0, 289)\n</code></pre>"},{"location":"lessons/01-get-local-time/#references","title":"References","text":"<ul> <li>MicroPython Time Documents</li> <li>Bhavesh Kakwani's blog Sync time in MicroPython using NTP - although the blog uses an ESP32, the concepts are the same on other processors such as the Raspberry Pi Pico.</li> </ul>"},{"location":"lessons/01-timekeeping-architecture/","title":"The Architecture of Timekeeping Devices","text":"<p>Throughout history people have designed clocks that were not just functional, but were things of beauty to be admired.  The example above is the famous Astronomical Clock called The Orloj which was built in Prague around 1400.  It remains an important tourist attraction in the city.</p> <p>Today, creating precise feature rich clocks is within the reach of anyone with $10 and a bit of curiosity.  Despite the fact that everyone uses their mobile phones to check the time, the landscape of creative and beautiful timekeeping devices continues to expand.  For example the market for beautiful Nixie tube clocks is perhaps larger than it has ever been due to the dedication of craftspeople like those people from Millclock in Ukraine.</p> <p></p> <p>I personally think that the Nixie Tube clocks, especially those created by Millclock are some of the  most pleasing forms of handcrafted artwork I have seen.  The amount of engineering that goes into manufacturing these 70 mm high retro-vacuum tubs is incredible.  Each wire in the tubes are made and assembled by hand, which is why a price of almost $2,000 for each clock is not surprising.</p> <p>It is interesting to note that many of the clocks in this course have features similar to the Millclock clocks such as syncing with time servers to get accurate times.  So you don't need a huge budget to get a precise clock these days!</p> <p>Regardless of your interest in timekeeping be it art, science, astronomy, being a maker, programming or AI, there are projects here to help you build your own highly personalized and customized timepiece using low cost components starting around $10.  These devices can be a platform for fun, learning computational thinking and artistic expression.</p> <p>One of the key things we learn about architecture choices is that there are few solutions that fit everyone's needs.  There are always trade offs.  You will find simple designs that are low-cost and easy to assemble in an hour.  You will also find complex designs that use exotic displays and integrate light and motion sensors to create a personalized experience for your device.</p> <p>First let take a look at the key architectural components of a timekeeping device.</p>"},{"location":"lessons/01-timekeeping-architecture/#core-components","title":"Core Components","text":"<p>Let's start with a high-level view of the core components of an electronic clock.  In the diagram above you see the following components:</p> <ol> <li>Sensors - These are things buttons and knobs that help us configure the time and settings of a clock.</li> <li>Microcontroller - This is the \"brain\" of our clock and where the programs run.  In our case we will be using the Raspberry Pi Pico and the Raspberry Pi Pico W (wireless) in our projects.</li> <li>Communications Bus - this is how we communicated between the microcontroller and the display.  In our labs the bus we will use is either a I2C (slower) or the faster SPI bus.</li> <li>Display - We will be using many types of displays from simple LEDs to complete graphical OLED displays.</li> <li>Power - Most of our projects are powered by a 5 volt USB cable or batteries.</li> </ol> <p>This diagram skims over a lot of the details like how we add wireless, photosensors to control brightness or adding speakers for sound for our alarm clocks.  But all our clocks will share these same basic components or very similar components.</p> <p>The architecture for our clocks and watches is the same architecture used in a field of computing called Physical Computing where computers read information from the real-world (incoming sensor data) and make changes to the world through actuators (usually things like motors and servos).  In the world of timekeeping, most of our output is the display and the speaker.  However, there are many fun clock projects that drive motors and servos to change the hands on a clock or change the visibility of a segment in a digit.</p> <p>Now let's do a little deeper dive into each of these components.</p>"},{"location":"lessons/01-timekeeping-architecture/#details-of-our-components","title":"Details of our Components","text":""},{"location":"lessons/01-timekeeping-architecture/#sensors-our-inputs","title":"Sensors - Our Inputs","text":""},{"location":"lessons/01-timekeeping-architecture/#buttons","title":"Buttons","text":"<p>Buttons are the most fundamental input devices in our clock projects. They serve multiple purposes including setting the time, changing modes, and configuring alarms. While they may seem simple, buttons require careful programming consideration to handle issues like switch bounce -- the tendency for mechanical switches to generate multiple signals when pressed once.</p> <p>In our projects, we typically use momentary push buttons that are normally open, meaning they only complete the circuit when pressed. These buttons are connected to the Pico's GPIO pins configured with internal pull-up resistors. This configuration means the pin reads HIGH normally and LOW when the button is pressed, simplifying our circuit design by eliminating the need for external resistors.</p> <p>Button debouncing is handled in our code using both hardware (capacitors) and software (timing delays) techniques. The code in our projects typically implements a debounce delay of 50-200 milliseconds, preventing multiple accidental triggers from a single press. This is particularly important when setting time values, where accuracy is crucial.</p>"},{"location":"lessons/01-timekeeping-architecture/#rotary-encoder-knobs","title":"Rotary Encoder Knobs","text":"<p>Rotary encoders provide an intuitive way to adjust values like hours and minutes in our clock projects. Unlike potentiometers that have fixed start and end positions, rotary encoders can rotate continuously in either direction. They work by generating two square wave signals (often called A and B) that are offset by 90 degrees, allowing us to determine both the direction and speed of rotation.</p> <p>The key advantage of rotary encoders in clock projects is their natural mapping to time adjustment -- clockwise rotation increases values while counterclockwise decreases them. Many of our projects use encoders with built-in push buttons, combining rotational input with selection capability in a single component. This allows users to both select what to adjust (by pressing) and make the adjustment (by rotating) with one control.</p> <p>Programming rotary encoders requires careful attention to interrupt handling, as we need to monitor both signal pins simultaneously to determine direction. Our code typically uses hardware interrupts to detect changes on either pin, then compares the states to determine rotation direction. We also implement acceleration, where faster rotation results in larger value changes, making it efficient to make both small adjustments and large changes.</p>"},{"location":"lessons/01-timekeeping-architecture/#photosensors","title":"Photosensors","text":"<p>Photosensors add environmental awareness to our clock projects, enabling automatic brightness adjustment based on ambient light conditions. The most common type we use is the Light Dependent Resistor (LDR), whose resistance varies inversely with light intensity. This simple component allows our displays to be clearly visible in bright daylight while avoiding harsh glare in darkness.</p> <p>Implementation of photosensors requires understanding analog-to-digital conversion, as these sensors output varying voltage levels rather than digital on/off signals. The Raspberry Pi Pico's ADC capabilities make it straightforward to read these analog values and convert them to usable brightness levels. Our projects typically map the sensor's full range to appropriate brightness values for our specific display type.</p> <p>Many of our advanced projects combine photosensor data with time-based algorithms to create sophisticated brightness control. For example, we might implement hysteresis to prevent rapid brightness changes in fluctuating light conditions, or combine time-of-day information with light levels to optimize display visibility while conserving power.</p>"},{"location":"lessons/01-timekeeping-architecture/#the-microcontroller","title":"The MicroController","text":"<p>The microcontroller serves as the brain of our clock projects, executing the MicroPython code that manages timekeeping, input handling, and display updates. While simple clocks could be built with basic logic circuits, using a microcontroller gives us tremendous flexibility in features and functionality while actually reducing the component count.</p> <p>Our projects primarily use the RP2040 microcontroller, which offers an excellent balance of processing power, memory, and input/output capabilities. Its dual-core architecture allows us to handle time-critical tasks like display updates on one core while managing user input and other features on the second core. The built-in programmable I/O (PIO) state machines are particularly useful for driving complex displays and handling precise timing requirements.</p> <p>One of the key advantages of using a microcontroller is the ability to easily add new features through software updates. Want to add a new alarm type or change how the display animates? Simply modify the code and upload it. This flexibility extends to handling different types of time synchronization, from manual setting to NTP time servers when using the wireless-enabled Pico W.</p>"},{"location":"lessons/01-timekeeping-architecture/#the-raspberry-pi-pico-and-the-rp2040","title":"The Raspberry Pi Pico and the RP2040","text":"<p>The Raspberry Pi Pico, built around the RP2040 chip, has become a go-to platform for DIY clock projects due to its robust feature set and low cost. The board provides 26 GPIO pins, hardware support for common interfaces like I2C and SPI, and built-in temperature sensing -- all features we leverage in our various clock designs.</p> <p>What makes the Pico particularly suitable for clock projects is its reliable performance and excellent power management capabilities. The board can run in several power modes, from full-speed operation to low-power sleep modes that help extend battery life in portable projects. The built-in USB programming interface makes development straightforward, while the extensive MicroPython support provides access to a rich ecosystem of libraries and examples.</p> <p>For more advanced projects, the Pico W variant adds wireless connectivity, enabling features like automatic time synchronization, weather display, and even remote configuration through web interfaces. The board's 2MB of flash storage provides ample space for our MicroPython code and additional features like custom fonts or sound files for alarms.</p>"},{"location":"lessons/01-timekeeping-architecture/#real-time-clocks-rtc","title":"Real-Time Clocks (RTC)","text":"<p>Real-Time Clocks are specialized timekeeping devices that maintain accurate time even when the main power is removed. While the Raspberry Pi Pico includes an internal RTC, it resets when power is lost. External RTC modules like the DS3231 provide continuous timekeeping through battery backup, making them essential for reliable clock projects.</p> <p>The DS3231 is particularly popular in our projects due to its high accuracy and temperature compensation. It communicates with the Pico using the I2C protocol, making it easy to integrate. The module includes a CR2032 battery backup that can maintain accurate time for several years without main power. Beyond basic timekeeping, it provides additional features like programmable alarms and a temperature sensor that helps compensate for timing variations caused by temperature changes.</p> <p>Working with external RTCs requires understanding both hardware connections and software protocols. Our projects typically use MicroPython's machine.RTC class for the internal RTC, but switch to specific libraries for external RTC modules. This allows us to leverage advanced features like temperature readings and sophisticated alarm settings. The combination of an external RTC with the Pico's internal RTC can provide both accuracy and flexibility, with the external RTC serving as the authoritative time source while the internal RTC handles temporary timing needs.</p>"},{"location":"lessons/01-timekeeping-architecture/#other-microcontrollers-that-run-micropython","title":"Other Microcontrollers that Run MicroPython","text":"<p>While our course focuses on the Raspberry Pi Pico, many other microcontrollers support MicroPython and can be used for clock projects. Popular alternatives include the ESP32 family, which offers built-in WiFi and Bluetooth capabilities, and various STM32 boards known for their processing power and extensive peripheral options.</p> <p>Each platform offers unique advantages. The ESP32, for instance, excels in wireless applications and includes a real-time clock (RTC) with battery backup capabilities. STM32 boards often provide more sophisticated analog interfaces and higher processing speeds, useful for complex display effects or audio generation.</p> <p>The key advantage of using MicroPython across these platforms is code portability. Many of our basic clock functions can be transferred between different microcontrollers with minimal modification, allowing students to experiment with different hardware while building on their existing knowledge.</p>"},{"location":"lessons/01-timekeeping-architecture/#our-display","title":"Our Display","text":""},{"location":"lessons/01-timekeeping-architecture/#ledx","title":"LEDx","text":"<p>LED displays form the foundation of many clock projects, ranging from simple seven-segment displays to complex LED matrices. The most basic projects use individual LEDs for time indication, while more advanced designs employ multiplexed seven-segment displays that can show hours, minutes, and even seconds with minimal microcontroller pins.</p> <p>Seven-segment displays remain popular due to their excellent visibility and straightforward programming interface. Each digit consists of seven LEDs arranged in a figure-8 pattern, plus an optional decimal point. By controlling which segments are lit, we can display numbers 0-9 and some letters. Multiple digits are typically multiplexed -- rapidly switching between digits faster than the human eye can detect -- to create the illusion of simultaneous display while using fewer GPIO pins.</p> <p>For more advanced projects, we often use LED matrices that provide greater flexibility in displaying both numbers and custom graphics. These can be controlled through shift registers or specialized LED driver ICs, reducing the number of required microcontroller pins while enabling complex animations and transitions.</p>"},{"location":"lessons/01-timekeeping-architecture/#graphic-displays-oled","title":"Graphic Displays (OLED)","text":"<p>OLED displays represent a significant step up in capabilities, offering full graphic control with excellent contrast and wide viewing angles. These displays communicate with the microcontroller via I2C or SPI protocols and can show both text and graphics. The most common resolution in our projects is 128x64 pixels, providing ample space for creative clock faces.</p> <p>The key advantage of OLED displays is their versatility. They can simulate traditional analog clock faces, display digital time in various fonts and sizes, and show additional information like temperature, humidity, or weather data. The high contrast ratio of OLED technology ensures excellent readability in various lighting conditions, while their low power consumption in displays with dark backgrounds makes them ideal for battery-powered projects.</p> <p>Programming OLED displays requires understanding basic graphics concepts like framebuffers and drawing primitives. Our projects use libraries that abstract these details while still allowing direct pixel control when needed. We can create smooth animations, implement multiple clock face designs, and even build interactive menus for settings and configuration.</p>"},{"location":"lessons/01-timekeeping-architecture/#speakers","title":"Speakers","text":"<p>In clock projects, speakers primarily serve for alarms and hourly chimes, though some advanced projects include more complex audio features. The simplest implementation uses a piezoelectric buzzer directly connected to a GPIO pin, capable of producing basic tones through PWM (Pulse Width Modulation) signals.</p> <p>For better sound quality, some projects employ small magnetic speakers with audio amplifier circuits. These can reproduce more complex sounds and music, though they require more sophisticated driving circuits and careful power management. The Raspberry Pi Pico's PWM capabilities make it possible to generate various frequencies and even simple melodies without additional hardware.</p> <p>Advanced projects might include multiple sound effects, customizable alarm tones, or even voice announcements. These typically require additional components like audio DACs (Digital-to-Analog Converters) or dedicated audio modules, along with careful consideration of timing to ensure smooth playback while maintaining accurate timekeeping.</p>"},{"location":"lessons/01-timekeeping-architecture/#analog-to-digital-converters","title":"Analog to Digital Converters","text":"<p>Analog to Digital Converters (ADCs) play a crucial role in our clock projects, primarily for reading sensors and implementing volume control for audio features. The Raspberry Pi Pico includes three ADC channels, providing 12-bit resolution for accurate measurements of analog signals.</p> <p>In clock applications, ADCs are most commonly used with photoresistors for automatic brightness control and potentiometers for user adjustments. The conversion process involves sampling the analog voltage at regular intervals and converting it to digital values our code can process. The Pico's ADC can sample at up to 500,000 samples per second, far exceeding our typical needs for clock projects.</p> <p>Understanding ADC principles is essential for handling real-world inputs effectively. Our projects implement techniques like oversampling to improve accuracy and filtering to reduce noise in measurements. This knowledge becomes particularly valuable when working with analog sensors for environmental monitoring or audio input processing.</p>"},{"location":"lessons/05-buttons/","title":"Buttons","text":"<p>Our standard watch kits places two or three buttons on the breadboard. You can use these buttons to set the time.</p> <p>The buttons are connected to the lower-left corner of the pico using GPIO 14 and GPIO 15.</p> <p>Instructions on how to use these buttons are covered in our MicroPython class:</p> <p>Using Buttons in MicroPython</p> <p>We suggest using the top blue button to change the mode of operation.  As you press this you cycle through various modes of your clock or watch.  Here are some sample modes for a clock:</p> <ol> <li>Run mode</li> <li>Set current time hour</li> <li>Set current time minute</li> <li>Set alarm hour</li> <li>Set alarm minute</li> </ol> <p>After you are in a given mode, the bottom button can be used to cycle through the options. Remember to get the current value for the cycle for each mode.  So if you are adjusting the hour you have to make sure the cycle value starts at the current hour.</p>"},{"location":"lessons/05-buttons/#sample-button-mode-code","title":"Sample Button Mode Code","text":"<pre><code>from utime import sleep, ticks_ms\nfrom machine import Pin\n\n# Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler\n\n# Config\nMODE_BUTTON_PIN = 14\nCYCLE_BUTTON_PIN = 15\nmode = 0 # the count of times the button has been pressed\ncycle = 0\nlast_time = 0 # the last time we pressed the button\n\nbuiltin_led = machine.Pin(25, Pin.OUT)\n# The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail\nmode_pin = machine.Pin(MODE_BUTTON_PIN, machine.Pin.IN, machine.Pin.PULL_UP)\ncycle_pin = machine.Pin(CYCLE_BUTTON_PIN, machine.Pin.IN, machine.Pin.PULL_UP)\n\n# This function gets called every time the button is pressed.  The parameter \"pin\" is not used.\ndef button_pressed_handler(pin):\n    global mode, cycle, last_time\n    new_time = ticks_ms()\n    # if it has been more that 1/5 of a second since the last event, we have a new event\n    if (new_time - last_time) &gt; 200:\n        # this should be pin.id but it does not work\n        if '14' in str(pin):\n            mode +=1\n        else:\n            cycle +=1\n        # last, we update the last time we got an ISR here\n        last_time = new_time\n\n\n# now we register the handler function when the button is pressed\nmode_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\ncycle_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\n\n# This is for only printing when a new button press count value happens\nold_mode = 0\nold_cycle = 0 \n\nwhile True:\n    # only print on change in the button_presses value\n    if mode != old_mode:\n        print('New Mode:', mode)\n        builtin_led.toggle()\n        old_mode = mode\n    if cycle != old_cycle:\n        print('New Cycle:', cycle)\n        builtin_led.toggle()\n        old_cycle = cycle\n    sleep(.1)\n</code></pre>"},{"location":"lessons/05-buttons/#three-button-set","title":"Three Button Set","text":"<pre><code>from machine import Pin\nimport time\n\n# Pin setup\nmode_pin = Pin(16, Pin.IN, Pin.PULL_UP)\nnext_pin = Pin(17, Pin.IN, Pin.PULL_UP)\nprevious_pin = Pin(18, Pin.IN, Pin.PULL_UP)\n\n# Time state\nhour = 12\nminute = 0\nis_pm = False\nmode = 0\nmode_names = [\"run\", \"set hour\", \"set minute\", \"set AM/PM\"]\nmode_count = len(mode_names)\n\n# Debounce state\nlast_mode_press = 0\nlast_next_press = 0\nlast_prev_press = 0\nDEBOUNCE_MS = 200\n\ndef format_time():\n    return f\"{hour:02d}:{minute:02d} {'PM' if is_pm else 'AM'}\"\n\ndef handle_mode(pin):\n    global mode, last_mode_press\n    current_time = time.ticks_ms()\n    if time.ticks_diff(current_time, last_mode_press) &gt; DEBOUNCE_MS:\n        mode = (mode + 1) % mode_count\n        print(f\"Mode: {mode_names[mode]}\")\n        last_mode_press = current_time\n\ndef handle_next(pin):\n    global hour, minute, is_pm, last_next_press\n    current_time = time.ticks_ms()\n    if time.ticks_diff(current_time, last_next_press) &gt; DEBOUNCE_MS:\n        if mode == 1:  # Set hour\n            hour = (hour % 12) + 1\n        elif mode == 2:  # Set minute\n            minute = (minute + 1) % 60\n        elif mode == 3:  # Toggle AM/PM\n            is_pm = not is_pm\n\n        if mode != 0:\n            print(format_time())\n        last_next_press = current_time\n\ndef handle_previous(pin):\n    global hour, minute, is_pm, last_prev_press\n    current_time = time.ticks_ms()\n    if time.ticks_diff(current_time, last_prev_press) &gt; DEBOUNCE_MS:\n        if mode == 1:  # Set hour\n            hour = ((hour - 2) % 12) + 1\n        elif mode == 2:  # Set minute\n            minute = (minute - 1) % 60\n        elif mode == 3:  # Toggle AM/PM\n            is_pm = not is_pm\n\n        if mode != 0:\n            print(format_time())\n        last_prev_press = current_time\n\n# Set up interrupts\nmode_pin.irq(trigger=Pin.IRQ_FALLING, handler=handle_mode)\nnext_pin.irq(trigger=Pin.IRQ_FALLING, handler=handle_next)\nprevious_pin.irq(trigger=Pin.IRQ_FALLING, handler=handle_previous)\n\n# Main loop\nprint(\"Clock started. Press mode button to change settings.\")\nwhile True:\n    if mode == 0:  # Only update display in run mode\n        print(format_time())\n        time.sleep(1)\n</code></pre>"},{"location":"lessons/06-setting-time/","title":"Manually Setting Time","text":"<p>We need a program that will use three buttons to set the time.</p>"},{"location":"lessons/06-setting-time/#the-mode-button","title":"The Mode Button","text":"<p>The first button is called the \"mode\" button.  It will cycle through four internal \"states\" of our clock. Here are the modes:</p> <ol> <li>Mode 0: Clock Running - this is the normal mode of operation</li> <li>Mode 1: Setting the Hour</li> <li>Mode 2: Setting the Minute</li> <li>Mode 3: Setting AM/PM</li> </ol> <p>Here is a walkthrough of the <code>button-mode-test.py</code> program, breaking it down into clear, digestible concepts for everyone new to MicroPython.</p>"},{"location":"lessons/06-setting-time/#code-walkthrough","title":"Code Walkthrough","text":""},{"location":"lessons/06-setting-time/#1-basic-setup-and-imports","title":"1. Basic Setup and Imports","text":"<pre><code>from mp_button import Button\nfrom time import localtime, sleep\nfrom machine import Pin\n</code></pre> <p>Let's understand what these lines do: - These are import statements that bring in code we need to use - <code>Button</code> is a special module that helps us work with physical buttons - <code>localtime</code> and <code>sleep</code> are time-related functions - <code>Pin</code> lets us work with the physical pins on our Raspberry Pi Pico</p>"},{"location":"lessons/06-setting-time/#2-setting-up-the-pins","title":"2. Setting Up the Pins","text":"<pre><code>mode_pin = Pin(16, Pin.IN, Pin.PULL_UP)\nnext_pin = Pin(17, Pin.IN, Pin.PULL_UP)\nprevious_pin = Pin(18, Pin.IN, Pin.PULL_UP)\n</code></pre> <p>Here's what's happening: - We're setting up three different pins (16, 17, and 18) on the Pico - Each pin is set as an input (<code>Pin.IN</code>) - meaning it receives signals rather than sends them - <code>Pin.PULL_UP</code> means the pin is naturally \"high\" (1) until a button press makes it \"low\" (0) - Think of it like a light switch that's normally on, and pressing the button turns it off</p>"},{"location":"lessons/06-setting-time/#3-global-variables","title":"3. Global Variables","text":"<pre><code>counter_pressed = 0\ncounter_released = 0\nmode = 0  # default clock running\nmode_names = [\"run\",\"set hour\",\"set minute\",\"set AM/PM\"]\nmode_count = len(mode_names)\nnow = localtime()\nhours = now[3]\nminutes = now[4]\nam_pm = 0\n</code></pre> <p>These are our program's variables: - <code>counter_pressed</code> and <code>counter_released</code> keep track of button presses - <code>mode</code> tells us which setting we're currently adjusting (starts at 0) - <code>mode_names</code> is a list of the different modes our clock can be in - <code>mode_count</code> is how many modes we have (4 in this case) - <code>now</code> gets the current time from the Pico - <code>hours</code> and <code>minutes</code> store the current time values - <code>am_pm</code> keeps track of whether it's morning (0) or afternoon (1)</p>"},{"location":"lessons/06-setting-time/#4-button-handler-functions","title":"4. Button Handler Functions","text":"<pre><code>def button_mode_irq(button, event):\n    global mode, hours, minutes\n    if event == Button.PRESSED:\n        mode += 1\n        mode = mode % mode_count\n        print('new mode:', mode, mode_names[mode])\n</code></pre> <p>This is our mode button handler: - <code>global</code> tells Python we want to change variables outside this function - When the button is pressed, we increase the mode by 1 - The <code>%</code> (modulo) operator helps us cycle back to 0 after reaching the last mode - For example: if mode is 3 and we add 1, <code>4 % 4 = 0</code>, so we go back to the first mode</p>"},{"location":"lessons/06-setting-time/#5-next-and-previous-button-handlers","title":"5. Next and Previous Button Handlers","text":"<pre><code>def button_next_irq(button, event):\n    global mode, hours, minutes, am_pm\n    if event == Button.PRESSED:\n        if mode == 1:\n            hours += 1\n        if mode == 2:\n            minutes += 1\n        if mode == 3:\n            am_pm = 1 if am_pm == 0 else 0\n</code></pre> <p>The next/previous buttons: - They only work when we're in a setting mode (not mode 0) - Mode 1: adjust hours - Mode 2: adjust minutes - Mode 3: toggle between AM and PM - The previous button does the same thing but decreases values</p>"},{"location":"lessons/06-setting-time/#6-creating-button-objects","title":"6. Creating Button Objects","text":"<pre><code>button_mode = Button(16, False, button_mode_irq, internal_pullup = True, debounce_time = 100)\nbutton_next = Button(17, False, button_next_irq, internal_pullup = True, debounce_time = 100)\nbutton_previous = Button(18, False, button_previous_irq, internal_pullup = True, debounce_time = 100)\n</code></pre> <p>Here we create our button objects: - Each button gets a pin number (16, 17, or 18) - We tell it which function to call when pressed (the <code>_irq</code> functions) - <code>debounce_time = 100</code> prevents multiple triggers from one press - Think of debouncing like waiting a moment to make sure someone really pressed the button once</p>"},{"location":"lessons/06-setting-time/#7-main-loop","title":"7. Main Loop","text":"<pre><code>while(True):\n    button_mode.update()\n    button_next.update()\n    button_previous.update()\n</code></pre> <p>This is our main program loop: - It runs forever (that's what <code>while True</code> means) - Each time through the loop, we check if any buttons were pressed - The <code>update()</code> function handles all the button checking for us</p>"},{"location":"lessons/06-setting-time/#full-program-listing","title":"Full Program Listing","text":"<pre><code>from mp_button import Button\nfrom time import localtime, sleep\nfrom machine import Pin\n\nmode_pin = Pin(16, Pin.IN, Pin.PULL_UP)\nnext_pin = Pin(17, Pin.IN, Pin.PULL_UP)\nprevious_pin = Pin(18, Pin.IN, Pin.PULL_UP)\n\n# we create a counter to increment as we press\n# and one to increment as we release\ncounter_pressed = 0\ncounter_released = 0\nmode = 0 # default clock running\nmode_names = [\"run\",\"set hour\",\"set minute\",\"set AM/PM\"]\nmode_count = len(mode_names)\nnow = localtime()\nhours = now[3]\nminutes = now[4]\nam_pm = 0\n\n# the following method (function) will be invoked\n# when the button changes state\n# the Button module expects a callback to handle \n# - pin number\n# - event (Button.PRESSED | Button.RELEASED)\n# the event contains a string 'pressed' or 'released'\n# which can be used in your code to act upon\ndef button_mode_irq(button, event):\n    global mode, hours, minutes\n    if event == Button.PRESSED:\n        mode +=1\n        # cycle back to zero if greater than mode_count\n        mode =  mode % mode_count\n        print('new mode:', mode, mode_names[mode])\n\ndef button_next_irq(button, event):\n    global mode, hours, minutes, am_pm\n    if event == Button.PRESSED:\n        if mode == 1:\n            hours += 1\n        if mode == 2:\n            minutes += 1\n        if mode == 3:\n            if am_pm == 0:\n                am_pm = 1\n            else:\n                am_pm = 0\n        print('next button:', hours, minutes, am_pm)\n\ndef button_previous_irq(button, event):\n    global mode, hours, minutes, am_pm\n    if event == Button.PRESSED:\n        if mode == 1:\n            hours -= 1\n        if mode == 2:\n            minutes -= 1\n        if mode == 3:\n            if am_pm == 0:\n                am_pm = 1\n            else:\n                am_pm = 0\n        print('prev button:', hours, minutes, am_pm)\n\nbutton_mode = Button(16, False, button_mode_irq, internal_pullup = True, debounce_time = 100)\nbutton_next = Button(17, False, button_next_irq, internal_pullup = True, debounce_time = 100)\nbutton_previous = Button(18, False, button_previous_irq, internal_pullup = True, debounce_time = 100)\n\nprint(\"year:\", now[0], \"month:\", now[1], \"day-of-month:\", now[2], \"hours\", now[3], \"minutes:\", now[4])\nwhile(True):\n    button_mode.update()\n    button_next.update()\n    button_previous.update()\n</code></pre>"},{"location":"lessons/06-setting-time/#the-decrement-time","title":"The Decrement Time","text":"<p>The following line need some explanation:</p> <p><pre><code>hour = ((hour - 2) % 12) + 1\n</code></pre> Let me break down that line, which handles decrementing hours  while staying within the 1-12 range:</p> <p>Let's walk through it step by step:</p> <ol> <li>First, we subtract 2 from the current hour: <code>(hour - 2)</code></li> <li>We subtract 2 (not 1) because we'll add 1 back at the end</li> <li> <p>This shift is necessary because we want to work with 0-11 for the modulo operation</p> </li> <li> <p>Then we take modulo 12: <code>% 12</code></p> </li> <li>This ensures our number wraps around within 0-11</li> <li> <p>For example, if hour was 1, then (1-2) = -1, and -1 % 12 = 11</p> </li> <li> <p>Finally, we add 1: <code>+ 1</code></p> </li> <li>This shifts our range from 0-11 back to 1-12</li> </ol> <p>Here's an example sequence to show how it works: - Starting at hour = 1:   - (1 - 2) = -1   - -1 % 12 = 11   - 11 + 1 = 12 - Starting at hour = 12:   - (12 - 2) = 10   - 10 % 12 = 10   - 10 + 1 = 11</p> <p>This gives us the desired behavior of decrementing through the  sequence: 12 \u2192 11 \u2192 10 \u2192 ... \u2192 1 \u2192 12</p>"},{"location":"lessons/06-setting-time/#updating-the-display","title":"Updating the Display","text":"<pre><code>from machine import Pin\nfrom utime import localtime, sleep, ticks_ms, ticks_diff\nimport tm1637\n\n# Pin setup\nCLK_PIN = 0\nDST_PIN = 1\nPM_PIN = 25\n\nmode_pin = Pin(16, Pin.IN, Pin.PULL_UP)\nnext_pin = Pin(17, Pin.IN, Pin.PULL_UP)\nprevious_pin = Pin(18, Pin.IN, Pin.PULL_UP)\n# LED value 0 indicates AM, value 1 indicates PM\npm_pin = Pin(PM_PIN, Pin.OUT)\n\n# Time state\nnow = localtime()\nhour = now[3]\nminute = now[4]\nsecond = now[5]\n\ntm = tm1637.TM1637(clk=Pin(CLK_PIN), dio=Pin(DST_PIN))\n\nmode = 0\nmode_names = [\"run\", \"set hour\", \"set minute\", \"set AM/PM\"]\nmode_count = len(mode_names)\n\n# Debounce state\nlast_mode_press = 0\nlast_next_press = 0\nlast_prev_press = 0\nDEBOUNCE_MS = 100\n\ndef format_time():\n    return f\"{hour:d}:{minute:02d}:{second:02d} {'PM' if is_pm else 'AM'}\"\n\ndef set_pm():\n    if hour &lt; 12:\n        is_pm = False\n        pm_pin.value(0)\n    else:\n        is_pm = True\n        pm_pin.value(1)\n\ndef handle_mode(pin):\n    global mode, last_mode_press\n    current_time = ticks_ms()\n    if ticks_diff(current_time, last_mode_press) &gt; DEBOUNCE_MS:\n        mode = (mode + 1) % mode_count\n        print(f\"Mode: {mode_names[mode]}\")\n        last_mode_press = current_time\n\ndef handle_next(pin):\n    global hour, minute, is_pm, last_next_press\n    current_time = ticks_ms()\n    if ticks_diff(current_time, last_next_press) &gt; DEBOUNCE_MS:\n        if mode == 1:  # Set hour\n            hour = (hour % 12) + 1\n        elif mode == 2:  # Set minute\n            minute = (minute + 1) % 60\n        elif mode == 3:  # Toggle AM/PM\n            is_pm = not is_pm\n\n        if mode != 0:\n            print(format_time())\n        last_next_press = current_time\n\ndef handle_previous(pin):\n    global hour, minute, is_pm, last_prev_press\n    current_time = ticks_ms()\n    if ticks_diff(current_time, last_prev_press) &gt; DEBOUNCE_MS:\n        if mode == 1:  # Set hour\n            hour = ((hour - 2) % 12) + 1\n        elif mode == 2:  # Set minute\n            minute = (minute - 1) % 60\n        elif mode == 3:  # Toggle AM/PM\n            is_pm = not is_pm\n\n        if mode != 0:\n            print(format_time())\n        last_prev_press = current_time\n\n# numbers modified to not dispaly the leading zero\ndef numbers_nlz(num1, num2, colon=True):\n    \"\"\"Display two numeric values -9 through 99, with a leading space before\n    single-digit first numbers and separated by a colon.\"\"\"\n    num1 = max(-9, min(num1, 99))\n    num2 = max(-9, min(num2, 99))\n    prefix = ' ' if num1 &lt; 10 else ''\n    # print(f'\"{prefix}{num1:d}{num2:0&gt;2d}\"')\n    segments = tm.encode_string(f'{prefix}{num1:d}{num2:0&gt;2d}')\n    if colon:\n        segments[1] |= 0x80  # colon on\n    tm.write(segments)\n\n# Set up interrupts\nmode_pin.irq(trigger=Pin.IRQ_FALLING, handler=handle_mode)\nnext_pin.irq(trigger=Pin.IRQ_FALLING, handler=handle_next)\nprevious_pin.irq(trigger=Pin.IRQ_FALLING, handler=handle_previous)\n\n# Main loop\nprint(\"Clock started. Press mode button to change settings.\")\n\nwhile True:\n    second = localtime()[5]\n    if mode == 0:  # Only update display in run mode\n        print(format_time())\n        # flash the colon on and off every second\n        if (second % 2): # modulo 2 will be true for odd numbers\n            numbers_nlz(hour, minute, True)\n        else:\n            numbers_nlz(hour, minute, False)\n        set_pm()\n        sleep(1)\n</code></pre>"},{"location":"lessons/10-i2c-bus/","title":"The I2C Bus Standard","text":"<p>Most microcontrollers use the I2C bus as a standard way to communicate with peripheral devices such as sensors, real-time clocks and displays.  In this section we cover how to connect your I2C devices to the main microcontroller and test that the connections are working.</p> <p>Note that I2C is a two-way bus.  Although in many of our display examples, there is only data moving from the microcontroller to the device.  When we study real-time clocks we will see data going back and forth from the microcontroller to peripheral device.</p>"},{"location":"lessons/10-i2c-bus/#connections","title":"Connections","text":"<p>The I2C bus has four connections:</p> <ol> <li>GND - Ground</li> <li>VCC - Power - (usually 3.3 or 5 volts)</li> <li>SDA - Data</li> <li>SCL - Clock</li> </ol>"},{"location":"lessons/10-i2c-bus/#ground-gnd","title":"Ground (GND)","text":"<p>The common reference point for electrical signals that completes the circuit and ensures stable voltage measurements. </p> <p>Connecting the display's GND pin to the microcontroller's GND pin provides a shared zero-voltage reference.</p>"},{"location":"lessons/10-i2c-bus/#power-vcc","title":"Power (VCC)","text":"<p>The voltage supply line that provides electrical power to operate the display, typically accepting either 3.3V or 5V depending on the model.</p> <p>Connecting a 3.3V supply from the microcontroller to power a small OLED display.</p>"},{"location":"lessons/10-i2c-bus/#serial-data-sda","title":"Serial Data (SDA)","text":"<p>A bidirectional line that carries data bits between devices using a specific protocol for addressing and acknowledgment. </p> <p>In the example code above, we use GPIO pin 0 to transmit display content and receive status information.</p>"},{"location":"lessons/10-i2c-bus/#serial-clock-scl","title":"Serial Clock (SCL)","text":"<p>A timing signal line generated by the master device that synchronizes data transfer and defines when the data line should be read or written.  In our work, the master device is the microcontroller which sends the clock signal to the display.</p> <p>In the sample code, we use GPIO pin 1 to coordinate data transfers at rates typically between 100kHz and 400kHz.</p> <p>Some important points about these connections:</p> <ol> <li>Both SDA and SCL require pull-up resistors (typically 4.7k\u03a9)</li> <li>All devices share the same GND connection</li> <li>Multiple I2C devices can share the same SDA and SCL lines</li> <li>Power must match the display's voltage requirements (check datasheet)</li> </ol>"},{"location":"lessons/10-i2c-bus/#sample-i2c-display-initialization-code","title":"Sample I2C Display Initialization Code","text":"<pre><code>from machine import Pin, I2C\nfrom ssd1306 import SSD1306_I2C\n\ni2c = I2C(0, sda=Pin(0), scl=Pin(1))\ndisplay = SSD1306_I2C(128, 64, i2c)\n\n# drawing code here\ndisplay.fill(0)\ndisplay.text(\"MicroPython\", 0, 0)\ndisplay.text(\"Rocks!\", 20, 20)\ndisplay.show()\n</code></pre> <p>Let's break down this I2C initialization code:</p> <p>This code sets up a communication interface to control an OLED display using I2C (Inter-Integrated Circuit) protocol instead of SPI. Here's what each part does:</p> <ol> <li>The imports:</li> </ol> <pre><code>from machine import Pin, I2C            # Gets I2C and Pin control classes\nfrom ssd1306 import SSD1306_I2C         # Gets the OLED display driver\n</code></pre> <ol> <li>The I2C bus initialization:</li> </ol> <pre><code>i2c = I2C(0,                           # Use I2C bus 0 \n          sda=Pin(0),                  # Data line on GPIO pin 0\n          scl=Pin(1))                  # Clock line on GPIO pin 1\n</code></pre> <ol> <li>The display initialization:</li> </ol> <pre><code>display = SSD1306_I2C(128,             # Display width in pixels\n                      64,              # Display height in pixels \n                      i2c)             # I2C bus we created\n</code></pre> <p>Key differences from the SPI version: - Uses only 2 pins instead of 5 (no CS, DC, or RES needed) - Simpler initialization code - Slightly slower than SPI but adequate for most uses - Can share bus with other I2C devices using different addresses</p> <p>Worth noting that I2C is often preferred for simple display projects because it requires fewer pins and simpler wiring, even though it's not as fast as SPI.</p> <p>A common issue to watch for is making sure your I2C connections have appropriate pull-up resistors, though many development boards include these built-in.</p>"},{"location":"lessons/10-i2c-bus/#testing-your-connections","title":"Testing Your Connections","text":""},{"location":"lessons/10-i2c-bus/#the-i2c-scanner","title":"The I2C Scanner","text":"<pre><code>from machine import I2C, Pin\nimport time\n\n# I2C setup\ni2c = I2C(0, sda=Pin(0), scl=Pin(1))\n\n# Run the scanner\ndevices_found = i2c.scan()\nfor device in devices_found:\n    print(device, hex(device))\n</code></pre> <p>This code is useful for testing connections on your clock projects.</p> <p>Imagine you've just connected a new display or real-time clock chip to your Raspberry Pi Pico W, and you want to make sure it's properly connected before you start writing more complex code. This is where this I2C scanner comes in handy - it's like a metal detector that beeps when it finds something, but for electronic components!</p> <p>Let's break it down step by step:</p>"},{"location":"lessons/10-i2c-bus/#imports","title":"Imports","text":"<p>First, we import the tools we need: <pre><code>from machine import I2C, Pin\nimport time\n</code></pre> - <code>I2C</code> is for communicating with components using just two wires - <code>Pin</code> lets us control the physical pins on the Pico W - <code>time</code> gives us timing functions (though we don't use it in this example)</p>"},{"location":"lessons/10-i2c-bus/#connection-setup","title":"Connection Setup","text":"<p>Next, we set up I2C communication:</p> <p><pre><code>i2c = I2C(0, sda=Pin(0), scl=Pin(1))\n</code></pre> - <code>I2C(0)</code> means we're using the first I2C channel - <code>sda=Pin(0)</code> connects the data line to pin GP0 - <code>scl=Pin(1)</code> connects the clock line to pin GP1</p>"},{"location":"lessons/10-i2c-bus/#run-the-scan-function","title":"Run the Scan Function","text":"<p>Finally, we scan for devices and print what we find:</p> <pre><code>devices_found = i2c.scan()\nfor device in devices_found:\n    print(device, hex(device))\n</code></pre> <ul> <li><code>i2c.scan()</code> looks for any I2C devices connected to those pins</li> <li>For each device found, it prints both the decimal number and hexadecimal address</li> <li>For example, if you see <code>104 0x68</code>, that's the same number in two formats</li> <li><code>0x68</code> (hex 68) is the address for a DS3231 real-time clock</li> <li><code>0x3C</code> (hex 3C) is common for OLED displays</li> </ul> <p>This code is super helpful because: 1. It confirms your wiring is correct - if you see a device, your connections work! 2. It tells you the address of your device, which you need for the rest of your code 3. It helps troubleshoot - if you don't see your device, you know to check your wiring</p> <p>Think of it like checking if your game controller is properly connected to your computer - this code does the same thing for I2C devices connected to your Pico W.</p>"},{"location":"lessons/10-i2c-bus/#common-i2c-addresses-for-clock-and-watches","title":"Common I2C Addresses for Clock and Watches","text":"<p>I'll create a comprehensive list of common I2C addresses you might encounter when building clocks and watches with the Raspberry Pi Pico W.</p>"},{"location":"lessons/10-i2c-bus/#real-time-clock-rtc-modules","title":"Real-Time Clock (RTC) Modules","text":"<ul> <li><code>0x68</code>: DS3231 Temperature-compensated RTC</li> <li><code>0x68</code>: DS1307 Basic RTC</li> <li><code>0x6F</code>: PCF8563 RTC</li> </ul>"},{"location":"lessons/10-i2c-bus/#oled-lcd-displays","title":"OLED &amp; LCD Displays","text":"<ul> <li><code>0x3C</code>: SSD1306 OLED display (most common setting)</li> <li><code>0x3D</code>: SSD1306 OLED display (alternate address)</li> <li><code>0x27</code>: LCD displays with PCF8574 I2C adapter</li> <li><code>0x3F</code>: LCD displays with PCF8574A I2C adapter</li> </ul>"},{"location":"lessons/10-i2c-bus/#environmental-sensors-for-clockweather-stations","title":"Environmental Sensors (for clock/weather stations)","text":"<ul> <li><code>0x76</code>: BME280 Temperature/Humidity/Pressure (primary address)</li> <li><code>0x77</code>: BME280 Temperature/Humidity/Pressure (alternate address)</li> <li><code>0x40</code>: HDC1080 Temperature/Humidity</li> <li><code>0x44</code>: SHT31 Temperature/Humidity (primary address)</li> <li><code>0x45</code>: SHT31 Temperature/Humidity (alternate address)</li> </ul>"},{"location":"lessons/10-i2c-bus/#user-input-expanders","title":"User Input Expanders","text":"<ul> <li><code>0x20</code> - <code>0x27</code>: MCP23017 16-bit I/O expander (configurable)</li> <li><code>0x38</code> - <code>0x3F</code>: PCF8574 8-bit I/O expander (configurable)</li> </ul>"},{"location":"lessons/10-i2c-bus/#pro-tips","title":"Pro Tips:","text":"<ol> <li>If you see address conflicts (two devices wanting to use <code>0x68</code> for example), many devices have an address select pin or jumper to change their address.</li> <li>Some devices like the SSD1306 OLED have a built-in address selection based on whether you connect their SA0 pin to ground or VCC.</li> <li>Always run an I2C scanner before starting a new project to confirm your device addresses match what you expect.</li> </ol> <p>Remember: These addresses are shown in hexadecimal format (hence the <code>0x</code> prefix). When you see these in scan results, they'll often show both decimal and hex formats (like <code>104 0x68</code> for a DS3231).</p>"},{"location":"lessons/11-spi-bus/","title":"The SPI Bus","text":"<p>The SPI Bus is the fastest serial bus that is used with most microcontrollers.  Although it is fast, most displays need seven wires to connect a display.  This is in contrast to the I2C bus that only uses four wires.</p> <pre><code>from machine import Pin, I2C\nimport ssd1306\n\nSCL=machine.Pin(2) # SPI CLock\nSDA=machine.Pin(3) # SPI Data\n\n# configure the SPI bus\n# for clocks with 20cm connectors 3MBS is a good choice\nspi=machine.SPI(0, sck=SCL, mosi=SDA, baudrate=3_000_000)\n\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\n# configure the display\ndisp = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n</code></pre> <p>The underscore in <code>3_000_000</code> is just Python syntax for making large numbers more readable - it's equivalent to writing <code>3000000</code>. This is a helpful convention when working with clock speeds and baudrates.</p>"},{"location":"lessons/11-spi-bus/#spi-bus","title":"SPI Bus","text":"<p>A serial communication interface that operates in a master-slave configuration using separate clock and data lines to synchronize high-speed data transfer between electronic components. </p> <p>Example: Configuring an SPI bus with a 3 MHz clock rate to drive an OLED display.</p>"},{"location":"lessons/11-spi-bus/#oled-display","title":"OLED Display","text":"<p>A self-illuminating electronic visual output device that uses organic light-emitting diodes arranged in a matrix to show text, numbers, or graphics. </p> <p>Example: A 128x64 pixel monochrome display showing time and temperature readings.</p>"},{"location":"lessons/11-spi-bus/#chip-select-cs","title":"Chip Select (CS)","text":"<p>A control signal that activates or deactivates a specific integrated circuit in a system with multiple devices sharing the same communication bus.</p> <p>Example: We can change the state of th CS pin to enable communication with the display while keeping other SPI devices inactive.  This allows you to use a single bus to communicated with multiple displays.</p>"},{"location":"lessons/11-spi-bus/#datacommand-dc","title":"Data/Command (DC)","text":"<p>A control line that indicates whether the transmitted information represents display commands or visual data to be shown. </p> <p>Example: Using Pin 5 to distinguish between instructions for display configuration and pixel data.</p>"},{"location":"lessons/11-spi-bus/#reset-res","title":"Reset (RES)","text":"<p>A control signal that returns an electronic device to its initial state, clearing all registers and settings to default values. </p> <p>Example: You can use the RESET to delay the startup of a display to make sure that the display has powered up in a coherent way and will start in a consistent state.</p>"},{"location":"lessons/11-spi-bus/#clock-line-scl","title":"Clock Line (SCL)","text":"<p>A signal wire that provides timing synchronization pulses to coordinate data transfer between electronic devices. </p> <p>Example: We use the Clock Line to generate 3 million clock pulses per second for display updates.</p>"},{"location":"lessons/11-spi-bus/#data-line-sdamosi","title":"Data Line (SDA/MOSI)","text":"<p>A signal wire that carries information serially from a controlling device to a receiving device. </p> <p>Example: We use the SDA pin to transmit display content one bit at a time.</p>"},{"location":"lessons/11-spi-bus/#tuning-the-baudrate","title":"Tuning the Baudrate","text":"<p>The baudrate parameter determines the transfer between thn microcontroller and the peripheral device.</p> <p>The baudrate=3_000_000 (3 megabits per second) setting is a reasonable balance for this application.  Digital clock displays are often only updated once per second.</p> <p>For SPI OLED displays with short connections (~20cm or less), a 3 MHz clock rate provides:</p> <ul> <li>Reliable data transfer while avoiding signal integrity issues</li> <li>Fast enough updates to prevent visible display flicker</li> <li>Reliable operation within the SSD1306 controller's specifications</li> </ul>"},{"location":"lessons/11-spi-bus/#when-higher-speeds-matter","title":"When Higher Speeds Matter","text":"<p>Simulating an analog clock face on a color watch display will require a large amount of data being transmitted between the microcontroller and the display.  For these situations you will frequently keep the wires between the microcontroller and the display short and then turn up the baudrate on the SPI interface.</p>"},{"location":"lessons/30-ili9341/","title":"ILI9341 Drawing","text":"<p>The ILI9341 chip is a 262144-color single-chip SOC driver for a TFT liquid crystal display with a resolution of 240x320 dots (RGB).</p> <p>Source Code</p>"},{"location":"lessons/30-ili9341/#configuration-file","title":"Configuration file","text":"<p>These examples will all use the following config file:</p> <p>config.py <pre><code>SCK_PIN = 2\nMISO_PIN = 3 # labeled SDI(MOSI) on the back of the display\nDC_PIN = 4\nRESET_PIN = 5\nCS_PIN = 6\nROTATION = 90\n\nWIDTH=320\nHEIGHT=240\n</code></pre></p> <p>We also put the color names in a colors.py file that calculates the colors using a name.</p> <pre><code>from ili9341 import color565\n\nWHITE = color565(255,255,255)\nBLACK = color565(0,0,0)\nRED = color565(255,0,0)\nORANGE = color565(255,128,0)\nYELLOW = color565(255,255,0)\nGREEN = color565(0,255,0)\nBLUE = color565(0,0,255)\nCYAN = color565(0,255,255)\nPURPLE = color565(255,0,255)\n</code></pre>"},{"location":"lessons/30-ili9341/#simple-drawing","title":"Simple Drawing","text":""},{"location":"lessons/40-machine-info/","title":"Machine Info","text":""},{"location":"lessons/40-machine-info/#modules","title":"Modules","text":"<pre><code>help('modules')\n</code></pre>"},{"location":"lessons/40-machine-info/#clock-frequency","title":"Clock Frequency","text":"<pre><code>import machine\nprint('freq:', machine.freq())\n</code></pre>"},{"location":"lessons/40-machine-info/#operating-system","title":"Operating System","text":"<pre><code>os.uname()\n</code></pre> <pre><code>os.statvfs(path)\n</code></pre>"},{"location":"lessons/40-machine-info/#platform","title":"Platform","text":"<pre><code>platform.platform()\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/","title":"Using Multiple Fonts","text":"<p>THe SSD1306 Display Driver only uses a single font. If we want multiple fonts we will need steps to convert open font libraries into a format that can be used by MicroPython.  Here are the steps:</p> <p>Font to Py Converter</p> <p>Code Walkthough</p> <p>Sample Helvetica Variable Width Font</p> <p>Helvetica Fixed Width Font</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/","title":"Understanding Font Display on OLED - A Student's Guide","text":""},{"location":"lessons/50-muntiple-fonts/code-walk-through/#introduction","title":"Introduction","text":"<p>Hey there! Let's learn how to display different fonts on an OLED screen using MicroPython. Think of this like creating your own digital sign board, where you can choose different writing styles (fonts) to display your messages.</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#part-1-the-writer-class-your-digital-pen","title":"Part 1: The Writer Class - Your Digital Pen","text":"<p>First, let's understand the <code>Writer</code> class. This is like a special pen that knows how to write characters on your OLED screen.</p> <pre><code>class Writer:\n    def __init__(self, display, font, verbose=True):\n        self.display = display    # Your OLED screen\n        self.font = font         # The font you want to use\n        self.char_dict = {}      # Dictionary to store characters\n        self.init_char_dict()    # Set up the characters\n        self.x = 0              # Starting position (left)\n        self.y = 0              # Starting position (top)\n        self.verbose = verbose  # Whether to show helpful messages\n</code></pre> <p>Think of this like: - <code>display</code> is your paper (OLED screen) - <code>font</code> is your pen style - <code>x</code> and <code>y</code> are where your pen is on the paper - <code>char_dict</code> is like your alphabet reference</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#part-2-character-management","title":"Part 2: Character Management","text":"<pre><code>def init_char_dict(self):\n    # Get all characters from start to end of font\n    for char in range(self.font.get_start(), self.font.get_end() + 1):\n        self.char_dict[chr(char)] = None\n</code></pre> <p>This is like making a list of all the letters and symbols your font can write. If you only need numbers 0-9, your list would be shorter than if you need the whole alphabet.</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#part-3-moving-to-a-new-line","title":"Part 3: Moving to a New Line","text":"<pre><code>def _newline(self):\n    # Move down by the font height\n    self.y += self.font.height()\n    # Go back to the left side\n    self.x = 0\n    # If we reach the bottom, go back to top\n    if self.y &gt;= self.display.height - self.font.height():\n        if self.verbose:\n            print('Screen full! Returning to top.')\n        self.y = 0\n</code></pre> <p>This is like when you reach the end of a line in your notebook: 1. Move down to the next line 2. Start from the left again 3. If you reach the bottom of the page, go back to the top</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#part-4-writing-characters","title":"Part 4: Writing Characters","text":"<pre><code>def _printchar(self, char):\n    # Handle new line character\n    if char == '\\n':\n        self._newline()\n        return\n\n    # Check if we can write this character\n    if char not in self.char_dict:\n        if self.verbose:\n            print(f'Character {char} not in font!')\n        return\n\n    # Get the character's image data\n    buf, w = self.font.get_ch(char)\n    fb = framebuf.FrameBuffer(bytearray(buf), w, self.font.height(), \n                             framebuf.MONO_HLSB)\n\n    # If we'll go past the right edge, start a new line\n    if self.x + w &gt; self.display.width:\n        self._newline()\n\n    # Draw the character and move right\n    self.display.blit(fb, self.x, self.y)\n    self.x += w\n</code></pre> <p>This is the most important part! For each character: 1. Check if it's a new line (\\n) 2. Make sure we can write this character 3. Get the character's picture (like a stamp) 4. If we're too close to the right edge, move to next line 5. \"Stamp\" the character on the screen 6. Move right for the next character</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#part-5-putting-it-all-together","title":"Part 5: Putting It All Together","text":"<p>Here's how you use it:</p> <pre><code># Set up your OLED display\nspi = SPI(0, sck=SCL, mosi=SDA, baudrate=100000)\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\n# Create your writer with a font\nwriter = Writer(oled, your_font)\n\n# Clear the screen\noled.fill(0)\n\n# Move to position (0,0) - top left\nwriter.set_textpos(0, 0)\n\n# Write some text\nwriter.printstring(\"Hello!\")\n\n# Show it on the screen\noled.show()\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#common-questions","title":"Common Questions","text":""},{"location":"lessons/50-muntiple-fonts/code-walk-through/#q-why-do-we-need-a-special-writer-class","title":"Q: Why do we need a special writer class?","text":"<p>A: The OLED screen only understands pixels (tiny dots). The Writer class converts letters into the right pattern of dots.</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#q-whats-a-framebuffer","title":"Q: What's a framebuffer?","text":"<p>A: Think of it like a rough draft - we draw the character there first, then copy it to the screen. It's like using tracing paper before drawing on your final paper.</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#q-why-check-the-screen-edges","title":"Q: Why check the screen edges?","text":"<p>A: Just like you don't want to write off the edge of your paper, we need to make sure text stays within the screen boundaries.</p>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#tips-for-success","title":"Tips for Success","text":"<ol> <li>Start with small fonts - big fonts take more memory</li> <li>Test your text before running it on the device</li> <li>Remember to call <code>oled.show()</code> to display your changes</li> <li>Clear the screen (<code>oled.fill(0)</code>) before writing new text</li> <li>Keep track of your position with <code>set_textpos()</code></li> </ol>"},{"location":"lessons/50-muntiple-fonts/code-walk-through/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Try writing your name in different positions on the screen</li> <li>Make text that automatically wraps around when it hits the edge</li> <li>Create a scrolling message that moves up the screen</li> <li>Mix different fonts in the same display</li> </ol> <p>Remember: The OLED screen is 128 pixels wide and 64 pixels tall. Think of it like a very small piece of graph paper where you can light up individual squares to form letters! ```</p>"},{"location":"lessons/50-muntiple-fonts/font-to-py/","title":"Font to MicroPython","text":"<p>Prompt</p> <p>Please give me suggestions on how I can display other fonts on the SSD1306 OLED using MicroPython.</p> <p>Based on the provided code and the SSD1306 OLED display usage, I can suggest several approaches for displaying different fonts:</p> <ol> <li>Using Framebuf-Based Custom Fonts</li> </ol> <pre><code>import framebuf\n# Define a custom font as a bytearrayCUSTOM_FONT ={'0':bytearray([0b01110000,0b10001000,0b10001000,0b10001000,0b01110000]),# Add more characters...}defdraw_custom_char(oled, char, x, y):if char in CUSTOM_FONT:        fb = framebuf.FrameBuffer(CUSTOM_FONT[char],8,8, framebuf.MONO_VLSB)        oled.blit(fb, x, y)`\n</code></pre> <ol> <li>Using Third-Party Font Modules</li> </ol> <pre><code>python\nCopy\n\n`# writer.py module approachfrom writer import Writer\nimport font10  # Example font moduledefsetup_custom_font(oled):    font_writer = Writer(oled, font10)    font_writer.set_textpos(0,0)return font_writer`\n</code></pre> <ol> <li>Converting TrueType Fonts You can convert TrueType fonts to a bitmap format using tools like\u00a0<code>font2py</code>\u00a0and then use them in your project:</li> </ol> <pre><code>python\nCopy\n\n`# After converting a font using font2pyimport my_converted_font\nfrom writer import Writer\ndefinit_custom_font(oled):    font_writer = Writer(oled, my_converted_font)return font_writer`\n</code></pre> <ol> <li>Creating Bitmap Fonts</li> </ol> <pre><code># Define a simple bitmap font\nDIGIT_FONT ={'0':[[0,1,1,0],[1,0,0,1],[1,0,0,1],[0,1,1,0]],\n# # Add more characters...\n}\ndef draw_bitmap_char(oled, char, x, y, scale=1):\n    if char in DIGIT_FONT:\n        bitmap = DIGIT_FONT[char]\n        for y_pos, row in enumerate(bitmap):\n            for x_pos, pixel in enumerate(row):\n                if pixel:\n                    if scale ==1:\n                        oled.pixel(x + x_pos, y + y_pos,1)\n                    else:\n                        oled.fill_rect(x + x_pos*scale, y + y_pos*scale, scale, scale,1)\n</code></pre> <ol> <li>Using the\u00a0<code>micropython-font-to-py</code>\u00a0Tool First, install the tool on your computer:</li> </ol> <p>You will need to go to the Peter Hinch GitHub site and clone the repo</p> <pre><code>git clone https://github.com/peterhinch/micropython-font-to-py.git\n</code></pre> <pre><code>pip install micropython-font-to-py\n</code></pre> <p>Then convert a font:</p> <pre><code>font_to_py.py YourFont.ttf 20 font20.py\n</code></pre> <p>And use it in your code:</p> <pre><code>import font20\nfrom writer import Writer\ndefsetup_font(oled):    font_writer = Writer(oled, font20)    font_writer.set_textpos(0,0)return font_writer\n# Usage\n# writer = setup_font(oled)\n# writer.writeln('Hello World!')\n# oled.show()`\n</code></pre> <p>Important considerations:</p> <ol> <li>Memory constraints - The OLED display and MicroPython device have limited memory, so be mindful of font size</li> <li>Performance - Larger fonts or complex rendering can impact refresh rates</li> <li>Display resolution - The SSD1306 is 128x64 pixels, so ensure fonts are appropriately sized</li> <li>Character set - Consider limiting to necessary characters to save memory</li> </ol> <p>Prompt</p> <p>Please proved detailed steps to use the micropython-font-to-py program to convert both truetype and bitmap fonts to be used with MicroPython on the OLED display</p> <p>Here are steps for converting and using fonts with micropython-font-to-py.</p>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#font-conversion-and-implementation-guide","title":"Font Conversion and Implementation Guide","text":""},{"location":"lessons/50-muntiple-fonts/font-to-py/#1-installation","title":"1.  Installation:","text":"<pre><code>pip install micropython-font-to-py\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#2-font-preparation","title":"2.  Font Preparation:","text":"<ul> <li>For TrueType fonts: Get your .ttf file ready</li> <li>For bitmap fonts: Create a Python module with your bitmap definitions</li> <li>Ensure you have necessary font licenses for usage</li> </ul>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#3-converting-truetype-fonts","title":"3.  Converting TrueType Fonts","text":"<pre><code># Basic conversionfont_to_py.py YourFont.ttf 20 font20.py\n# Fixed-width conversion\nfont_to_py.py -x YourFont.ttf 20 font20.py\n# Include extended ASCII\nfont_to_py.py -x -s YourFont.ttf 20 font20.py\n# Compressed output\nfont_to_py.py -f YourFont.ttf 20 font20.py`\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#4-file-transfer-to-pico","title":"4. File Transfer To Pico","text":"<ul> <li>Transfer both the generated font file (e.g.,\u00a0<code>font20.py</code>) and the\u00a0<code>writer.py</code>\u00a0class to your MicroPython device</li> <li>You can use tools like Thonny IDE or\u00a0<code>ampy</code>\u00a0for file transfer</li> </ul>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#5-implementation","title":"5. Implementation","text":"<ul> <li>Use the code from the artifact above to implement the font rendering</li> <li>Start with small fonts (12-20px) to ensure good performance</li> <li>Test with your specific character set</li> </ul>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"lessons/50-muntiple-fonts/font-to-py/#memory-issues","title":"Memory Issues","text":"<p>The Raspberry Pi Pico is limited to using 264K of RAM.  Fonts can easily use up this memory.</p> <ul> <li> <p>If you get memory errors, try:</p> <ul> <li>Using smaller font sizes</li> <li>Converting fewer characters</li> <li>Using compressed output (-f option)</li> <li>Using fixed-width fonts (-x option)</li> </ul> </li> <li> <p>Performance Issues:</p> </li> <li> <p>If rendering is slow:</p> <ul> <li>Use smaller fonts</li> <li>Reduce update frequency</li> <li>Consider buffering text changes</li> <li>Use fixed-width fonts for faster rendering</li> </ul> </li> <li> <p>Display Issues:</p> </li> <li> <p>If text appears garbled:</p> <ul> <li>Check font orientation</li> <li>Verify display initialization</li> <li>Ensure proper I2C/SPI configuration</li> <li>Verify font file transfer was successful</li> </ul> </li> </ul>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#download-github-code","title":"Download GitHub Code","text":""},{"location":"lessons/50-muntiple-fonts/font-to-py/#1-first-clone-the-repository","title":"1. First, clone the repository:","text":"<pre><code>git clone https://github.com/peterhinch/micropython-font-to-py.git`\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#2-navigate-to-the-directory","title":"2. Navigate to the directory:","text":"<pre><code>cd micropython-font-to-py`\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#3-pillow-library","title":"3. Pillow Library","text":"<p>You'll also need the Python Imaging Library (PIL) installed:</p> <pre><code>pip install pillow`\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#4-move-conversion-tool","title":"4. Move Conversion Tool","text":"<p>The\u00a0<code>font_to_py.py</code>\u00a0script is in this directory. You can either:</p> <ul> <li>Use it directly from this location</li> <li>Copy it to a convenient location in your PATH</li> <li>Make it executable with\u00a0<code>chmod +x font_to_py.py</code></li> </ul>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#5-run-converter","title":"5. Run Converter","text":"<p>Now you can use the tool. For example:</p> <pre><code>python3 font_to_py.py YourFont.ttf 20 font20.py`\n</code></pre> <p>If you want to make the tool generally available on your system:</p> <pre><code># Make executablechmod +x font_to_py.py\n# Optional: Move to a directory in your PATH (e.g., /usr/local/bin)sudocp font_to_py.py /usr/local/bin/font_to_py`\n</code></pre> <p>These examples and explanations should help you understand how fonts work on the OLED display. The first artifact provides a thorough explanation of the concepts, while the second gives you practical code examples to try.</p> <p>Some key points to remember:</p> <ol> <li>Always convert your font files before using them</li> <li>Keep track of your screen position</li> <li>Clear the screen before writing new text</li> <li>Don't forget to call <code>oled.show()</code> to display changes</li> <li>Be mindful of memory usage with large fonts</li> </ol>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#limiting-font-sets","title":"Limiting Font Sets","text":"<p>For most clocks, you will only need the digits 0-9, the colon and the \"A\", \"M\" and \"P\" letters</p> <p>Prompt</p> <p>The Raspberry Pi Pico has 264K or RAM. Will this be a problem if I just use the digits 0-9, a colon and the \"P\" and \"M\" letters?</p> <p>No, using just digits 0-9, a colon, and the letters \"A\" \"M\" and \"P\" (14 characters total) won't cause memory problems on the Raspberry Pi Pico's 264KB of RAM, even with relatively large font sizes. Let me explain why:</p>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#1-memory-requirements-per-character","title":"1. Memory Requirements per Character","text":"<ul> <li>Each character in a bitmap font is essentially a grid of pixels</li> <li>For example, if you use a 32x32 pixel font size:<ul> <li>Each character = 32x32 = 1024 bits = 128 bytes</li> <li>14 characters \u00d7 128 bytes = 1,892 bytes total</li> </ul> </li> <li>Even at 64x64 pixels (very large):<ul> <li>Each character = 64x64 = 4096 bits = 512 bytes</li> <li>14 characters \u00d7 512 bytes = 7,168 bytes</li> </ul> </li> </ul>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#2-oled-frame-buffer-size","title":"2. OLED Frame Buffer Size","text":"<p>The SSD1306 OLED (128x64) buffer takes: - 128 \u00d7 64 = 8,192 bits = 1,024 bytes (1K RAM)</p>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#3-total-memory-impact","title":"3. Total Memory Impact","text":"<ul> <li>Font data: ~1.7KB - 6.7KB (depending on size)</li> <li>OLED buffer: 1KB</li> <li>Writer class and supporting code: ~1KB</li> <li>Total: ~4KB - 9KB</li> </ul> <p>This means:</p> <ul> <li>You're using less than 4% of the Pico's RAM even with very large fonts</li> <li>Plenty of memory remains for your program logic</li> <li>You could even store multiple font sizes if desired</li> </ul>"},{"location":"lessons/50-muntiple-fonts/font-to-py/#helvetica-variable-width","title":"Helvetica Variable Width","text":"<p>Prompt</p> <p>When I display the time \"1:11\" the screen looks odd. Please change the code to use a variable width helvetica font.</p> <p>Yes, with a fixed-width font, the \"1\" digits can look awkwardly spaced. Let's modify the code to use variable-width Helvetica for better visual appearance.</p> <p>The key improvements in this version:</p> <ol> <li>Variable Width Handling:</li> <li>Each digit takes only the space it needs</li> <li>\"1\" is narrower than other digits</li> <li> <p>Spacing looks more natural</p> </li> <li> <p>Hour Format Changes:</p> </li> <li>Hours don't show leading zeros (e.g., \"1:11\" not \"01:11\")</li> <li>Minutes still show leading zeros</li> <li> <p>Looks more like a traditional clock display</p> </li> <li> <p>Dynamic Positioning:</p> </li> <li>Calculates exact width of each character</li> <li>Centers the entire time display properly</li> <li> <p>Adjusts spacing between elements automatically</p> </li> <li> <p>Improved Spacing:</p> </li> <li>Colon spacing adjusted for better visual balance</li> <li>Small gaps added between elements</li> <li>Everything remains centered regardless of digit widths</li> </ol> <p>Would you like me to: 1. Adjust any of the spacing parameters? 2. Add AM/PM display? 3. Test with specific time combinations?</p> <pre><code># Step 1: Convert Helvetica font WITHOUT fixed width\n# python3 font_to_py.py Helvetica.ttf 40 helvetica_40.py\n# Note: Removed the -x flag to allow variable width characters\n\nfrom machine import Pin, SPI\nimport ssd1306\nfrom writer import Writer\nimport helvetica_40  # Your converted font\n\nclass LargeTimeDisplay:\n    def __init__(self):\n        # Initialize SPI and display\n        self.spi = SPI(0, \n                      sck=Pin(2),   # Clock\n                      mosi=Pin(3),  # Data\n                      baudrate=100000)\n\n        # Display pins\n        self.dc = Pin(6)    # Data/Command\n        self.rst = Pin(4)   # Reset\n        self.cs = Pin(5)    # Chip Select\n\n        # Initialize display\n        self.display = ssd1306.SSD1306_SPI(\n            128,    # Width\n            64,     # Height\n            self.spi,\n            self.dc,\n            self.rst,\n            self.cs\n        )\n\n        # Initialize writer with large font\n        self.writer = Writer(self.display, helvetica_40)\n\n    def get_char_width(self, char):\n        \"\"\"Get width of a specific character\"\"\"\n        _, width = helvetica_40.get_ch(char)\n        return width\n\n    def get_string_width(self, text):\n        \"\"\"Calculate total width of a string\"\"\"\n        return sum(self.get_char_width(char) for char in text)\n\n    def draw_colon(self, x, y):\n        \"\"\"Draw a large colon for separating hours and minutes\"\"\"\n        colon_width = 6\n        colon_height = 6\n        spacing = 10\n\n        # Top dot\n        self.display.fill_rect(x, y + 10, colon_width, colon_height, 1)\n        # Bottom dot\n        self.display.fill_rect(x, y + 10 + spacing + colon_height, \n                             colon_width, colon_height, 1)\n\n        return colon_width  # Return width for position calculations\n\n    def show_time(self, hours, minutes):\n        \"\"\"Display time with variable width font\"\"\"\n        # Clear display\n        self.display.fill(0)\n\n        # Format numbers with leading zeros for minutes only\n        hour_str = str(hours)  # No leading zero for hours\n        min_str = f\"{minutes:02d}\"  # Leading zero for minutes\n\n        # Calculate widths\n        hour_width = self.get_string_width(hour_str)\n        min_width = self.get_string_width(min_str)\n        colon_total_width = 16  # Colon width plus spacing\n\n        # Calculate total width\n        total_width = hour_width + colon_total_width + min_width\n\n        # Calculate starting position to center everything\n        start_x = (128 - total_width) // 2\n        start_y = (64 - helvetica_40.height()) // 2\n\n        # Current x position\n        x = start_x\n\n        # Draw hours\n        self.writer.set_textpos(x, start_y)\n        self.writer.printstring(hour_str)\n        x += hour_width + 5  # Move past hours plus small gap\n\n        # Draw colon\n        self.draw_colon(x, start_y)\n        x += colon_total_width - 5  # Move past colon (adjusted for spacing)\n\n        # Draw minutes\n        self.writer.set_textpos(x, start_y)\n        self.writer.printstring(min_str)\n\n        # Update display\n        self.display.show()\n\n# Example usage\nif __name__ == '__main__':\n    # Create display instance\n    time_display = LargeTimeDisplay()\n\n    # Test display with different times\n    from time import sleep\n\n    test_times = [\n        (1, 11),   # Testing narrow digits\n        (11, 11),  # Testing wide number combination\n        (10, 01),  # Testing leading zero\n        (2, 22),   # Testing repeated digits\n    ]\n\n    # Show each test time for 2 seconds\n    for hours, minutes in test_times:\n        time_display.show_time(hours, minutes)\n        sleep(2)\n\n\"\"\"\nKey Changes from Fixed-Width Version:\n1. Removed -x flag from font conversion\n2. Added methods to calculate individual character widths\n3. Dynamically calculate positions based on actual character widths\n4. Adjusted spacing to look better with variable width characters\n5. Removed leading zero from hours for better appearance\n6. Added flexible spacing calculations\n\nNotes on Spacing:\n- Hours: No leading zero, natural width\n- Minutes: Always show leading zero\n- Colon: Centered between hours and minutes\n- Overall: Centered on display\n\"\"\"\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/hevetica-example/","title":"Helvetica Example","text":"<p>This example shows how to use the font-to-python.py program to generate aHelvetica font in a fixed width and variable width version.  Note that the fixed width version is easier to place digits on the display, but the variable width version is more aesthetically pleasing for times such as 11:11.</p>"},{"location":"lessons/50-muntiple-fonts/hevetica-example/#fixed-width-version","title":"Fixed Width Version","text":"<p>Here are the key points about this version</p> <p>The font is converted at 40 pixels high.  This is about the maximum size that will fit on a 128x64 OLED display with four digits and a colon.</p> <p>This allows approximately:</p> <ul> <li>Each digit: ~25-30 pixels wide</li> <li>Total for 4 digits: ~100-120 pixels</li> <li>Colon and spacing: ~8-10 pixels</li> <li>Total width: ~120 pixels (fits within 128 pixel display)</li> <li>Height of 40 pixels (fits within 64 pixel display)</li> </ul> <p>To maximize size while ensuring fit:</p> <ol> <li>Start with 40px height</li> <li>If too large, decrease by 2px until perfect fit</li> <li>If too small, increase by 2px until just before overflow</li> </ol> <pre><code># Step 1: Convert Helvetica font\n# First, download Helvetica.ttf (or use Arial as a free alternative)\n# Then run the conversion tool (assuming 40px height which allows ~128px width for 4 digits + colon):\n#\n# python3 font_to_py.py -x Helvetica.ttf 40 helvetica_40.py\n#\n# The -x flag creates a fixed-width font which is better for digit alignment\n\nfrom machine import Pin, SPI\nimport ssd1306\nfrom writer import Writer\nimport helvetica_40  # Your converted font\n\nclass LargeTimeDisplay:\n    def __init__(self):\n        # Initialize SPI and display\n        self.spi = SPI(0, \n                      sck=Pin(2),   # Clock\n                      mosi=Pin(3),  # Data\n                      baudrate=100000)\n\n        # Display pins\n        self.dc = Pin(6)    # Data/Command\n        self.rst = Pin(4)   # Reset\n        self.cs = Pin(5)    # Chip Select\n\n        # Initialize display\n        self.display = ssd1306.SSD1306_SPI(\n            128,    # Width\n            64,     # Height\n            self.spi,\n            self.dc,\n            self.rst,\n            self.cs\n        )\n\n        # Initialize writer with large font\n        self.writer = Writer(self.display, helvetica_40)\n\n        # Calculate center position (implemented below)\n        self.calculate_positions()\n\n    def calculate_positions(self):\n        \"\"\"Calculate positions for centered time display\"\"\"\n        # Get character width (should be fixed due to -x flag in conversion)\n        dummy_char, char_width = helvetica_40.get_ch('0')\n\n        # Calculate total width (4 digits + colon)\n        total_width = (char_width * 4) + 20  # 20 pixels for colon and spacing\n\n        # Calculate starting x position to center time\n        self.start_x = (128 - total_width) // 2\n\n        # Calculate y position to center vertically\n        self.start_y = (64 - helvetica_40.height()) // 2\n\n        # Store character width for later use\n        self.char_width = char_width\n\n    def draw_colon(self, x, y):\n        \"\"\"Draw a large colon for separating hours and minutes\"\"\"\n        # Draw two rectangles for the colon\n        colon_width = 6\n        colon_height = 6\n        spacing = 10\n\n        # Top dot\n        self.display.fill_rect(x, y + 10, colon_width, colon_height, 1)\n        # Bottom dot\n        self.display.fill_rect(x, y + 10 + spacing + colon_height, \n                             colon_width, colon_height, 1)\n\n    def show_time(self, hours, minutes):\n        \"\"\"Display time in large font\"\"\"\n        # Clear display\n        self.display.fill(0)\n\n        # Format hours and minutes\n        hour_str = f\"{hours:02d}\"\n        min_str = f\"{minutes:02d}\"\n\n        # Current x position for drawing\n        x = self.start_x\n\n        # Draw hours\n        self.writer.set_textpos(x, self.start_y)\n        self.writer.printstring(hour_str)\n\n        # Draw colon\n        x += self.char_width * 2 + 5  # Move past hours\n        self.draw_colon(x, self.start_y)\n\n        # Draw minutes\n        x += 15  # Move past colon\n        self.writer.set_textpos(x, self.start_y)\n        self.writer.printstring(min_str)\n\n        # Update display\n        self.display.show()\n\n# Example usage\nif __name__ == '__main__':\n    # Create display instance\n    time_display = LargeTimeDisplay()\n\n    # Test display with different times\n    from time import sleep\n\n    test_times = [\n        (12, 30),\n        (1, 15),\n        (5, 45),\n        (10, 20),\n    ]\n\n    # Show each test time for 2 seconds\n    for hours, minutes in test_times:\n        time_display.show_time(hours, minutes)\n        sleep(2)\n</code></pre>"},{"location":"lessons/50-muntiple-fonts/hevetica-example/#variable-width-version","title":"Variable Width Version","text":"<p>Here are the key changes from the Fixed-Width Version:</p> <ol> <li>Removed -x flag from font conversion which allows variable width characters</li> <li>Added methods to calculate individual character widths</li> <li>Dynamically calculate positions based on actual character widths</li> <li>Adjusted spacing to look better with variable width characters</li> <li>Removed leading zero from hours for better appearance</li> <li>Added flexible spacing calculations</li> </ol> <p>Notes on Spacing: - Hours: No leading zero, natural width - Minutes: Always show leading zero - Colon: Centered between hours and minutes - Overall: Centered on display</p> <p>This allows approximately:</p> <pre><code>from machine import Pin, SPI\nimport ssd1306\nfrom writer import Writer\nimport helvetica_40  # Your converted font\n\nclass LargeTimeDisplay:\n    def __init__(self):\n        # Initialize SPI and display\n        self.spi = SPI(0, \n                      sck=Pin(2),   # Clock\n                      mosi=Pin(3),  # Data\n                      baudrate=100000)\n\n        # Display pins\n        self.dc = Pin(6)    # Data/Command\n        self.rst = Pin(4)   # Reset\n        self.cs = Pin(5)    # Chip Select\n\n        # Initialize display\n        self.display = ssd1306.SSD1306_SPI(\n            128,    # Width\n            64,     # Height\n            self.spi,\n            self.dc,\n            self.rst,\n            self.cs\n        )\n\n        # Initialize writer with large font\n        self.writer = Writer(self.display, helvetica_40)\n\n    def get_char_width(self, char):\n        \"\"\"Get width of a specific character\"\"\"\n        _, width = helvetica_40.get_ch(char)\n        return width\n\n    def get_string_width(self, text):\n        \"\"\"Calculate total width of a string\"\"\"\n        return sum(self.get_char_width(char) for char in text)\n\n    def draw_colon(self, x, y):\n        \"\"\"Draw a large colon for separating hours and minutes\"\"\"\n        colon_width = 6\n        colon_height = 6\n        spacing = 10\n\n        # Top dot\n        self.display.fill_rect(x, y + 10, colon_width, colon_height, 1)\n        # Bottom dot\n        self.display.fill_rect(x, y + 10 + spacing + colon_height, \n                             colon_width, colon_height, 1)\n\n        return colon_width  # Return width for position calculations\n\n    def show_time(self, hours, minutes):\n        \"\"\"Display time with variable width font\"\"\"\n        # Clear display\n        self.display.fill(0)\n\n        # Format numbers with leading zeros for minutes only\n        hour_str = str(hours)  # No leading zero for hours\n        min_str = f\"{minutes:02d}\"  # Leading zero for minutes\n\n        # Calculate widths\n        hour_width = self.get_string_width(hour_str)\n        min_width = self.get_string_width(min_str)\n        colon_total_width = 16  # Colon width plus spacing\n\n        # Calculate total width\n        total_width = hour_width + colon_total_width + min_width\n\n        # Calculate starting position to center everything\n        start_x = (128 - total_width) // 2\n        start_y = (64 - helvetica_40.height()) // 2\n\n        # Current x position\n        x = start_x\n\n        # Draw hours\n        self.writer.set_textpos(x, start_y)\n        self.writer.printstring(hour_str)\n        x += hour_width + 5  # Move past hours plus small gap\n\n        # Draw colon\n        self.draw_colon(x, start_y)\n        x += colon_total_width - 5  # Move past colon (adjusted for spacing)\n\n        # Draw minutes\n        self.writer.set_textpos(x, start_y)\n        self.writer.printstring(min_str)\n\n        # Update display\n        self.display.show()\n\n# Example usage\nif __name__ == '__main__':\n    # Create display instance\n    time_display = LargeTimeDisplay()\n\n    # Test display with different times\n    from time import sleep\n\n    test_times = [\n        (1, 11),   # Testing narrow digits\n        (11, 11),  # Testing wide number combination\n        (10, 01),  # Testing leading zero\n        (2, 22),   # Testing repeated digits\n    ]\n\n    # Show each test time for 2 seconds\n    for hours, minutes in test_times:\n        time_display.show_time(hours, minutes)\n        sleep(2)\n</code></pre>"},{"location":"lessons/55-shift-registers/","title":"Shift Registers","text":""},{"location":"lessons/55-shift-registers/#sample-prompt","title":"Sample Prompt","text":"<p>Prompt</p> <p>Please create a detailed tutorial about using shift registers that would be understood by a 9th grade high school student.  Assume that the student already knows about using the Raspberry Pi Pico to turn on and off LEDs,but does not have enough output pins to drive all 4 digits on a seven-segment display clock. Suggest where figures should be added and what the figures should contain.  Discuss the 74HC595 chip, what its inputs and outputs are and what some basic MicroPython code would look like to turn on and off some LEDs controlled by the 74HC595.  Return the tutorial in markdown format.</p>"},{"location":"lessons/55-shift-registers/#sample-response","title":"Sample Response","text":""},{"location":"lessons/55-shift-registers/#using-shift-registers-to-control-more-leds-with-your-pico","title":"Using Shift Registers to Control More LEDs with Your Pico","text":"<p>Have you ever wanted to build a digital clock but ran out of pins on your Raspberry Pi Pico? A shift register can help! Think of a shift register like a magical helper that turns a few Pico pins into many output pins. Let's learn how to use one!</p> <p></p>"},{"location":"lessons/55-shift-registers/#what-is-a-shift-register","title":"What is a Shift Register?","text":"<p>A shift register is like a row of eight boxes that can each hold either a 1 (on) or 0 (off). The cool part is that you can control all eight outputs using just three pins from your Pico! The 74HC595 is a popular and easy-to-use shift register.</p>"},{"location":"lessons/55-shift-registers/#the-important-pins-on-the-74hc595","title":"The Important Pins on the 74HC595","text":"<ul> <li>Data Pin (DS or SER IN): This is where you send your 1s and 0s, one at a time</li> <li>Clock Pin (SRCLK): Each time this pin gets a pulse, it shifts all the data one position</li> <li>Latch Pin (STCP or RCLK): When pulsed, this updates all outputs at once</li> <li>Output Pins (Q0-Q7): These eight pins connect to your LEDs</li> <li>Power (VCC): Connect to 3.3V</li> <li>Ground (GND): Connect to ground</li> </ul>"},{"location":"lessons/55-shift-registers/#detailed-pin-descriptions","title":"Detailed Pin Descriptions","text":""},{"location":"lessons/55-shift-registers/#srclk","title":"SRCLK","text":"<p>Shift Register Clock or Input Clock  - A digital input signal that controls the shifting of data through a serial-to-parallel register by generating a transition from low to high voltage level. </p> <p>Example: Pulsing SRCLK from 0V to 3.3V causes each bit to move one position in the shift register.</p>"},{"location":"lessons/55-shift-registers/#rclk","title":"RCLK","text":"<p>Register Clock or Latch Pin A digital input signal that transfers the contents of the shift register to the storage register by generating a transition from low to high voltage level. </p> <p>Example: Pulsing RCLK from 0V to 3.3V updates all output pins simultaneously with new values.  The term \"latch pin\" is more descriptive of its function (it \"latches\" or locks in the data), while RCLK is the technical abbreviation used in datasheets. On the 74HC595 chip, this is pin 12, and it's also sometimes labeled as STCP (STorage Clock Pulse).</p>"},{"location":"lessons/55-shift-registers/#wiring-it-up","title":"Wiring It Up","text":"<p>[Figure 3: Show a wiring diagram with:</p> <ul> <li>A Pico</li> <li>A 74HC595</li> <li>Several LEDs with their resistors</li> <li>The connections between them]</li> </ul> <p>Here's how to connect everything:</p> <ol> <li>Connect VCC to 3.3V on the Pico</li> <li>Connect GND to ground</li> <li>Connect Data DS to GPIO 16</li> <li>Connect Clock (SRCLK) to GPIO 17</li> <li>Connect Latch (RCLK) to GPIO 18</li> <li>Connect LEDs with resistors to outputs Q0-Q7</li> </ol>"},{"location":"lessons/55-shift-registers/#the-code","title":"The Code","text":"<p>Here's some simple MicroPython code to control your LEDs:</p> <pre><code>from machine import Pin\nfrom utime import sleep\n\n# Set up our Pico pins\ndata_pin = Pin(16, Pin.OUT)\nclock_pin = Pin(17, Pin.OUT)\nlatch_pin = Pin(18, Pin.OUT)\n\ndef shift_byte(byte_val):\n    # Send each bit one at a time\n    for i in range(8):\n        # Get the current bit (0 or 1)\n        bit = (byte_val &gt;&gt; (7-i)) &amp; 1\n\n        # Set the data pin\n        data_pin.value(bit)\n\n        # Pulse the clock\n        clock_pin.value(1)\n        clock_pin.value(0)\n\n    # Pulse the latch to show the new pattern\n    latch_pin.value(1)\n    latch_pin.value(0)\n\n# Example: Light up alternate LEDs\nwhile True:\n    shift_byte(0b10101010)  # Turn on LEDs 7,5,3,1\n    sleep(1)\n    shift_byte(0b01010101)  # Turn on LEDs 6,4,2,0\n    sleep(1)\n</code></pre>"},{"location":"lessons/55-shift-registers/#how-it-works","title":"How It Works","text":"<p>[Figure 4: Show an animation or series of diagrams demonstrating how data shifts through the register]</p> <ol> <li>The <code>shift_byte</code> function takes a number between 0 and 255</li> <li>It converts this number into eight separate bits (1s and 0s)</li> <li>For each bit:</li> <li>It puts the bit on the data pin</li> <li>Pulses the clock to shift it in</li> <li>After all 8 bits are sent, it pulses the latch to update all LEDs at once</li> </ol>"},{"location":"lessons/55-shift-registers/#using-multiple-shift-registers","title":"Using Multiple Shift Registers","text":"<p>[Figure 5: Show how to chain two 74HC595s together]</p> <p>Need even more outputs? You can chain shift registers together! Connect the Q7' (serial out) pin of the first shift register to the DS (data) pin of the second one. They'll share the same clock and latch pins.</p>"},{"location":"lessons/55-shift-registers/#practice-project-binary-counter","title":"Practice Project: Binary Counter","text":"<p>Try this: Make a program that counts from 0 to 255, showing each number in binary on your LEDs. Here's a starter:</p> <pre><code>for number in range(256):\n    shift_byte(number)\n    sleep(0.1)  # Wait a bit between numbers\n</code></pre> <p>This will help you understand how binary numbers work while practicing with your shift register!</p>"},{"location":"lessons/55-shift-registers/#common-problems-and-solutions","title":"Common Problems and Solutions","text":"<ol> <li>LEDs not lighting up? </li> <li>Check your connections</li> <li>Make sure your LEDs have resistors</li> <li> <p>Verify your ground connections</p> </li> <li> <p>Random LED patterns?</p> </li> <li>Make sure your clock and latch pulses are complete</li> <li>Check if your data is sending in the right order</li> </ol>"},{"location":"lessons/55-shift-registers/#next-steps","title":"Next Steps","text":"<p>Once you're comfortable with this, you can: 1. Control a 4-digit display for your clock 2. Make LED light patterns 3. Build a binary game 4. Create a VU meter for music</p> <p>Remember: A shift register is just a tool to help you control more things with fewer pins. With practice, you'll find lots of cool ways to use it in your projects!</p> <p>[Note: All figures should be clear, well-labeled, and include captions explaining what they show. Consider using color coding for different types of connections (power, data, ground) in the diagrams.]</p>"},{"location":"lessons/55-shift-registers/#example-74hc595","title":"Example: 74HC595","text":""},{"location":"lessons/55-shift-registers/#references","title":"References","text":"<ul> <li>Shift Registers on Wikipedia</li> <li>Nice Animation of Shift Registers by Last Minute Engineering</li> </ul>"},{"location":"lessons/60-sound/","title":"Adding Sound to Your Clock","text":""},{"location":"lessons/60-sound/#why-add-sound","title":"Why Add Sound","text":""},{"location":"lessons/60-sound/#feedback-when-setting-time","title":"Feedback When Setting Time","text":"<p>Using sounds allows you to use low-cost momentary push buttons that don't have a clear \"clink\" when pressed.</p>"},{"location":"lessons/60-sound/#alarm-clock-sounds","title":"Alarm Clock Sounds","text":""},{"location":"lessons/60-sound/#timers-and-reminders","title":"Timers and Reminders","text":""},{"location":"lessons/60-sound/#adding-a-speaker","title":"Adding a Speaker","text":""},{"location":"lessons/60-sound/#generating-simple-sounds-with-pwm","title":"Generating Simple Sounds with PWM","text":"<p>Play a Tune with PWM</p>"},{"location":"lessons/60-sound/#using-a-digital-to-analog-converter","title":"Using a Digital to Analog Converter","text":""},{"location":"lessons/60-sound/#references","title":"References","text":"<p>Prof. Albrecht Schmidt Wiki</p>"},{"location":"lessons/60-sound/play-tune/","title":"Play a Tune Using PWM","text":"<p>Below is an example MicroPython program that uses the provided note frequencies and plays the Mario melody on a PWM pin (GPIO 16 in this example). You can adjust timing and duty cycle to get the sound you want. Simply copy this code onto your MicroPython device (e.g., Raspberry Pi Pico running MicroPython) and run it.</p> <pre><code>from machine import Pin, PWM\nfrom utime import sleep\n\n# Initialize speaker on GPIO16\nspeaker = PWM(Pin(16))\n\n# Define the tone (note) frequency dictionary\ntones = {\n    \"B0\": 31,\"C1\": 33,\"CS1\": 35,\"D1\": 37,\"DS1\": 39,\"E1\": 41,\"F1\": 44,\"FS1\": 46,\n    \"G1\": 49,\"GS1\": 52,\"A1\": 55,\"AS1\": 58,\"B1\": 62,\"C2\": 65,\n    \"CS2\": 69,\"D2\": 73,\"DS2\": 78,\"E2\": 82,\"F2\": 87,\"FS2\": 93,\"G2\": 98,\n    \"GS2\": 104,\"A2\": 110,\"AS2\": 117,\"B2\": 123,\"C3\": 131,\"CS3\": 139,\n    \"D3\": 147,\"DS3\": 156,\"E3\": 165,\"F3\": 175,\"FS3\": 185,\n    \"G3\": 196,\"GS3\": 208,\"A3\": 220,\"AS3\": 233,\"B3\": 247,\"C4\": 262,\"CS4\": 277,\"D4\": 294,\"DS4\": 311,\n    \"E4\": 330,\"F4\": 349,\"FS4\": 370,\"G4\": 392,\"GS4\": 415,\"A4\": 440,\"AS4\": 466,\"B4\": 494,\"C5\": 523,\"CS5\": 554,\"D5\": 587,\"DS5\": 622,\"E5\": 659,\"F5\": 698,\n    \"FS5\": 740,\"G5\": 784,\"GS5\": 831,\"A5\": 880,\"AS5\": 932,\"B5\": 988,\"C6\": 1047,\"CS6\": 1109,\"D6\": 1175,\"DS6\": 1245,\"E6\": 1319,\"F6\": 1397,\"FS6\": 1480,\"G6\": 1568,\"GS6\": 1661,\n    \"A6\": 1760,\"AS6\": 1865,\"B6\": 1976,\"C7\": 2093,\"CS7\": 2217,\"D7\": 2349,\"DS7\": 2489,\"E7\": 2637,\"F7\": 2794,\"FS7\": 2960,\"G7\": 3136,\"GS7\": 3322,\"A7\": 3520,\n    \"AS7\": 3729,\"B7\": 3951,\"C8\": 4186,\"CS8\": 4435,\"D8\": 4699,\"DS8\": 4978\n}\n\n# Mario melody notes\nmario = [\n    \"E7\", \"E7\", 0, \"E7\", 0, \"C7\", \"E7\", 0, \"G7\", 0, 0, 0, \"G6\", 0, 0, 0,\n    \"C7\", 0, 0, \"G6\", 0, 0, \"E6\", 0, 0, \"A6\", 0, \"B6\", 0, \"AS6\", \"A6\", 0,\n    \"G6\", \"E7\", 0, \"G7\", \"A7\", 0, \"F7\", \"G7\", 0, \"E7\", 0, \"C7\", \"D7\", \"B6\", 0, 0,\n    \"C7\", 0, 0, \"G6\", 0, 0, \"E6\", 0, 0, \"A6\", 0, \"B6\", 0, \"AS6\", \"A6\", 0,\n    \"G6\", \"E7\", 0, \"G7\", \"A7\", 0, \"F7\", \"G7\", 0, \"E7\", 0, \"C7\", \"D7\", \"B6\", 0, 0\n]\n\ndef play_tone(note, duration=0.15):\n    \"\"\"\n    Plays a single tone for the specified duration.\n    If note is 0, it is treated as a rest (no sound).\n    Adjust durations as needed for the best result.\n    \"\"\"\n    if note == 0:\n        # Rest (no sound)\n        speaker.duty_u16(0)\n        sleep(duration)\n    else:\n        # Play the specified note\n        freq = tones[note]\n        speaker.freq(freq)\n        # Set a duty cycle (volume), 0 to 65535\n        speaker.duty_u16(30000)\n        sleep(duration)\n        # Turn the sound off between notes\n        speaker.duty_u16(0)\n        sleep(0.05)\n\n# Play the entire Mario melody\nfor n in mario:\n    play_tone(n)\n\n# Turn speaker off at the end\n# Note that the note still plays on stop/interrupt!\nspeaker.duty_u16(0)\n</code></pre>"},{"location":"lessons/60-sound/play-tune/#adjust-the-tempo","title":"Adjust the Tempo","text":"<pre><code>duration=0.15\n</code></pre>"},{"location":"lessons/60-sound/play-tune/#adding-interrupt-handling","title":"Adding Interrupt Handling","text":"<pre><code># Main execution\ntry:\n    print(\"Playing Mario theme...\")\n    play_mario()\n    # Clean up\n    speaker.deinit()\n    print(\"Done!\")\nexcept KeyboardInterrupt:\n    # Clean up if interrupted\n    speaker.deinit()\n    print(\"\\nStopped by user\")\n</code></pre> <pre><code>from machine import Pin, PWM\nfrom utime import sleep_ms\n\n# Initialize speaker on GPIO 16\nspeaker = PWM(Pin(16))\n\n# Note frequencies in Hz\ntones = {\n    \"B0\": 31, \"C1\": 33, \"CS1\": 35, \"D1\": 37, \"DS1\": 39, \"E1\": 41, \"F1\": 44, \"FS1\": 46,\n    \"G1\": 49, \"GS1\": 52, \"A1\": 55, \"AS1\": 58, \"B1\": 62, \"C2\": 65,\n    \"CS2\": 69, \"D2\": 73, \"DS2\": 78, \"E2\": 82, \"F2\": 87, \"FS2\": 93, \"G2\": 98,\n    \"GS2\": 104, \"A2\": 110, \"AS2\": 117, \"B2\": 123, \"C3\": 131, \"CS3\": 139,\n    \"D3\": 147, \"DS3\": 156, \"E3\": 165, \"F3\": 175, \"FS3\": 185,\n    \"G3\": 196, \"GS3\": 208, \"A3\": 220, \"AS3\": 233, \"B3\": 247, \"C4\": 262, \"CS4\": 277, \"D4\": 294, \"DS4\": 311,\n    \"E4\": 330, \"F4\": 349, \"FS4\": 370, \"G4\": 392, \"GS4\": 415, \"A4\": 440, \"AS4\": 466, \"B4\": 494, \"C5\": 523, \"CS5\": 554, \"D5\": 587, \"DS5\": 622, \"E5\": 659, \"F5\": 698,\n    \"FS5\": 740, \"G5\": 784, \"GS5\": 831, \"A5\": 880, \"AS5\": 932, \"B5\": 988, \"C6\": 1047, \"CS6\": 1109, \"D6\": 1175, \"DS6\": 1245, \"E6\": 1319, \"F6\": 1397, \"FS6\": 1480, \"G6\": 1568, \"GS6\": 1661,\n    \"A6\": 1760, \"AS6\": 1865, \"B6\": 1976, \"C7\": 2093, \"CS7\": 2217, \"D7\": 2349, \"DS7\": 2489, \"E7\": 2637, \"F7\": 2794, \"FS7\": 2960, \"G7\": 3136, \"GS7\": 3322, \"A7\": 3520,\n    \"AS7\": 3729, \"B7\": 3951, \"C8\": 4186, \"CS8\": 4435, \"D8\": 4699, \"DS8\": 4978\n}\n\nmario = [\"E7\", \"E7\", 0, \"E7\", 0, \"C7\", \"E7\", 0, \"G7\", 0, 0, 0, \"G6\", 0, 0, 0, \"C7\", 0, 0, \"G6\",\n         0, 0, \"E6\", 0, 0, \"A6\", 0, \"B6\", 0, \"AS6\", \"A6\", 0, \"G6\", \"E7\", 0, \"G7\", \"A7\", 0, \"F7\", \"G7\",\n         0, \"E7\", 0, \"C7\", \"D7\", \"B6\", 0, 0, \"C7\", 0, 0, \"G6\", 0, 0, \"E6\", 0, 0, \"A6\", 0, \"B6\", 0,\n         \"AS6\", \"A6\", 0, \"G6\", \"E7\", 0, \"G7\", \"A7\", 0, \"F7\", \"G7\", 0, \"E7\", 0, \"C7\", \"D7\", \"B6\", 0, 0]\n\ndef play_tone(frequency, duration=100):\n    \"\"\"Play a tone at the given frequency for the specified duration\"\"\"\n    if frequency &gt; 0:\n        speaker.freq(frequency)  # Set frequency\n        speaker.duty_u16(32768)  # 50% duty cycle (32768 is half of 65535)\n        sleep_ms(duration)\n        speaker.duty_u16(0)     # Turn off tone\n    else:\n        sleep_ms(duration)      # Rest for the specified duration\n\ndef play_mario():\n    \"\"\"Play the Mario theme song\"\"\"\n    # Tempo control\n    tempo = 150  # Adjust this value to control speed (lower = faster)\n\n    # Play each note\n    for note in mario:\n        if note == 0:\n            # Rest\n            play_tone(0, tempo)\n        else:\n            # Play the note\n            play_tone(tones[note], tempo)\n\n        # Brief pause between notes to separate them\n        sleep_ms(50)\n\n# Main execution\ntry:\n    print(\"Playing Mario theme...\")\n    play_mario()\n    # Clean up\n    speaker.deinit()\n    print(\"Done!\")\nexcept KeyboardInterrupt:\n    # Clean up if interrupted\n    speaker.deinit()\n    print(\"\\nStopped by user\")\n</code></pre>"},{"location":"lessons/70-power/","title":"Powering Your Clocks and Watches","text":""},{"location":"lessons/70-power/#powering-your-raspberry-pi-pico","title":"Powering Your Raspberry Pi Pico","text":"<p>Understanding how VSYS works and how VSYS is different from VBUS.</p> <p>Using 3.3 volts for your displays and peripherals</p>"},{"location":"lessons/70-power/#wall-power-vs-portability","title":"Wall Power vs. Portability","text":""},{"location":"lessons/70-power/#backup-power-when-power-fails","title":"Backup Power When Power Fails","text":""},{"location":"lessons/70-power/#coin-cells-for-real-time-clocks","title":"Coin Cells for Real-time Clocks","text":""},{"location":"lessons/70-power/#usb-power","title":"USB Power","text":""},{"location":"lessons/70-power/#aa-battery-packs","title":"AA Battery Packs","text":""},{"location":"lessons/70-power/#usb-battery-packs","title":"USB Battery Packs","text":""},{"location":"lessons/70-power/#lipo-batteries","title":"LiPo Batteries","text":""},{"location":"lessons/70-power/#lipo-battery","title":"LiPo Battery","text":""},{"location":"lessons/digital-to-analog-converters/","title":"Digital to Analog Converters and the I2S Protocol","text":""},{"location":"lessons/digital-to-analog-converters/#the-pcm5102-dac-board","title":"The PCM5102 DAC Board","text":""},{"location":"lessons/digital-to-analog-converters/#connections","title":"Connections","text":"<p>Hooking the up PCM5102 board is pretty easy for the general case:</p> <ul> <li>SCK \u2013 Gnd</li> <li>BCK \u2013 I2S bit clock pin</li> <li>DIN \u2013 I2S data pin</li> <li>LCK \u2013 I2S word select pin</li> <li>GND \u2013 Gnd</li> <li>VIN \u2013 3.3V</li> </ul>"},{"location":"lessons/digital-to-analog-converters/#pico-connections","title":"Pico Connections","text":"<p>Use the lower right connections</p> <ul> <li>SCK_PIN = 16 # Connect to BCK on DAC (Bit Clock)</li> <li>WS_PIN = 17 #  Connect to LCK on DAC (Word Select/Left-Right Clock)</li> <li>SD_PIN = 18 # Connect to DIN on DAC (Data Input) I2S_ID = 0 BUFFER_LENGTH_IN_BYTES = 2000</li> </ul>"},{"location":"lessons/digital-to-analog-converters/#sampling-rates","title":"Sampling Rates","text":"<p>We can also lower sample rates. The PCM5102A supports the following standard sample rates:</p> <ul> <li>8000 Hz (telephone quality)</li> <li>16000 Hz (decent speech quality)</li> <li>22050 Hz (half of CD quality)</li> <li>32000 Hz (digital radio quality)</li> <li>44100 Hz (CD quality)</li> <li>48000 Hz (professional audio)</li> <li>88200 Hz (high resolution)</li> <li>96000 Hz (high resolution)</li> </ul>"},{"location":"lessons/digital-to-analog-converters/#references","title":"References","text":"<p>Todbot Blog: Cheap stereo line out I2S DAC</p>"},{"location":"lessons/digital-to-analog-converters/code/","title":"Using a DAC to Generate Sounds","text":"<pre><code>from machine import Pin, I2S\nimport struct\nimport math\nfrom utime import sleep_ms, ticks_ms, ticks_diff\n\n# Pin Definitions\nBCK_PIN = 16      # Connect to BCK on DAC (Bit Clock)\nWS_PIN = 17       # Connect to LCK on DAC (Word Select)\nSD_PIN = 18       # Connect to DIN on DAC (Data Input)\n\n# Audio parameters\nSAMPLE_RATE = 16000\nBUFFER_SIZE = 512  # Larger buffer for smoother playback\n\n# Note frequencies\nNOTES = {\n    'C4': 261.63,\n    'D4': 293.66,\n    'E4': 329.63,\n    'F4': 349.23,\n    'G4': 392.00,\n    'A4': 440.00,\n    'B4': 493.88,\n    'C5': 523.25,\n    'REST': 0\n}\n\n# Simple melody: each tuple contains (note_name, duration_ms)\nMELODY = [\n    ('C4', 300), ('E4', 300), ('G4', 300),  # Ascending arpeggio\n    ('C5', 600),                            # Hold high note\n    ('G4', 200), ('E4', 200), ('C4', 600),  # Descending\n    ('REST', 300),                          # Pause\n    ('G4', 300), ('F4', 300), ('E4', 300),  # Walking down\n    ('D4', 300), ('C4', 600),               # End phrase\n]\n\ndef apply_envelope(value, i, buffer_size, attack_samples=100, release_samples=100):\n    \"\"\"Apply attack and release envelope to reduce clicks and pops\"\"\"\n    if i &lt; attack_samples:\n        return value * (i / attack_samples)\n    elif i &gt; buffer_size - release_samples:\n        return value * ((buffer_size - i) / release_samples)\n    return value\n\ndef make_tone_buffer(frequency):\n    \"\"\"Create a buffer with complete cycles of the sine wave\"\"\"\n    if frequency == 0:  # For REST\n        return bytearray(BUFFER_SIZE * 2)\n\n    # Calculate samples for complete cycles\n    samples_per_cycle = SAMPLE_RATE / frequency\n    num_cycles = max(1, int(BUFFER_SIZE / samples_per_cycle))\n    adjusted_buffer_size = int(num_cycles * samples_per_cycle)\n    if adjusted_buffer_size &gt; BUFFER_SIZE:\n        adjusted_buffer_size = BUFFER_SIZE\n\n    buffer = bytearray(adjusted_buffer_size * 2)\n\n    # Generate a smoother waveform\n    amplitude = 0.15  # Reduced amplitude for cleaner sound\n\n    for i in range(0, adjusted_buffer_size * 2, 2):\n        # Basic sine wave\n        sample_pos = (i // 2) / samples_per_cycle * 2 * math.pi\n        raw_value = math.sin(sample_pos)\n\n        # Apply envelope and amplitude\n        value = int(32767 * amplitude * \n                   apply_envelope(raw_value, i//2, adjusted_buffer_size))\n\n        # Pack into buffer\n        struct.pack_into(\"&lt;h\", buffer, i, value)\n\n    return buffer\n\n# Configure I2S with higher sample precision\naudio_out = I2S(\n    0,\n    sck=Pin(BCK_PIN),\n    ws=Pin(WS_PIN),\n    sd=Pin(SD_PIN),\n    mode=I2S.TX,\n    bits=16,\n    format=I2S.MONO,\n    rate=SAMPLE_RATE,\n    ibuf=2048  # Larger internal buffer\n)\n\nprint(\"Playing melody... Press Ctrl+C to stop\")\n\ntry:\n    while True:\n        for note_name, duration in MELODY:\n            print(f\"\\nPlaying {note_name} for {duration}ms\")\n\n            # Create buffer for this frequency\n            frequency = NOTES[note_name]\n            buffer = make_tone_buffer(frequency)\n\n            # Play the note for specified duration\n            start_time = ticks_ms()\n            while ticks_diff(ticks_ms(), start_time) &lt; duration:\n                audio_out.write(buffer)\n                sleep_ms(10)\n                print(\".\", end=\"\")\n\n            # Longer pause between notes for clearer separation\n            sleep_ms(70)\n\n        # Pause between repetitions\n        sleep_ms(1000)\n\nexcept KeyboardInterrupt:\n    print(\"\\nStopping...\")\nfinally:\n    audio_out.deinit()\n    print(\"Test complete\")\n</code></pre>"},{"location":"lessons/digital-to-analog-converters/prompt/","title":"Prompt","text":"<p>Prompt</p> <p>I need to add sound to my clock.  To do this I purchased the following:</p> <p>Interface I2S PCM5102A DAC Decoder GY-PCM5102 I2S Player Module For Raspberry</p> <p>It has the following edge connections:</p> <p>GND - Connected to GND  V  IN - Connected to 3.3 V LCK - Connected to GPIO 15 D IN - Connected to GPIO 14 BCK - Connected to GPIO 13 SCK - Connected to GPIO 12 LINE OUT - Connected to an 8-ohm speaker</p> <p>Please help me write a MicroPython program for the Raspberry Pi Pico that can help me test this device.</p>"},{"location":"lessons/digital-to-analog-converters/prompt/#response","title":"Response","text":"<p>I'll help you write a MicroPython program to test the I2S DAC module with your Pico. We'll create a simple test that generates a sine wave tone to verify the setup is working correctly.</p> <p>I2S DAC Test Program</p> <p>This program provides a basic test of your I2S DAC setup. Here's how it works:</p> <ol> <li>It configures the I2S interface with the pins you've connected:<ul> <li>GPIO 12 (SCK) for the serial clock</li> <li>GPIO 15 (WS/LCK) for the word select</li> <li>GPIO 14 (SD/DIN) for the serial data</li> </ul> </li> <li>It creates functions to:<ul> <li>Generate sine waves at specific frequencies</li> <li>Play individual tones</li> <li>Run a test sequence of notes (C4, E4, G4, C5)</li> </ul> </li> <li>The test sequence plays each note for 500ms.</li> </ol> <p>To use this program:</p> <ol> <li>Save it to your Pico as <code>main.py</code></li> <li>When you run it, you should hear a sequence of ascending notes through your speaker</li> <li>If you don't hear anything:<ul> <li>Check all your connections</li> <li>Verify your speaker is properly connected to LINE OUT</li> <li>Make sure your power connections (GND and VIN) are secure</li> </ul> </li> </ol> <p>You can modify the <code>test_sequence()</code> function to play different frequencies or durations. For reference, here are some common note frequencies:</p> <pre><code>python\nCopy\n\n`NOTE_FREQUENCIES ={'C4':262,'D4':294,'E4':330,'F4':349,'G4':392,'A4':440,'B4':494,'C5':523}`\n</code></pre> <p>Would you like me to modify the program to include different test patterns or features?</p> <p>CopyRetry</p>"},{"location":"lessons/ntp/","title":"Network Time Protocol (NTP)","text":""},{"location":"lessons/ntp/#part-1-understanding-time-synchronization","title":"Part 1: Understanding Time Synchronization","text":""},{"location":"lessons/ntp/#why-do-we-need-ntp","title":"Why Do We Need NTP?","text":"<ol> <li>Computer clocks tend to drift over time</li> <li>Different devices need to agree on the exact time for:</li> <li>Coordinating events</li> <li>Logging activities</li> <li>Securing network communications</li> <li>Scheduling tasks</li> </ol>"},{"location":"lessons/ntp/#how-ntp-works","title":"How NTP Works","text":""},{"location":"lessons/ntp/#client-server-model","title":"Client-Server Model","text":"<ul> <li>Your device (client) asks specialized time servers (NTP servers) for the current time</li> <li>The server responds with highly accurate time information</li> <li>Your device adjusts its clock accordingly</li> </ul>"},{"location":"lessons/ntp/#time-server-hierarchy","title":"Time Server Hierarchy","text":"<ul> <li>Level 0: Atomic clocks and GPS clocks (Stratum 0)</li> <li>Level 1: Computers directly connected to Level 0 devices</li> <li>Level 2: Computers that get time from Level 1</li> </ul>"},{"location":"lessons/ntp/#part-2-basic-ntp-communication","title":"Part 2: Basic NTP Communication","text":""},{"location":"lessons/ntp/#the-ntp-request-process","title":"The NTP Request Process","text":"<ol> <li>Your device sends a tiny message to an NTP server</li> <li>The server adds its timestamp</li> <li>Your device calculates the time difference, accounting for network delay</li> <li>Your clock gets adjusted</li> </ol>"},{"location":"lessons/ntp/#understanding-time-formats","title":"Understanding Time Formats","text":"<ol> <li>NTP uses seconds since January 1, 1900</li> <li>Modern computers use seconds since:</li> <li>January 1, 1970 (Unix time)</li> <li>January 1, 2000 (Some embedded systems)</li> <li>We need to convert between these formats</li> </ol>"},{"location":"lessons/ntp/sample-ntp-function/","title":"NTP Function","text":"<p>Here is a step-by-step walk though of our NTP function in MicroPython</p>"},{"location":"lessons/ntp/sample-ntp-function/#function-listing","title":"Function Listing","text":"<pre><code># Adapted from official ntptime by Peter Hinch July 2022\n# The main aim is portability:\n# Detects host device's epoch and returns time relative to that.\n# Basic approach to local time: add offset in hours relative to UTC.\n# Timeouts return a time of 0. These happen: caller should check for this.\n# Replace socket timeout with select.poll as per docs:\n# http://docs.micropython.org/en/latest/library/socket.html#socket.socket.settimeout\n\nimport socket\nimport struct\nimport select\nfrom time import gmtime\n\n# (date(2000, 1, 1) - date(1900, 1, 1)).days * 24*60*60\n# (date(1970, 1, 1) - date(1900, 1, 1)).days * 24*60*60\nNTP_DELTA = 3155673600 if gmtime(0)[0] == 2000 else 2208988800\n\n# The NTP host can be configured at runtime by doing: ntptime.host = 'myhost.org'\nhost = \"pool.ntp.org\"\n\ndef time(hrs_offset=0):  # Local time offset in hrs relative to UTC\n    NTP_QUERY = bytearray(48)\n    NTP_QUERY[0] = 0x1B\n    try:\n        addr = socket.getaddrinfo(host, 123)[0][-1]\n    except OSError:\n        return 0\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    poller = select.poll()\n    poller.register(s, select.POLLIN)\n    try:\n        s.sendto(NTP_QUERY, addr)\n        if poller.poll(1000):  # time in milliseconds\n            msg = s.recv(48)\n            val = struct.unpack(\"!I\", msg[40:44])[0]  # Can return 0\n            return max(val - NTP_DELTA + hrs_offset * 3600, 0)\n    except OSError:\n        pass  # LAN error\n    finally:\n        s.close()\n    return 0  # Timeout or LAN error occurred\n</code></pre> <p>Let's break down the key parts of this code.</p> <p><pre><code># Time difference constants\nNTP_DELTA = 3155673600 if gmtime(0)[0] == 2000 else 2208988800\n</code></pre> This line determines which epoch your device uses (2000 or 1970) and sets the correct conversion factor.</p> <p><pre><code># Create the NTP request packet\nNTP_QUERY = bytearray(48)\nNTP_QUERY[0] = 0x1B\n</code></pre> This creates the special message format that NTP servers expect. The <code>0x1B</code> tells the server this is a time request.</p> <p><pre><code># Connect to NTP server\naddr = socket.getaddrinfo(host, 123)[0][-1]\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n</code></pre> This code: 1. Looks up the NTP server address 2. Creates a UDP socket for communication 3. Port 123 is the standard NTP port</p> <p><pre><code># Send request and get response\ns.sendto(NTP_QUERY, addr)\nif poller.poll(1000):  # wait up to 1 second\n    msg = s.recv(48)\n    val = struct.unpack(\"!I\", msg[40:44])[0]\n</code></pre> This section: 1. Sends our time request 2. Waits for up to 1 second for a response 3. Extracts the timestamp from the response</p>"},{"location":"lessons/ntp/sample-ntp-function/#part-4-hands-on-exercise","title":"Part 4: Hands-on Exercise","text":"<p>Let's use this code to synchronize a clock:</p> <ol> <li>Save the code as <code>ntp_sync.py</code></li> <li>Create a simple clock program:</li> </ol> <pre><code>from machine import RTC\nimport ntp_sync\n\ndef sync_time():\n    # Get time with UTC offset for your timezone\n    # Example: -4 for EDT\n    current_time = ntp_sync.time(-4)  \n    if current_time &gt; 0:\n        # Convert to time tuple and set RTC\n        rtc = RTC()\n        rtc.datetime(gmtime(current_time))\n        print(\"Time synchronized!\")\n    else:\n        print(\"Time sync failed\")\n\n# Run the synchronization\nsync_time()\n</code></pre>"},{"location":"lessons/ntp/sample-ntp-function/#part-5-understanding-results","title":"Part 5: Understanding Results","text":"<p>After running the code, you might see: 1. Success: Your device's time is now synchronized 2. Failure: Common causes include:    - No internet connection    - NTP server timeout    - Network restrictions</p> <p>Remember that in real applications, you should: - Handle errors gracefully - Implement periodic resynchronization - Consider time zones and daylight saving time - Add timeout handling for reliability</p>"},{"location":"lessons/ntp/sample-ntp-function/#references","title":"References","text":"<p>[Peter Hinch NTP Function](https://github.com/peterhinch/micropython-samples/blob/master/ntptime/ntptime.py0</p>"},{"location":"lessons/rtc/","title":"Real Time Clocks","text":"<p>The DS3231 is a highly accurate real-time clock (RTC) integrated circuit that maintains precise time using an internal temperature-compensated crystal oscillator (TCXO).  The letters \"DS\" initially were for Dallas Semiconductor,  the name of the company that originally created the chip.</p> <p>Key features:</p> <ul> <li>Accuracy within \u00b12ppm (about 1 minute/year) across -40\u00b0C to +85\u00b0C</li> <li>Battery backup using CR2032 for continuous timekeeping</li> <li>I2C interface operating at 400kHz</li> <li>Built-in temperature sensor (\u00b13\u00b0C accuracy)</li> <li>Two programmable time-of-day alarms</li> </ul> <p>The device stores time data in BCD format across multiple registers:</p> <p>0x00: Seconds 0x01: Minutes 0x02: Hours 0x03: Day 0x04: Date 0x05: Month 0x06: Year</p> <p>Example: Reading hour register 0x02 returns value 0x15 in BCD, representing 15:00 (3:00 PM).</p>"},{"location":"lessons/rtc/#driver","title":"Driver","text":"<p>We will be using the </p>"},{"location":"lessons/rtc/#how-long-will-the-battery-last","title":"How Long Will The Battery Last","text":"<p>The typical operational duration of the backup coin-cell battery in real-time clock circuits ranges from 2 to 10 years, depending on temperature conditions and current draw. </p> <p>The DS3231 RTC module used in our kits draw 3\u03bcA at  room temperature typically operates for 8 years on a single CR2032 battery. The key factors affecting battery life are:</p> <ul> <li>Operating temperature (lower temps extend life)</li> <li>Current draw of the RTC (varies by model)</li> <li>Battery capacity (typical CR2032 = 220mAh)</li> <li>Additional features active (temperature sensing, alarms, etc.)</li> </ul>"},{"location":"lessons/rtc/#references","title":"References","text":"<p>DS3231 Data Sheet on the Analog Devices Website - note that Analog Devices acquired Dallas Semiconductor.</p>"},{"location":"lessons/rtc/13-real-time-clocks/","title":"Real Time Clocks","text":"<p>Note</p> <p>Minimal real-time clock support has only recently been added to the core MicroPython libraries. Make sure you are using the latest release of MicroPython to use the features built into the MicroPython Runtime.</p> <p>See The MicroPython RTC Documentation to make sure you have the right release.</p> <p>Note that the built-in MicroPython library does not setting alarms, turning on and off the oscillator stop flag or accessing the temperature of the RTC (available only on some RTCs like the DS3231).  These functions must be done through a library or by providing your own functions.</p>"},{"location":"lessons/rtc/13-real-time-clocks/#the-ds1307-and-the-ds3231","title":"The DS1307 and the DS3231","text":"<p>Our lessons use two different RTC chips.  Let's do a comparison of these RTC modules and explain their implementation with the MicroPython.</p>"},{"location":"lessons/rtc/13-real-time-clocks/#ds1307","title":"DS1307","text":"<p>This is the original battery-backed real-time clock with I2C interface that maintains basic timekeeping functions introduced by Maxim (then Dallas Semiconductor) around 2004-2005. For example, the DS1307 can be used for tracking hours, minutes, seconds with \u00b12 seconds/day accuracy at C 77\u00b0F (25\u00b0). This is appropriate for room temperature household clocks that have a uniform temperature.  Large swings in temperature change crystal vibration frequency which can impact clock accuracy.</p>"},{"location":"lessons/rtc/13-real-time-clocks/#ds3231","title":"DS3231","text":"<p>This is a newer temperature-compensated real-time clock Released by Maxim Integrated around 2009-2010. With integrated crystal and I2C interface that maintains highly accurate timekeeping under varying conditions.</p> <p>The DS3231 represented a significant advancement in accuracy and temperature compensation over the earlier DS1307. The improved technology helped make the DS3231 the preferred choice for precision timekeeping applications, despite its higher cost. The DS3231m typically maintains an accuracy of \u00b12 seconds each month (not day) across an incredible range of  -40\u00b0F to 185\u00b0F (-40\u00b0C to +85\u00b0C). The DS3231 also has an on-board register you can access to get the current temperature of the device.</p> <p>Key Technical and Financial Differences:</p> <ol> <li> <p>Accuracy:</p> </li> <li> <p>DS1307: \u00b12 seconds/day</p> </li> <li> <p>DS3231: \u00b12 seconds/month due to temperature compensation</p> </li> <li> <p>Temperature Operation:</p> </li> <li> <p>DS1307: 32\u00b0F to 158\u00b0F (0\u00b0C to +70\u00b0C)</p> </li> <li> <p>DS3231: -40\u00b0F to 185\u00b0F (-40\u00b0C to +85\u00b0C) with compensation</p> </li> <li> <p>Clock Output:</p> </li> <li> <p>DS1307: Programmable square wave (1Hz, 4kHz, 8kHz, 32kHz)</p> </li> <li> <p>DS3231: 32kHz output plus programmable square wave</p> </li> <li> <p>Based on typical retail prices as of 2024:</p> </li> <li> <p>DS1307: $1-2 USD</p> </li> <li>DS3231: $3-5 USD</li> </ol>"},{"location":"lessons/rtc/13-real-time-clocks/#implementation-with-micropython","title":"Implementation with MicroPython","text":"<p>The coding for each of these chips in almost identical since they implement the same I2C interface.</p> <pre><code>from machine import I2C, Pin\n\n# Both modules use same I2C interface setup\ni2c = I2C(0, sda=Pin(0), scl=Pin(1))\n\n# DS1307 implementation\nDS1307_ADDR = 0x68\ndef ds1307_get_time():\n    return i2c.readfrom_mem(DS1307_ADDR, 0x00, 7)\n\n# DS3231 implementation\nDS3231_ADDR = 0x68\ndef ds3231_get_time():\n    return i2c.readfrom_mem(DS3231_ADDR, 0x00, 7)\n\n# Both modules store time in BCD format\ndef decode_bcd(bcd):\n    return (bcd &amp; 0xF) + ((bcd &gt;&gt; 4) * 10)\n</code></pre> <p>The code structure remains similar for both modules since they share the I2C interface and address. The DS3231 provides additional registers for temperature data and aging offset, which can be accessed for more precise timekeeping.</p> <p>For classroom use, the DS3231 is recommended due to its superior accuracy and temperature compensation, though it typically costs more than the DS1307.</p>"},{"location":"lessons/rtc/13-real-time-clocks/#detecting-the-rtc-type","title":"Detecting the RTC Type","text":"<p>Both the DS1307 and the DS3231 appear at exactly the same address <code>0x68</code>.  So how can you tell which device you have?  The answer is that the DS3231 has additional status, control and temperature registers we can look for.  If it has these values we know it is the good stuff!</p> <pre><code>from machine import I2C, Pin\nimport time\n\n# I2C setup\ni2c = I2C(0, sda=Pin(0), scl=Pin(1))\n\n# Device addresses\nRTC_ADDR = 0x68  # Both DS1307 and DS3231 use 0x68\n\ndef identify_rtc():\n    \"\"\"\n    Identify whether the RTC is a DS1307 or DS3231\n    Returns: String identifying the RTC type\n    \"\"\"\n    try:\n        # Try to read the status register (0x0F) - only exists on DS3231\n        i2c.writeto(RTC_ADDR, b'\\x0F')\n        status = i2c.readfrom(RTC_ADDR, 1)[0]\n\n        # Try to read control register (0x0E) - only exists on DS3231\n        i2c.writeto(RTC_ADDR, b'\\x0E')\n        control = i2c.readfrom(RTC_ADDR, 1)[0]\n\n        # If we got here, it's almost certainly a DS3231\n        # Try reading temperature registers as final confirmation\n        i2c.writeto(RTC_ADDR, b'\\x11')\n        temp_data = i2c.readfrom(RTC_ADDR, 2)\n\n        return \"DS3231 (Temperature-compensated RTC)\"\n\n    except Exception as e:\n        # If we couldn't read those registers, it's probably a DS1307\n        # Let's verify by trying to read the control register (0x07) of DS1307\n        try:\n            i2c.writeto(RTC_ADDR, b'\\x07')\n            control = i2c.readfrom(RTC_ADDR, 1)[0]\n            return \"DS1307 (Basic RTC)\"\n        except:\n            return \"Unknown RTC device\"\n\ndef main():\n    print(\"\\nRTC Model Identifier\")\n    print(\"-\" * 40)\n\n    # First check if any device is present at RTC address\n    devices = i2c.scan()\n    if RTC_ADDR not in devices:\n        print(f\"No RTC found at address 0x{RTC_ADDR:02X}\")\n        return\n\n    # Identify the RTC\n    rtc_type = identify_rtc()\n    print(f\"Found: {rtc_type}\")\n\n    if \"DS3231\" in rtc_type:\n        # Read temperature for DS3231\n        i2c.writeto(RTC_ADDR, b'\\x11')\n        temp_data = i2c.readfrom(RTC_ADDR, 2)\n        temp_msb = temp_data[0]\n        temp_lsb = (temp_data[1] &gt;&gt; 6) * 25  # 0.25\u00b0C precision\n        temp_c = temp_msb + (temp_lsb / 100.0)\n        temp_f = (temp_c * 9/5) + 32\n        print(f\"Temperature: {temp_c:.2f}\u00b0C ({temp_f:.2f}\u00b0F)\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"lessons/rtc/13-real-time-clocks/#rtcs-and-eeprom","title":"RTCs and EEPROM","text":"<p>Some RTCs also include a small 4K EEPROM to store information such as what time zone you are in and what the clock skew was for the last period.  If your i2c scanner shows something at digital 80 (0x50) when you add your RTC, this is your EEPROM.</p> <p>The device at 80 (0x50) is almost certainly an AT24C32 EEPROM (Electrically Erasable Programmable Read-Only Memory). It's commonly included on DS3231 RTC modules to provide non-volatile storage. This EEPROM can store about 4KB of data and is often used to store configuration settings.</p> <p>You can get a dump of its contents by doing the following detection code:</p> <pre><code>from machine import I2C, Pin\nimport time\n\n# I2C setup\ni2c = I2C(0, sda=Pin(0), scl=Pin(1))\n\n# Device addresses\nDS3231_ADDR = 0x68  # 104 decimal\nEEPROM_ADDR = 0x50  # 80 decimal\n\ndef read_ds3231_temp():\n    \"\"\"Read temperature from DS3231\"\"\"\n    try:\n        # First ensure we're reading fresh temperature data\n        # Write to the control register (0x0E) to force a temperature conversion\n        i2c.writeto(DS3231_ADDR, b'\\x0E\\x20')  # Set CONV bit\n        time.sleep(0.2)  # Wait for conversion\n\n        # Now read temperature registers (0x11 and 0x12)\n        i2c.writeto(DS3231_ADDR, b'\\x11')\n        temp_data = i2c.readfrom(DS3231_ADDR, 2)\n\n        # MSB is the integer part\n        temp_msb = temp_data[0]\n\n        # LSB holds two bits for decimal part\n        temp_lsb = (temp_data[1] &gt;&gt; 6) * 25  # Convert to decimal (0.25\u00b0C precision)\n\n        # Handle negative temperatures (2's complement)\n        if temp_msb &amp; 0x80:\n            temp_msb = -(~(temp_msb - 1) &amp; 0xFF)\n\n        temp_c = temp_msb + (temp_lsb / 100.0)  # Combine integer and decimal parts\n        temp_f = (temp_c * 9/5) + 32\n\n        return temp_c, temp_f\n    except Exception as e:\n        return f\"Error reading temperature: {str(e)}\"\n\ndef read_ds3231_time():\n    \"\"\"Read current time from DS3231\"\"\"\n    try:\n        # Start reading from register 0x00\n        i2c.writeto(DS3231_ADDR, b'\\x00')\n        data = i2c.readfrom(DS3231_ADDR, 7)\n\n        # Convert BCD to decimal\n        def bcd2dec(bcd):\n            return (bcd &amp; 0x0F) + ((bcd &gt;&gt; 4) * 10)\n\n        second = bcd2dec(data[0])\n        minute = bcd2dec(data[1])\n        hour = bcd2dec(data[2])\n        day = bcd2dec(data[4])\n        month = bcd2dec(data[5] &amp; 0x1F)\n        year = bcd2dec(data[6]) + 2000\n\n        return f\"{year:04d}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:02d}\"\n    except Exception as e:\n        return f\"Error reading time: {str(e)}\"\n\ndef read_eeprom(start_addr=0, length=32):\n    \"\"\"Read data from EEPROM\"\"\"\n    try:\n        # Create buffer for address\n        addr_buf = bytearray(2)\n        addr_buf[0] = (start_addr &gt;&gt; 8) &amp; 0xFF  # High byte\n        addr_buf[1] = start_addr &amp; 0xFF         # Low byte\n\n        # Write address to EEPROM\n        i2c.writeto(EEPROM_ADDR, addr_buf)\n\n        # Read data\n        data = i2c.readfrom(EEPROM_ADDR, length)\n        return data\n    except Exception as e:\n        return f\"Error reading EEPROM: {str(e)}\"\n\ndef main():\n    \"\"\"Main program to read and display device information\"\"\"\n    print(\"\\nI2C Device Information Reader\")\n    print(\"-\" * 40)\n\n    # Scan for devices\n    devices = i2c.scan()\n    print(f\"Found devices at addresses: {[hex(x) for x in devices]}\")\n    print(\"-\" * 40)\n\n    # Read and display DS3231 information\n    # Note that the DS1307 does not have any temperature registers\n    if DS3231_ADDR in devices:\n        print(\"DS3231 RTC Information:\")\n        print(f\"Current Time: {read_ds3231_time()}\")\n        temp_c, temp_f = read_ds3231_temp()\n        print(f\"Temperature: {temp_c:.2f}\u00b0C ({temp_f:.2f}\u00b0F)\")\n    else:\n        print(\"DS3231 not found!\")\n\n    print(\"-\" * 40)\n\n    # Read and display EEPROM contents\n    if EEPROM_ADDR in devices:\n        print(\"AT24C32 EEPROM Contents (first 32 bytes):\")\n        eeprom_data = read_eeprom(0, 32)\n\n        # Display as hex\n        print(\"Hex dump:\")\n        for i in range(0, len(eeprom_data), 16):\n            chunk = eeprom_data[i:i+16]\n            hex_values = ' '.join([f'{x:02X}' for x in chunk])\n            ascii_values = ''.join([chr(x) if 32 &lt;= x &lt;= 126 else '.' for x in chunk])\n            print(f\"{i:04X}: {hex_values:&lt;48} {ascii_values}\")\n\n        # Try to interpret as ASCII\n        print(\"\\nASCII interpretation (if printable):\")\n        ascii_text = ''.join([chr(x) if 32 &lt;= x &lt;= 126 else '.' for x in eeprom_data])\n        print(ascii_text)\n    else:\n        print(\"EEPROM not found!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"lessons/rtc/13-real-time-clocks/#results-of-scan-on-rtm-with-eeprom","title":"Results of Scan on RTM with EEPROM","text":"<pre><code>AT24C32 EEPROM Contents (first 32 bytes):\nHex dump:\n0000: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF  ................\n0010: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF  ................\nASCII interpretation (if printable):\n................................\n</code></pre>"},{"location":"lessons/rtc/13-real-time-clocks/#dump-eeprom-address","title":"Dump EEPROM Address","text":"<p>The AT24C32/AT24C64 EEPROM typically is located at 87 (0x57).</p> <p>Here is a script to dump this memory.</p> <pre><code>import time\n\n# I2C setup\ni2c = I2C(0, sda=Pin(0), scl=Pin(1))\n\n# Device addresses\nRTC_ADDR = 0x68  # Both DS1307 and DS3231 use 0x68\n# EEPROM address\nEEPROM_ADDR = 0x57\n\ndef dump_eeprom():\n   # Read first 100 bytes in chunks of 8\n   for addr in range(0, 100, 8):\n       data = i2c.readfrom_mem(EEPROM_ADDR, addr, 8)\n       print(f\"0x{addr:02x}:\", \" \".join([f\"{x:02x}\" for x in data]))\n       time.sleep(0.1)  # Small delay between reads\n\ndump_eeprom()\n</code></pre>"},{"location":"lessons/rtc/13-real-time-clocks/#setting-thr-rtc-from-localtime","title":"Setting thr RTC from localtime","text":"<p>After you get your RTC clock working it is time to set the correct time in the RTC.  You will notice that when the RTC first comes up the date and time will be set to January 1st 2015 at midnight.  We now want to update this time with the time from your local laptop or desktop.  If you use Thonny, the localtime in the Pico is automatically set to the time on computer when Thonny starts up and connects to the Raspberry Pi Pico.</p> <p>Now we just need a small program to take the localtime and write it to the RTC's clock.  Here is tha line:</p> <pre><code>i2c.writeto_mem(DS3231_ADDR, 0x00, data)\n</code></pre> <p>Where data is a binary coded list of binary-coded integers that represent the datetime structure.  Here is an example program called <code>set-rtc-from-localtime.py</code></p> <p>One other note.  The DS3231 has an internal oscillator that can get turned off.  After you set the time it is important to make sure that the oscillator is running correctly again.  The function <code>reset_osf()</code> will clear the stop flag to make sure that the clock is ticking.</p> <pre><code>from machine import Pin, I2C\nfrom utime import localtime\n\n# Constants\nDS3231_ADDR = 0x68\nSTATUS_REG = 0x0F  # Status register address\n\n# I2C setup\nsda = Pin(0, Pin.OUT)\nscl = Pin(1, Pin.OUT)\ni2c = I2C(0, scl=scl, sda=sda, freq=3000000)\n\ndef dec2bcd(dec):\n    \"\"\"Convert decimal to binary coded decimal.\"\"\"\n    return (dec // 10) &lt;&lt; 4 | (dec % 10)\n\ndef check_osf():\n    \"\"\"Check the oscillator stop flag.\"\"\"\n    status = i2c.readfrom_mem(DS3231_ADDR, STATUS_REG, 1)[0]\n    return bool(status &gt;&gt; 7)\n\ndef reset_osf():\n    \"\"\"Clear the oscillator stop flag.\"\"\"\n    status = bytearray(1)\n    i2c.readfrom_mem_into(DS3231_ADDR, STATUS_REG, status)\n    i2c.writeto_mem(DS3231_ADDR, STATUS_REG, bytearray([status[0] &amp; 0x7f]))\n\ndef set_ds3231():\n    \"\"\"Set the DS3231 RTC time and ensure oscillator is running.\"\"\"\n    now = localtime()\n    year = now[0] % 100  # Convert to 2-digit year\n    month = now[1]\n    day = now[2]\n    hour = now[3]\n    minute = now[4]\n    second = now[5]\n\n    # First check if oscillator is stopped\n    if check_osf():\n        print(\"Oscillator was stopped. Resetting OSF flag...\")\n        reset_osf()\n\n    data = bytearray([\n        dec2bcd(second),\n        dec2bcd(minute),\n        dec2bcd(hour),\n        dec2bcd(now[6] + 1),  # Convert weekday from 0-6 to 1-7\n        dec2bcd(day),\n        dec2bcd(month),\n        dec2bcd(year)\n    ])\n\n    i2c.writeto_mem(DS3231_ADDR, 0x00, data)\n    print(f\"RTC set to: {month}/{day}/{now[0]} {hour:02d}:{minute:02d}:{second:02d}\")\n\n    # Verify oscillator is running\n    if check_osf():\n        print(\"Warning: Oscillator still shows stopped state!\")\n    else:\n        print(\"Oscillator running normally\")\n\nif __name__ == \"__main__\":\n    set_ds3231()\n</code></pre>"},{"location":"lessons/rtc/13-real-time-clocks/#bcd-format","title":"BCD Format","text":"<pre><code>def dec2bcd(dec):\n    \"\"\"Convert decimal to binary coded decimal.\"\"\"\n    return (dec // 10) &lt;&lt; 4 | (dec % 10)\n</code></pre> <p>This converts regular numbers to Binary Coded Decimal format that the DS3231 requires. For example, 23 becomes 0x23.</p> <p>BCD (Binary-Coded Decimal) is used in the DS3231 RTC for three main reasons:</p> <ol> <li>Readability - Each digit maps directly to its binary value (e.g., 23 becomes 0x23), making it easier to read register values when debugging.</li> <li>Easy conversion - Converting between BCD and human-readable time formats requires minimal processing, important for simple microcontrollers</li> <li>Historical compatibility - Many early digital clock chips used BCD, and the format persisted in RTC design for consistency</li> </ol> <p>In BCD, each decimal digit (0-9) is stored in 4 bits, with two digits per byte. For example:</p> <p>Decimal 23 \u2192 BCD 0010 0011 Decimal 59 \u2192 BCD 0101 1001</p>"},{"location":"lessons/rtc/13-real-time-clocks/#avoid-the-builtin-machinertc-library","title":"Avoid the Builtin Machine.RTC Library","text":"<p>The machine.RTC() on the Pico uses an internal oscillator that loses time on power loss, unlike the DS3231 which maintains time with its battery backup. The DS3231 is also more accurate (\u00b12ppm vs \u00b110% for the internal RTC).</p> <p>Unless you need absolute minimal components, stick with the DS3231 for better accuracy and battery backup capability.</p> <p>The internal RTC example on the MicroPython RP2 site would work functionally, but would need resetting after each power cycle.</p>"},{"location":"lessons/rtc/13-real-time-clocks/#reading-the-temperature-from-the-ds3231-real-time-clock","title":"Reading the Temperature from the DS3231 Real Time Clock","text":"<p>The math of reading the temperature from the DS3231 is unfortunately rather complicated.  Here are the steps</p> <ol> <li>Strip off the sign bit by doing a Boolean AND with 0x7f</li> <li>If the MSB is set we need to make the temperature negative</li> <li>Then we add the fraction from the LSB</li> <li>Finally, we convert the temperature in C to F</li> </ol> <pre><code>def read_temperature():\n    \"\"\"Read temperature from DS3231 RTC.\"\"\"\n    # Read temperature registers\n    i2c.writeto(DS3231_ADDR, b'\\x11')\n    temp_data = i2c.readfrom(DS3231_ADDR, 2)\n    temp_msb = temp_data[0]\n    temp_lsb = temp_data[1]\n\n    # Get raw temp value (ignoring sign bit)\n    raw_temp = temp_msb &amp; 0x7F  # Strip off sign bit\n\n    # 0xD7 &amp; 0x7F = 0x57 = 87 decimal (original value minus sign bit)\n    # If sign bit was set, make it negative\n    if temp_msb &amp; 0x80:\n        raw_temp = raw_temp ^ 0x7F  # Invert the bits\n        raw_temp = -(raw_temp + 1)  # Two's complement\n\n    # Add fraction from LSB\n    frac = (temp_lsb &gt;&gt; 6) * 0.25\n    temp_c = raw_temp + frac\n\n    # Convert to Fahrenheit\n    temp_f = (temp_c * 9.0 / 5.0) + 32.0\n\n    print(f\"Raw temp (after sign bit removal): {raw_temp}\")\n    print(f\"Temperature: {temp_c}\u00b0C = {temp_f}\u00b0F\")\n\n    return temp_f\n</code></pre>"},{"location":"lessons/rtc/13-rtc-explained/","title":"RTC Explained","text":""},{"location":"lessons/rtc/13-rtc-explained/#explaining-rtc-to-students","title":"Explaining RTC to Students","text":"<p>Prompt</p> <p>You are a friendly and fun science teacher working with a group of high-school  students taking a course called \"Programming Clocks and Watches\".  Today your  lecture is on \"Real time Clocks\" like the old DS1307 and the newer super  accurate DS3231.  Give the full text of a 15-minute lecture before the  hands-on lab and mention where images should be inserted.</p> <p>Hello everyone, and welcome to today's exciting lecture on Real Time Clocks!  In our \"Programming Clocks and Watches\" course, we're going to dive into  the fascinating world of the good old DS1307 used in our classrooms and the new super accurate DS3231.</p> <p>First, let's talk about what a Real Time Clock (RTC) is.  An RTC is a computer chip that keeps track of the current time,  even when the main power is off. It's like a tiny, dedicated clock  inside your electronic devices. RTCs are found in computers,  smartphones, appliances, and many other gadgets that need to keep accurate time.</p> <p>Here is how the DS1307 is typically used in a microcontroller project.</p> <p></p> <p>The DS1307 is one of the most well-known RTCs.  We have a LOT of them lying around the lab. This little chip was first introduced in 2005 and has been widely used in various electronic projects. The DS1307 keeps track of seconds, minutes, hours, days, months, and years. It communicates with the main processor using a protocol called I2C (Inter-Integrated Circuit).</p> <p>Now, let's take a look at how the DS1307 works. It has a built-in crystal oscillator that vibrates at a specific frequency, acting as a precise clock source. The chip counts these oscillations to keep track of time. The DS1307 also has a small amount of battery-backed memory, allowing it to maintain the time even when the main power is off.</p> <p>Speaking of power, the DS1307 uses a small coin cell battery to keep the clock running when the main power is disconnected. This battery can last for several years, ensuring that your device always has the correct time.</p> <p></p> <p>Now, let's move on to the newer and more accurate DS3231. Released in 2011, the DS3231 is known for its incredible precision. It has a temperature-compensated crystal oscillator (TCXO), which means it can maintain accurate timekeeping even when the temperature changes. This is important because temperature fluctuations can affect the frequency of regular crystal oscillators, causing the clock to drift over time.</p> Device Strength Accuracy (PPM) Seconds Drift Per Month Price DS1307 Low Cost \u00b120 \u00b152 $1 DS3231 Accuracy \u00b12 \u00b15 $3 <p>The DS1307 uses a standard crystal oscillator while the DS3231 uses a temperature-compensated crystal oscillator (TCXO), explaining the accuracy difference. How accurate is the DS3231, you might ask? Well, it has a typical accuracy of \u00b12 parts per million (ppm), which translates to a drift of about 1 minute per year! In comparison, the DS1307 has an accuracy of around \u00b120 ppm, which means it can drift by about 10 minutes per year. That's a significant difference!</p> <p>[Insert image of I2C communication]</p> <p>Just like the DS1307, the DS3231 communicates with the main processor using the I2C protocol. It has a simple register-based interface that allows you to read and set the time easily.</p> <p>Now, let's talk about some fun applications of RTCs. One cool project you can build is a digital clock that always displays the correct time, even if it's been unplugged for a while. You can also create a data logger that records temperature, humidity, or other sensor readings along with precise timestamps. The possibilities are endless!</p> <p>In our hands-on lab today, we'll be working with both the DS1307 and the DS3231. You'll learn how to wire them up, set the time, and read the current time using a microcontroller. We'll also explore some practical examples and discuss how to choose the right RTC for your projects.</p> <p>So, get ready to have some fun with Real Time Clocks! Remember, whether you're building a simple clock or a complex data logging system, an RTC is an essential component that keeps everything running on time.</p> <p>Let's head to the lab and start tinkering with these amazing little chips!</p>"},{"location":"lessons/rtc/13-rtc-explained/#testing-the-ds1307-and-ds3232-real-time-clocks","title":"Testing the DS1307 and DS3232 Real Time Clocks","text":""},{"location":"lessons/rtc/13-rtc-explained/#hardware-configuration","title":"Hardware Configuration","text":""},{"location":"lessons/rtc/13-rtc-explained/#ds1307-connections","title":"DS1307 Connections","text":"<ol> <li>CLK - clock</li> <li>DST - Data (incoming to Pico)</li> <li>RST - Reset</li> <li>VCC - must be 5 volts, not 3.2</li> <li>GND - ground</li> </ol> <p>We will use the lower right pins on the Pico so that the display can use the pins in the upper-right corner.</p> <p>These pin assignments are</p> <ol> <li>GP16 - far lower right - CLK</li> <li>GP17 - second from the bottom - DST</li> <li>GP18 - fourth pin up - RST</li> </ol> <p>Contents of config.py</p> <pre><code>CLK_PIN = 16\nDST_PIN = 17\nRST_PIN = 18\n</code></pre>"},{"location":"lessons/rtc/13-rtc-explained/#sample-ds1307-micropython-test-program-for-the-raspberry-pi-pico","title":"Sample DS1307 MicroPython Test Program for the Raspberry Pi Pico","text":"<pre><code>from machine import I2C, Pin\nimport config\n\nCLK_PIN = config.CLK_PIN\nDST_PIN = config.DST_PIN\nDS_PIN = config.DS_PIN\n\nprint(\"Clock on pin:\", CLK_PIN)\nprint(\"Data on pin:\", DST_PIN)\nprint(\"Data Select on pin:\", DS_PIN)\n\ni2c = I2C(0, scl=Pin(CLK_PIN), sda=Pin(DST_PIN), freq=100000)\nscan_result = i2c.scan()\nprint(\"I2C addresses found:\", [hex(device_address) for device_address in scan_result])\n\nif 104 in scan_result:\n    print(\"PASS: DS1307 FOUND\")\nelse:\n    print(\"FAIL: DS1307 NOT FOUND\")\n</code></pre>"},{"location":"lessons/rtc/13-rtc-explained/#sample-test-result","title":"Sample Test Result","text":"<pre><code>Clock on pin: 17\nData on pin: 16\nData Select on pin: 18\nI2C addresses found: ['0x50', '0x68']\nPASS: DS1307 FOUND\n</code></pre>"},{"location":"lessons/rtc/13-rtc-explained/#full-test-of-ds1307","title":"Full Test of DS1307","text":"<pre><code>#!/usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n\"\"\"I2C DS1307 showcase\"\"\"\n\nfrom ds1307 import DS1307\nfrom machine import I2C, Pin\nfrom utime import gmtime, sleep, time\nimport config\nCLK_PIN = config.CLK_PIN\nDST_PIN = config.DST_PIN\nDS_PIN = config.DS_PIN\n\n# DS1307 on 0x68\nI2C_ADDR = 0x68     # DEC 104, HEX 0x68\n\n# define custom I2C interface, default is 'I2C(0)'\n# check the docs of your device for further details and pin infos\n# this are the pins for the Raspberry Pi Pico adapter board\ni2c = I2C(0, scl=Pin(CLK_PIN), sda=Pin(DST_PIN), freq=800000)\nprint(i2c.scan())\nds1307 = DS1307(addr=I2C_ADDR, i2c=i2c)\n\n# get LCD infos/properties\nprint(\"DS1307 is on I2C address 0x{0:02x}\".format(ds1307.addr))\nprint(\"Weekday start is {}\".format(ds1307.weekday_start))\n\n# get the current RTC time\nprint(\"Current RTC time: {}\".format(ds1307.datetime))\n\n# set the RTC time to the current system time\nnow = gmtime(time())\nds1307.datetime = now\n\n# Print the date and time in ISO8601 format: 2023-04-18T21:14:22\nprint(\"Today is {:04d}-{:02d}-{:02d}T{:02d}:{:02d}:{:02d}\".format(\n    ds1307.year, ds1307.month, ds1307.day,\n    ds1307.hour, ds1307.minute, ds1307.second))\n\n# check whether this year is a leap year\nprint(\"Is this year a leap year? {}\".format(ds1307.is_leap_year(ds1307.year)))\n\n# get the day of the year\nprint(\"Today is day {} of {}\".format(\n    ds1307.day_of_year(year=ds1307.year, month=ds1307.month, day=ds1307.day),\n    ds1307.year))\n\n# halt the oscillator\nprint(\"The oscillator is currently active at {}? {}\".format(\n    ds1307.datetime, ds1307.halt))\nprint(\"Halt the oscillator and wait for 5 seconds ...\")\nds1307.halt = True\nsleep(5)\n\nprint(\"Current RTC time: {}\".format(ds1307.datetime))\n\nprint(\"Enable the oscillator and wait for 5 seconds ...\")\nds1307.halt = False\nsleep(5)\nprint(\"Current RTC time: {}\".format(ds1307.datetime))\n</code></pre>"},{"location":"lessons/rtc/13-rtc-explained/#test-result","title":"Test Result","text":"<pre><code>[80, 104]\nDS1307 is on I2C address 0x68\nWeekday start is 0\nCurrent RTC time: (2024, 12, 27, 20, 29, 47, 4, 362)\nToday is 2024-12-27T20:29:51\nIs this year a leap year? True\nToday is day 362 of 2024\nThe oscillator is currently active at (2024, 12, 27, 20, 29, 51, 4, 362)? False\nHalt the oscillator and wait for 5 seconds ...\nCurrent RTC time: (2024, 12, 27, 20, 29, 51, 4, 362)\nEnable the oscillator and wait for 5 seconds ...\nCurrent RTC time: (2024, 12, 27, 20, 29, 56, 4, 362)\n</code></pre>"},{"location":"lessons/rtc/13-rtc-explained/#localtime-and-gmtimetime","title":"Localtime and gmtime(time())","text":"<pre><code>from utime import gmtime, time, localtime\nprint(\"time()\", time())\nprint(\"   localtime()\", localtime())\nprint(\"gmtime(time())\", gmtime(time()))\n</code></pre> <p>Result</p> <p><pre><code>time() 1735332067\n   localtime() (2024, 12, 27, 20, 41, 7, 4, 362)\ngmtime(time()) (2024, 12, 27, 20, 41, 7, 4, 362)\n</code></pre> This code is running on MicroPython on the Raspberry Pi Pico (RP2040) and demonstrates the usage of time-related functions from the <code>utime</code> module. </p> <p>Let's break it down:</p> <ol> <li><code>from utime import gmtime, time, localtime</code>: This line imports the <code>gmtime</code>, <code>time</code>,  and <code>localtime</code> functions from the <code>utime</code> module, which is MicroPython's equivalent of  the <code>time</code> module in standard Python.</li> <li><code>print(\"time()\", time())</code>: This line prints the label \"time()\" followed by the result of calling the <code>time()</code> function. The <code>time()</code> function returns the number of seconds elapsed since the Unix epoch (January 1, 1970, 00:00:00 UTC) as an integer value. In your output, <code>time()</code> returned 1735332067, which represents the current timestamp.</li> <li><code>print(\"   localtime()\", localtime())</code>: This line prints the label \"localtime()\"  followed by the result of calling the <code>localtime()</code> function. The <code>localtime()</code>  function takes no arguments and returns a tuple representing the current local time.  The tuple contains the following elements in order: (year, month, day, hour, minute,  second, weekday, yearday). In your output, <code>localtime()</code> returned <code>(2024, 12, 27, 20, 41, 7, 4, 362)</code>, indicating the current local time on the Raspberry Pi Pico.</li> <li><code>print(\"gmtime(time())\", gmtime(time()))</code>: This line prints the label \"gmtime(time())\" followed by the result of calling the <code>gmtime()</code> function with  the current timestamp obtained from <code>time()</code>. The <code>gmtime()</code> function takes a  timestamp as an argument and returns a tuple representing the corresponding UTC time.  The tuple has the same format as the one returned by <code>localtime()</code>. In your output,  <code>gmtime(time())</code> returned <code>(2024, 12, 27, 20, 41, 7, 4, 362)</code>, which represents the current UTC time.</li> </ol> <p>What does the number that <code>time()</code> returns represent?</p> <p>The number returned by <code>time()</code> represents the number of seconds  that have elapsed since the Unix epoch (January 1, 1970, 00:00:00 UTC).  This value is commonly known as the Unix timestamp or epoch time.  It is a widely used standard for representing points in time and is  independent of time zones.</p> <p>In our example, <code>time()</code> returned 1735332067. This timestamp corresponds to  the date and time shown in the <code>localtime()</code> and <code>gmtime(time())</code> outputs, which is December 27, 2024, at 20:41:07 UTC.</p> <p>The Unix timestamp is a useful representation of time because it allows for  easy arithmetic operations on timestamps and can be converted to human-readable formats using functions like <code>localtime()</code> and <code>gmtime()</code>. It is widely used in  various programming languages and systems for time-related operations.</p> <p>It's important to note that the accuracy and synchronization of the time on the  Raspberry Pi Pico depend on its internal clock and any time synchronization  mechanisms used. Without external time synchronization, the Pico's internal  clock may drift over time, resulting in slight inaccuracies compared to the actual current time.</p>"},{"location":"lessons/rtc/13-rtc-explained/#accuracy-of-the-clock-on-the-raspberry-pi-pico","title":"Accuracy of the Clock on the Raspberry Pi Pico**","text":"<p>The Raspberry Pi Pico does not have a real-time clock (RTC) built into its hardware. Its clock is derived from the internal oscillator, which may be subject to drift and is not highly accurate for long-term timekeeping. The accuracy depends on the quality of the oscillator and the environmental conditions, such as temperature.</p> <ul> <li> <p>Drift: The internal clock is typically accurate to within 1% under normal conditions.</p> </li> <li> <p>Seconds off per day: For a 1% drift:</p> </li> </ul> \\[ 1\\% \\text{ of 24 hours} = 0.01 \\times 24 \\times 3600 \\approx 864 \\, \\text{seconds off per day}. \\] <p>Thus, the clock on the Pico can drift up to \u00b1864 seconds per day without correction.</p> <p>For improved accuracy, you can add an external RTC module to the Pico.</p> <p>Accuracy of the Clock on the DS1307</p> <p>The DS1307 is a low-cost RTC chip widely used in electronics projects. Its accuracy is based on an external 32.768 kHz quartz crystal oscillator, which is sensitive to factors like temperature and crystal quality.     \u2022   Drift: The DS1307 typically drifts by \u00b120 ppm (parts per million) at 25\u00b0C.     \u2022   Seconds off per day: With a drift of 20 ppm:</p> \\[ 20 \\, \\text{ppm} \\times 24 \\times 3600 \\, \\text{seconds} = 1.728 \\, \\text{seconds off per day}. \\] <p>The DS1307 clock may be off by approximately \u00b11.7 seconds per day under ideal conditions.</p> <p>For more accurate timekeeping, consider using a higher-quality RTC like the DS3231, which has a drift of \u00b12 ppm (about \u00b10.17 seconds per day) due to its temperature compensation feature.</p>"},{"location":"lessons/rtc/13-rtc-explained/#references","title":"References","text":"<ul> <li>DS1307 Data Sheet</li> <li>Reference Manual</li> </ul>"},{"location":"lessons/rtc/ds3231/","title":"DS3231 Real-time Clock","text":"<p>The DS3231 is a temperature-compensated real-time clock Released by Maxim Integrated around 2009-2010. With integrated crystal and I2C interface that maintains highly accurate timekeeping under varying conditions.</p> <p>The DS3231 represented a significant advancement in accuracy and temperature compensation over the earlier DS1307. The improved technology helped make the DS3231 the preferred choice for precision timekeeping applications, despite its higher cost. The DS3231m typically maintains an accuracy of \u00b12 seconds each month (not day) across an incredible range of -40\u00b0F to 185\u00b0F (-40\u00b0C to +85\u00b0C). The DS3231 also has an on-board register you can access to get the current temperature of the device.</p>"},{"location":"lessons/rtc/ds3231/#key-technical-and-financial-differences","title":"Key Technical and Financial Differences:","text":"<p>Accuracy - DS1307: \u00b12 seconds/day - DS3231: \u00b12 seconds/month due to temperature compensation</p> <p>Temperature Operation:</p> <ul> <li>DS1307: 32\u00b0F to 158\u00b0F (0\u00b0C to +70\u00b0C)</li> <li>DS3231: -40\u00b0F to 185\u00b0F (-40\u00b0C to +85\u00b0C) with compensation</li> </ul> <p>Clock Output:</p> <ul> <li>DS1307: Programmable square wave (1Hz, 4kHz, 8kHz, 32kHz)</li> <li>DS3231: 32kHz output plus programmable square wave</li> </ul> <p>Typical retail prices as of 2025:</p> <ul> <li>DS1307: $1-2 USD</li> <li>DS3231: $3-5 USD</li> </ul>"},{"location":"lessons/rtc/ds3231/#low-cost","title":"Low Cost","text":"<p>eBay Listing:</p> <p></p> <p>Just 73 cent on AliExpress:</p> <p></p>"},{"location":"lessons/rtc/ds3231/#micropython-drivers","title":"MicroPython Drivers","text":""},{"location":"lessons/rtc/ds3231/#references","title":"References","text":"<ul> <li>Pangopi Driver</li> </ul>"},{"location":"lessons/rtc/testing-the-rtc-type/","title":"Testing the RTC Type","text":"<p>When you order a RTC board, you need to make sure you are getting the correct version.  Sometimes the label on the chip will be visible.  However, they are sometimes hard to read.  In that case we can use software to test the features of the two chips.</p> <ul> <li>DS1307 older with no temperature compensation</li> <li>DS3231 newer with temperature compensation</li> </ul>"},{"location":"lessons/rtc/testing-the-rtc-type/#photos-of-different-rtc-boards","title":"Photos of Different RTC Boards","text":""},{"location":"lessons/rtc/testing-the-rtc-type/#ds1307","title":"DS1307","text":""},{"location":"lessons/rtc/testing-the-rtc-type/#ds3231","title":"DS3231","text":""},{"location":"lessons/rtc/testing-the-rtc-type/#tests","title":"Tests","text":""},{"location":"lessons/rtc/testing-the-rtc-type/#tests-specific-register-patterns-that-are-unique-to-the-ds3231","title":"Tests specific register patterns that are unique to the DS3231:","text":"<ul> <li>Control register bit patterns</li> <li>Status register bit patterns</li> <li>Temperature register behavior</li> </ul>"},{"location":"lessons/rtc/testing-the-rtc-type/#performs-consistency-checks","title":"Performs consistency checks:","text":"<ul> <li>Verifies temperature readings are in valid range (-40\u00b0C to +85\u00b0C)</li> <li>Checks if temperature readings make sense</li> <li>Verifies register bit patterns match datasheet specifications</li> </ul>"},{"location":"lessons/rtc/testing-the-rtc-type/#better-ds1307-detection","title":"Better DS1307 detection:","text":"<pre><code>-   Checks the DS1307's control register pattern\n-   Verifies the register behaves as expected\n</code></pre> <pre><code>from machine import Pin, I2C\nfrom utime import sleep\n\ndef test_ds3231_features(i2c, addr):\n    \"\"\"\n    More thoroughly test if the device is actually a DS3231\n    Returns: (is_ds3231, error_message)\n    \"\"\"\n    try:\n        # Test 1: Check control and status registers with specific masks\n        # DS3231 control register (0x0E) should have bits 6,5,4,2 readable/writable\n        # Other bits should be 0\n        control = i2c.readfrom_mem(addr, 0x0E, 1)[0]\n        if control &amp; 0x83 != 0:  # Bits 7,1,0 should be 0\n            return False, \"Control register pattern doesn't match DS3231\"\n\n        # Test 2: Status register (0x0F) should only have bits 7,3,2,1,0 possibly set\n        status = i2c.readfrom_mem(addr, 0x0F, 1)[0]\n        if status &amp; 0x70 != 0:  # Bits 6,5,4 should be 0\n            return False, \"Status register pattern doesn't match DS3231\"\n\n        # Test 3: Try temperature register consistency check\n        # Read temperature twice with a forced conversion between\n        temp1 = i2c.readfrom_mem(addr, 0x11, 2)\n\n        # Force conversion\n        control |= (1 &lt;&lt; 5)  # Set CONV bit\n        i2c.writeto_mem(addr, 0x0E, bytes([control]))\n        sleep(0.01)  # Wait for conversion\n\n        temp2 = i2c.readfrom_mem(addr, 0x11, 2)\n\n        # The readings should be similar and in a reasonable range (-40\u00b0C to +85\u00b0C)\n        msb1 = temp1[0]\n        msb2 = temp2[0]\n\n        # Check if temperatures are in valid range\n        if abs(msb1) &gt; 85 or abs(msb2) &gt; 85:\n            return False, \"Temperature readings out of valid range\"\n\n        return True, \"DS3231 verified\"\n\n    except Exception as e:\n        return False, f\"Error testing DS3231 features: {str(e)}\"\n\ndef identify_rtc():\n    \"\"\"\n    Identify whether the RTC is a DS1307 or DS3231\n    \"\"\"\n    # Initialize I2C\n    i2c = I2C(0, sda=Pin(8), scl=Pin(9), freq=100000)\n\n    RTC_ADDR = 0x68\n\n    # First check if any device is present\n    devices = i2c.scan()\n    if RTC_ADDR not in devices:\n        return \"No RTC found at address 0x68\"\n\n    # Test for DS3231 features\n    is_ds3231, message = test_ds3231_features(i2c, RTC_ADDR)\n\n    if is_ds3231:\n        # Get temperature if it's really a DS3231\n        try:\n            temp_msb = i2c.readfrom_mem(RTC_ADDR, 0x11, 1)[0]\n            temp_lsb = i2c.readfrom_mem(RTC_ADDR, 0x12, 1)[0] &gt;&gt; 6\n\n            if temp_msb &amp; 0x80:\n                temp_msb = -(~temp_msb &amp; 0x7F) - 1\n\n            temp_c = temp_msb + ((temp_lsb &amp; 0x03) * 0.25)\n            temp_f = (temp_c * 9/5) + 32\n\n            return f\"DS3231 found! Current temperature: {temp_c:.2f}\u00b0C ({temp_f:.2f}\u00b0F)\"\n        except Exception as e:\n            return f\"DS3231 found but error reading temperature: {str(e)}\"\n    else:\n        # Test for DS1307\n        try:\n            # DS1307 has a unique control register at 0x07\n            # It should only have bit 4 (OUT) possibly set\n            control = i2c.readfrom_mem(RTC_ADDR, 0x07, 1)[0]\n            if control &amp; 0xEF == 0:  # All bits except bit 4 should be 0\n                return \"DS1307 found!\"\n            else:\n                return \"Found RTC at 0x68 but cannot definitively identify type\"\n        except:\n            return \"Unknown RTC device type\"\n\ndef main():\n    print(\"\\nRTC Identifier\")\n    print(\"-\" * 40)\n\n    result = identify_rtc()\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"lessons/screen-drawing/01-drawing-coordinates/","title":"Drawing Coordinates","text":"<p>Screen Coordinates Lab on Robot Faces</p>"},{"location":"lessons/screen-drawing/02-display-text/","title":"Display Time and Date in Text","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {} {}, {}\".format(day_name, month_name, now[2], now[0])\n\nwhile(True):\n    now = localtime()\n    # print(now)\n    LCD.fill(LCD.black)    \n    LCD.text(format_time(now), 77, 50, LCD.white)\n    LCD.text(format_date(now), 40, 80, LCD.white)\n    LCD.show()\n    sleep(1)\n</code></pre>"},{"location":"lessons/screen-drawing/03-drawing-face/","title":"Drawing Watch Faces","text":"<p>An analog watch ususally has hands that are drawn from the center to the edge of the display.</p> <p>The lines or marks that indicate the hours are often referred to as \"hour indices\" or \"hour markers.\"</p> <p>The smaller lines that indicate the minutes are called \"minute indices\" or \"minute markers.\"</p> <p>For simple lines, we can use the <code>line(x1,y1, x2,y2,color)</code> function which draws a sinle pixel line from the starting point at (x1,y1) to the end pint at (x2,y2) using the fifth color parameter.  For monochrome clocks the color 1 is whtie and 0 is black.</p> <p>For thinker lines we can use the display.rect() function.</p> <p>Some watches have more complex hands that are composed of  multiple geometries such as triangles.</p> <p>For most modern display drivers we can use the MicroPython poly() function to draw polygons on the screen. These are part of the MicroPython framebuf function.</p> <p>Some older drivers don't yet support these functions, so we might have to craft our own functions.</p>"},{"location":"lessons/screen-drawing/03-drawing-face/#references","title":"References","text":"<p>Instructables on Filled Circles and Triangles by TonyGo2</p>"},{"location":"lessons/screen-drawing/04-larger-fonts/","title":"Larger Fonts","text":"<p>Many display libraries use the MicroPython framebuf standards that only provide for a single font.  This is sometimes fine for simple small displays, but it is sometimes insufficient for some projects where either a smaller or larger font is used.</p> <p>The ssd1306 driver is a good example of the default behaviour of text drawing.  Only a single font is suppied.</p> <pre><code>display.text('Hello, World!', 0, 0, 1)\ndisplay.show()\n</code></pre> <p>Some display drivers allow you to change the default font:</p> <p>LCD160 Set Font</p> <p>Font to Py Command</p> <p>Sample Font Files</p>"},{"location":"lessons/screen-drawing/04-larger-fonts/#references","title":"References","text":"<p>Peter Hinch's Font to Python Utility -  a utility takes input a font file in ttf or otf form together with a height in pixels and outputs a Python source file containing the font as a bitmap.</p> <p>Peter Hinch's Nano GUI</p> <p>Les' Lab: Designing your own Pico fonts - Raspberry Pi Pico display fonts in MicroPython: How to design fonts for your Pi Pico project.</p>"},{"location":"lessons/screen-drawing/05-drawing-polygons/","title":"Drawing Polygons","text":""},{"location":"lessons/screen-drawing/06-draw-performance/","title":"Drawing Performance","text":"<p>One of the challenges we face when updating the watch display is that refreshing an entire screen using a relatively slow SPI interface means that we need to be thoughtful about updating the displays.</p> <p>By default, many screen drivers update every pixel of the screen when the user does a <code>show()</code> operation.  For small monochrome screens this is not usually a problem.  But for larger color screens the draw times can lead to slow updates.</p> <p>Let's do a little math to see when drawing performance becomes a problem.  Remember that the human eye can's really see screen updates that occur faster than about 30 frames per second.  That is why most film movies were filled at 25 frames per second.</p> <p>To calculate the full-screen draw time we need to calculate the total number of bits we need to send and then calculate the time it takes to send these bits.  We can then check our math by looking at timestamps just before we draw and after we finish the drawing.</p> <p>Let's start out with our favorite clock screen: the 128X64 monochrome OLED screen.</p> <ol> <li>Width = 128</li> <li>Height = 64</li> <li>Bits per Pixel = 1</li> </ol> <p>Total bits = 128 * 64 * 1 = 8,192 bits = 1024 bytes</p> <p>Now we need to also know the transfer speed of our display interface.  Although there are both I2C and SPI versions of these displays, we usually prefer the SPI that should transfer data at about </p> <p>Pi Pico SPI LCD using a frame buffer to get 30fps animation - ILI9341 and ST7789 MicroPython drivers</p>"},{"location":"lessons/screen-drawing/06-draw-performance/#sample-timer-code","title":"Sample Timer Code","text":"<p>We can calculate the time to draw the full screen by recording the number of clock ticks in microseconds before and after we do a screen update.</p> <pre><code>from utime import ticks_us\n\nstart = ticks_us()\nscreen_update()\nend = ticks_us()\nprint('Execution time in microseconds:', end - start)\n</code></pre> <p>On the OLED screen, we get a result that is around 10 milliseconds which is 100 screen updates per second.</p>"},{"location":"lessons/screen-drawing/06-draw-performance/#references","title":"References","text":"<ol> <li>Notes on the very slow refresh rate for ST7735 </li> </ol>"},{"location":"lessons/screen-drawing/07-drawing-digits/","title":"Drawing Clock Digits","text":""},{"location":"lessons/screen-drawing/07-drawing-digits/#the-seven-segments-of-a-numeric-digit","title":"The Seven Segments of a Numeric Digit","text":"<p>Since the early history of computing, numeric displays were created using a grouping of seven individual lights to display a single digit.  These are called Seven Segment Displays.  An example is shown in the image below:</p> <p></p> <p>The segments are labeled \"a\" through \"g\" starting at the top and going around in a clockwise direction.  Note that the seventh segment is in the center element is the \"g\" segment.</p> <p>Technically, many displays have an 8th segment for the decimal point (DP).  To keep things simple we will just focus on the main seven segments in this lesson.</p> <p>Clocks also usually have a colon that separates the hours and minutes and an AM/PM indicator for 12-hour displays.  We will be treating these and independent drawing components in this lab.  Many digital clocks have the colon flash on and off every second.</p>"},{"location":"lessons/screen-drawing/07-drawing-digits/#the-segment-map","title":"The Segment Map","text":"<p>To start out, we need to create a \"digit-to-segment map\" data structure. We use this to help us figure out what segments to turn on for any given digit.</p> <p>We will also need to convert the segment letters into integers.  These integers will form the index of an array.</p> <p></p> <p>To write our code, we ask, for any given digit, is the segment on or off?</p> <p>To do this, we can create an array of segments like this:</p> <pre><code>segmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n</code></pre> <p>For any given digit like \"2\" we can then just pass the index of \"2\" to a Python list to get a list of the segments to turn on.  That line of code looks like this:</p> <pre><code>segmentOn = segmentMapping[digit];\n</code></pre> <p>This will return the segments that are to be turned on for any given input digit.  For example:</p> <pre><code>segmentOn = segmentMapping[2];\nprint(segmentOn)\n# returns:\n[1, 1, 0, 1, 1, 0, 1]\n</code></pre> <p>We now have the data structure to do the drawing.  We will do this in two steps.</p> <ol> <li>Draw the three horizontal lines for a digit if they are on</li> <li>Draw all vertical lines for a given digit, keeping in mind that we need to only draw half the way down the digit for the upper left and upper right vertical segments (1 and 5)</li> </ol> <p>We will start out with a simple digit drawing using a single-pixel width line.  Later we will add a parameter to change the thickness of the line.  But we want to take this one-step-at-a-time.</p>"},{"location":"lessons/screen-drawing/07-drawing-digits/#drawing-horizontal-segments","title":"Drawing Horizontal Segments","text":"<p>This sample code will step through the horizontal lines for segments 0, 3 and 6.  It will check using the <code>segmentOn[i]</code> line which will ONLY be true if that segment should be turned on for a given digit.</p> <p>Next, we figure out how high to draw the horizontal line. To do this we will need to figure out the vertical offset (yOffset). The top line (segment 0) has no offset and the bottom line has the full height of the digit.</p> <p>Unlike the vertical lines, the horizontal lines will span the entire width of the area. That makes our code simple because the line will have a horizontal length of exactly the  x plus the width of the digit.</p> <pre><code># reasonable test values for a small display\nx = 10\ny = 10\nwidth = 20\nheight = 30\n# Horizontal segments\n  for i in [0, 3, 6]:\n    # check if this digit has the segment on\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height # bottom element\n      if (i==6):\n          yOffset = height // 2 # bottom\n      # draw a signal thin line\n      oled.line(x, y+yOffset, x + width, y+yOffset, 1)\n</code></pre>"},{"location":"lessons/screen-drawing/07-drawing-digits/#drawing-the-vertical-segments","title":"Drawing the Vertical Segments","text":"<p>Next, we need to create some code to draw the four vertical segments.  This is a little more complex because the lines do NOT span the full height of the digit.</p> <pre><code># Draw Vertical segments\nx = 10\ny = 10\nwidth = 20\nheight = 30\n# Draw the vertical segments ur, lr, ll, ul\nfor i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n        # top two segments\n        if (i==1 or i==5):\n            startY = 0\n            endY = height // 2\n        if (i==2 or i==4):\n            startY = height // 2\n            endY = height\n        # left segments\n        if (i==4 or i==5): xOffset = 0\n        # right segments\n        if (i==1 or i==2): xOffset = width\n        oled.line(x+xOffset, y+startY, x+xOffset, y+endY, 1)\n</code></pre>"},{"location":"lessons/screen-drawing/07-drawing-digits/#testing-our-drawing","title":"Testing Our Drawing","text":"<p>We can now wrap the code above in a <code>drawDigit()</code> function, and we will test each of the digits 0-9 in a small test program.</p> <p>Our first version of drawDigit is modeled after the rect() function. After we pass in the digit, it takes in the (x,y) and width and height parameters and the color value.</p> <p>Draw Digit Function Parameters:</p> <ol> <li>The digit to display - an integer in the range 0-9</li> <li>x of the upper left corner</li> <li>y of the upper left corner</li> <li>the width of the digit (about 20 is a good value)</li> <li>the height of the digit</li> <li>the color (0=black, 1=white)</li> </ol> <p>Here is our testing program that draws digits 0-9 in the center of a standard 128x64 monochrome OLED display:</p> <pre><code># Lab 20: Draw Digits with just the line function\n# this lab uses the line() function to draw the segments\nimport machine\nimport utime\nimport ssd1306\nfrom utime import sleep, localtime\nled = machine.Pin(25, machine.Pin.OUT)\n\nSCL=machine.Pin(2) # SPI CLock\nSDA=machine.Pin(3) # SPI Data\nspi=machine.SPI(0, sck=SCL, mosi=SDA, baudrate=100000)\n\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\nWIDTH = 128\nHEIGHT = 64\n\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n\n\n# x and y are the center of the digit, size is the center to edge\ndef drawDigit(digit, x, y, width, height, color):\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottom, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height # bottom element\n      if (i==6):\n          yOffset = height // 2 # middle line\n      oled.line(x, y+yOffset, x + width, y+yOffset, 1)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n        # top two segments\n        if (i==1 or i==5):\n            startY = 0\n            endY = height // 2\n        if (i==2 or i==4):\n            startY = height // 2\n            endY = height\n        # left segments\n        if (i==4 or i==5): xOffset = 0\n        # right segments\n        if (i==1 or i==2): xOffset = width\n        oled.line(x+xOffset, y+startY, x+xOffset, y+endY, 1)\n\n\noled.fill(0)\noled.text('Lab 12: rect', 0, 0, 1)\nx = 10 # upper left corner x\ny = 10 # upper left corner y\nw = 20 # digit width\nh = 30 # digit height\n\nwhile True:\n    for i in range(0, 10):\n\n        print(i)\n        # create an outline one px away from the drawing region\n        oled.rect(x-2, y-2, w+5, h+5, 1)\n        # draw one digit\n        drawDigit(i, x, y, w, h, 1)\n        # draw a second digit\n        #drawDigit(i, x + w + 4, w, h, t, 1)\n        oled.text(str(i), 0, 54, 1)\n        oled.show()\n        sleep(2)\n        oled.fill(0)\n</code></pre> <p>This <code>drawDigit()</code> is very handy.  We just need to give the function some parameters and it will draw the right digit at a location (x,y) as the upper left corner with the correct width and height!</p> <p>But the lines are somewhat thin.  A more robust implementation will also allow us the change the thickness of the segments. That will be more complex since we will have to adjust the starting point of where we draw each segment based on the thickness of the segment.  We will also need to use a rectangle, not a line.  This requires we figure out the exact width and height before we draw.</p> <p>We explore the line width function in the next lesson.</p>"},{"location":"lessons/screen-drawing/09-digit-functions/","title":"Creating Digit Functions","text":"<p>In the last section, we drew a seven-segment digit number using the line function.  In this section, we will build a better function that will add a flexible new parameter for the thickness of the digit segments.  We will then test the function under a variety of conditions and see how we can make the function easier to use.</p>"},{"location":"lessons/screen-drawing/09-digit-functions/#new-thickness-parameters","title":"New Thickness Parameters","text":"<p>Placing the rectangles correctly within a seven-segment display when we have many drawing parameters requires some precision.  We will use a decomposition process and take \"one step at a time\" to work out the details.</p> <p></p>"},{"location":"lessons/screen-drawing/09-digit-functions/#draw-segment-function","title":"Draw Segment Function","text":"<p>Here is our revised parameters list:</p> <ol> <li>The digit to display - an integer in the range 0-9</li> <li>x of the upper left corner</li> <li>y of the upper left corner</li> <li>the width of the digit (about 20 is a good value)</li> <li>the height of the digit</li> <li>(NEW) the thickness of each segment (3 or 4 are good values)</li> <li>the color (0=black, 1=white)</li> </ol> <p>Here is our revised function for drawing a single digit with the segment thickness added.</p> <pre><code># digit is the number to display\n# x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thickness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thickness, color):\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottom, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thickness # bottom element\n      if (i==6):\n          yOffset = height // 2 - thickness // 2# bottom\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thickness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + height // 2\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thickness\n\n      oled.fill_rect(x+xOffset, startY, thickness, endY-startY, color)\n</code></pre> <p>Let's now take a look at how we had to modify our code.</p> <p>The first item to note is that when we calculate a starting point to draw, we can't just draw at the edge of the region.  We need to back off our initial drawing point by the width of the segment.</p> <p>Here is an example of subtracting the thickness from y when we draw the bottom segment:</p> <pre><code>yOffset = height - thickness # bottom element\n</code></pre> <p></p>"},{"location":"lessons/screen-drawing/09-digit-functions/#full-test-program","title":"Full Test Program","text":"<pre><code># Clock Lab 20: Draw Seven Segments\n# this lab uses the fill_rect function to draw the segments\nimport machine\nimport utime\nimport ssd1306\nfrom utime import sleep, localtime\nled = machine.Pin(25, machine.Pin.OUT)\n\nSCL=machine.Pin(2) # SPI CLock\nSDA=machine.Pin(3) # SPI Data\nspi=machine.SPI(0, sck=SCL, mosi=SDA, baudrate=100000)\n\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n\n# digit is the numer to display\n# x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thickness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thickness, color):\n  # get a list of the segments that are on for this digit\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottom, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thickness # bottom element\n      if (i==6):\n          yOffset = height // 2 - thickness // 2# bottom\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thickness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + height // 2\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thickness\n\n      oled.fill_rect(x+xOffset, startY, thickness, endY-startY, color)\n\noled.fill(0)\noled.text('Lab 12: rect', 0, 0, 1)\nx = 10 # upper left corner x\ny = 10 # upper left corner y\nw = 20 # digit width\nh = 30 # digit height\nt = 3\n\nwhile True:\n    for i in range(0, 10):\n\n        print(i)\n        # create an outline on px away from the drawing region\n        oled.rect(x-2, y-2, w+4, h+4, 1)\n        # draw one digit\n        drawDigit(i, x, y, w, h, t, 1)\n        # draw a second digit\n        #drawDigit(i, x + w + 4, w, h, t, 1)\n        oled.text(str(i), 0, 54, 1)\n        oled.show()\n        sleep(2)\n        oled.fill(0)\n</code></pre>"},{"location":"lessons/screen-drawing/12-draw-time-functions/","title":"Draw a Digital Clock Time Function","text":"<p>In this section, we will create a new function called <code>drawTime</code>.  The input will be the upper left starting point (x,w), width and height, hours and minutes and the format (12-hour or 24-hour) and the color (black or white).</p> <p>This lab will build in the prior lab that displayed a single digit.</p> <p>Let's first of all create a plan of how we will layout our digital clock display.</p> <p>Our goal is to create a function that will be reusable over many types of displays with little or no modification.  This will require us to think through the potential ways our users will use this function and anticipate their needs so they are not tempted to rewrite our code on their own.</p>"},{"location":"lessons/screen-drawing/12-draw-time-functions/#12-hour-display-format","title":"12-Hour Display Format","text":"<p>Here is an example of our 12-hour clock layout:</p> <p></p> <p>Note that there are six horizontal x-dimension numbers and three vertical y-dimension numbers that you can adjust to create a pleasant interface.</p>"},{"location":"lessons/screen-drawing/12-draw-time-functions/#automatically-scaling-the-layout","title":"Automatically Scaling the Layout","text":"<p>It would be tempting to just hard-code the layout using a single set of numbers. But what if the user wanted a smaller or larger portion of their display used to display the time?</p> <p>As the user selects the height and width of their clock we would like to scale these numbers accordingly.  The absolute values of these numbers is not too important now.  We just want to get the relative values down.  To start the process, I did a layout on an 11-inch wide drawing and I assigned the width of each digit to be 3.0.</p> <pre><code># horizontal\nx1 = .73\nx2 = .73\nx3 = 3.0\nx4 = 1.35\nx5 = .5\nx6 = .35\nx7 = 1.5\nx8 = .35\nx9 = .5\n# Vertical\ny1 = 5.31\ny2 = 1.58\ny3 = .68\ny4 = .68\n</code></pre> <p>We need to make the width of the display be x1 + x2 + 3*x3 + x4 + x5 + x6 + x7 which is</p> <pre><code># Scale Test\n\ndef drawTime12h(hour, minute, x, y, width, height):\n    # horizontal\n    x1 = .73\n    x2 = .73\n    x3 = 3.0 # digit width\n    x4 = 1.35\n    x5 = .5\n    x6 = .35\n    x7 = 1.5\n    x8 = .35\n    x9 = .5 # colon width and height\n\n    # vertical\n    y1 = 5.31\n    y2 = 1.58 # to top colon\n    y3 = .68 # between colons\n\n    total_width = x1 + x2 + 3*x3 + x4 + x5 + x6 + x7\n    print(\"total width:\", total_width)\n    total_height = y1\n\n    # calculate the scaling ratios\n    x_scale = width / total_width\n    y_scale = height / total_height \n\n    digit_width = x3 * x_scale\n    digit_height = y1 * y_scale\n    print(\"x scale:\", x_scale, \"y scale:\", y_scale)\n\n    if hour &gt; 12:\n        hour12 = hour - 12\n\n    # hour tens\n    if hour12 &gt; 10:\n        oled.rect(x,y,int(x1*x_scale),int(y1*y_scale))\n\n    # hour ones x,y,w,h\n    drawDigit(hour % 10, int((x + x1 + x2)*x_scale), y, int(x3*x_scale), int(y1*y_scale))\n\n    # minute tens ones digit, x,y,w,h\n    min_tens_x = int((x + x1 + x2 + x3 + x4)*x_scale)\n    drawDigit(minute // 10, min_tens_x, y, int(x3*x_scale), int(y1*y_scale))\n\n    # minute  ones x,y,w,h\n    min_ones_x = int((x + x1 + x2 + 2*x3 + x4 + x5)*x_scale)\n    drawDigit(minute % 10, min_ones_x, y, int(x3*x_scale), int(y1*y_scale))\n\n    # draw colon\n    colon_size = x9\n    # top colon\n    oled.rect(int((x+x1+x2+x3+x8)*x_scale), y+int(y2*y_scale), colon_size, colon_size)\n    # bottom colon\n    oled.rect(int((x+x1+x2+x3+x8)*x_scale), y+int((y2+y3)*y_scale), colon_size, colon_size)\n\n    # AM/PM\n    if hours &lt; 12:\n        am_pm_text = 'am'\n    else:\n        am_pm_text = 'pm'\n    am_pm_x = min_ones_x + int((x3+x6)*x_scale)\n    oled.text(am_pm_text, am_pm_x, y + int(y1*y_scale)) \n\ndrawTime12h(hour, minute, 0, 0, 100, 50)\n</code></pre>"},{"location":"lessons/screen-drawing/15-scale-testing/","title":"Digital Clock Display Scale Testing","text":"<p>We would like to test our digital clock display at a large range of different sizes to make sure our scale functions work.  For example, the function should work over a range of sizes from 20 to 110 pixels wide.</p> <p>Here is a test driver for the drawTime12 function:</p> <pre><code># test times\ntt = [[00,00], [12,59], [12,00], [8,33], [13,59], [23,59]]\n\nwhile True:\n    ## tti is the test time index\n    for tti in range(0,len(tt)):\n        for size in range(20, 110):\n            oled.fill(0) # clear screen\n            # bounding box for the entire screen\n            # oled.rect(0,0, WIDTH-1, HEIGHT-1, 1)\n\n            # bounding box for the time region\n            height = int(size*.5)\n            oled.rect(0, 0, size+20, height+5, 1)\n            # print(\"h=\", tt[tti][0], \"min:\", tt[tti][1])\n            drawTime12h(tt[tti][0], tt[tti][1], 2, 2, size, height, 1)\n            oled.text(str(tt[tti][0]) + ':' + str(tt[tti][1]), 0, 54, 1)\n            oled.show()\n            sleep(.1)\n</code></pre>"},{"location":"lessons/screen-drawing/15-scale-testing/#sample-code","title":"Sample Code","text":"<pre><code># Lab 42: Scale Test test v2\n\nfrom machine import Pin\nfrom time import sleep\nimport ssd1306\nimport config\n\nSCL=Pin(config.SCL_PIN) # SPI CLock\nSDA=Pin(config.SDA_PIN) # SPI Data\n\nRES = Pin(config.RESET_PIN) # Reset\nDC = Pin(config.DC_PIN) # Data/command\nCS = Pin(config.CS_PIN) # Chip Select\nWIDTH = config.WIDTH\nHEIGHT = config.HEIGHT\n\nspi=machine.SPI(config.SPI_BUS, sck=SCL, mosi=SDA, baudrate=100000)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n# digit is the numer to display\n# x and y are upper-left-corner\n# width and height are the dimensions of the digit\n# thickness is the width of the line segments\n# color is 1 for white and 0 for black\ndef drawDigit(digit, x, y, width, height, thickness, color):\n  # get a list of the segments that are on for this digit\n  if digit &gt; 9 or digit &lt; 0:\n      print('Error: digit out of range:', digit)\n      return -1\n  segmentOn = segmentMapping[digit];\n\n  # Draw the horizontal segments: top, bottom, middle\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): # top\n          yOffset = 0 \n      if (i==3):\n          yOffset = height - thickness # bottom element\n      if (i==6):\n          yOffset = height // 2 - thickness // 2# bottom\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      oled.fill_rect(x, y+yOffset, width, thickness, color)\n\n  # Draw the vertical segments ur, lr, ll, ul\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      # upper vertical lines\n      if (i==1 or i==5):\n          startY = y\n          endY = y + height // 2\n      # lower two vertical lines (2=lower right and 4=lower left)\n      if (i==2 or i==4):\n          startY = y + (height // 2)\n          endY = y + height\n      if (i==4 or i==5): xOffset = 0\n      if (i==1 or i==2): xOffset = width-thickness\n\n      oled.fill_rect(x+xOffset, startY, thickness, endY-startY, color)\n\ndef drawTime12h(hour, minute, x, y, width, height, color):\n\n    # this does not scale\n    am_pm_font_height = 8\n\n    # horizontal spacing\n    x1 = .73 # width of the hour tens digit (1 or off)\n    x2 = .25 # space between hour tens and hour ones\n    x3 = 3.0 # digit width\n    x4 = 1.35 # space beteen hour ones and minute tens\n    x5 = .5 # space between minute tens and minute ones\n    x6 = .35 # space between minute ones and am/pm text\n    x7 = 1.5 # an/pm text width\n\n    # colon x positioning\n    x8 = .35 # space between hour ones and colon\n    x9 = .5 # colon width and height\n\n    # vertical\n    y1 = 5.31 # digit height\n    y2 = (y1 // 2) - .1 # to top colon\n    y3 = 1.5 # space between colons\n\n    total_width = x1 + x2 + 3*x3 + x4 + x5 + x6 + x7\n    # print(\"total width:\", total_width)\n    total_height = y1\n\n    # calculate the scaling ratios\n    x_scale = width / total_width\n    y_scale = height / total_height \n\n    digit_width = x3 * x_scale\n    digit_height = y1 * y_scale\n    # print(\"x scale:\", x_scale, \"y scale:\", y_scale)\n\n\n    time_width = total_width * x_scale\n    # print(\"time_width:\", time_width)\n\n    # thickness calculation based on a fraction of the width\n    thickness = int(.25 * digit_width)\n\n    if hour &gt; 12:\n        hour12 = hour - 12\n    else: hour12 = hour\n\n    hour_minute = hour % 10\n    if hour_minute == 0:\n        hour_minute = 2\n\n    # hour tens display \n    if hour12 == 0 or hour12 &gt; 9:\n        oled.fill_rect(x,y,int(x1*x_scale),int(y1*y_scale), color)\n\n    # hour ones for the d, x,y,w,h, t,c\n    if hour12 == 0:\n        hour12 = 12\n    hour_ones_x = int((x + x1 + x2)*x_scale)\n    drawDigit(hour12 % 10, hour_ones_x, y, int(x3*x_scale), int(y1*y_scale), thickness, color)\n\n    # minute tens ones digit, x,y,w,h\n    min_tens_x = int((x + x1 + x2 + x3 + x4)*x_scale)\n    drawDigit(minute // 10, min_tens_x, y, int(x3*x_scale), int(y1*y_scale), thickness, color)\n\n    # minute ones digit d, x,y,w,h, t, c\n    min_ones_x = int((x + x1 + x2 + 2*x3 + x4 + x5)*x_scale)\n    drawDigit(minute % 10, min_ones_x, y, int(x3*x_scale), int(y1*y_scale), thickness, color)\n\n    # draw colon\n    colon_size = int(x9*x_scale)\n    # top colon\n    oled.fill_rect(int((x+x1+x2+x3+x8)*x_scale), y+int(y2*y_scale), colon_size, colon_size, color)\n    # bottom colon\n    oled.fill_rect(int((x+x1+x2+x3+x8)*x_scale), y+int((y2+y3)*y_scale), colon_size, colon_size, color)\n\n    # AM/PM\n    if hour &lt; 12:\n        am_pm_text = 'am'\n    else:\n        am_pm_text = 'pm'\n    # but here.  It displays outside the width\n    am_pm_x = min_ones_x + int((x3+x6)*x_scale)\n    # print('am/pm x:', am_pm_x)\n    oled.text(am_pm_text, am_pm_x, y + int(y1*y_scale) - am_pm_font_height, color)\n\n    oled.show()\n\n# test times\ntt = [[00,00], [12,59], [12,00], [8,33], [13,59], [23,59]]\n\nwhile True:\n    ## tti is the test time index\n    for tti in range(0,len(tt)):\n        for size in range(20, 110):\n            oled.fill(0) # clear screen\n            # bounding box for the entire screen\n            # oled.rect(0,0, WIDTH-1, HEIGHT-1, 1)\n\n            # bounding box for the time region\n            height = int(size*.5)\n            oled.rect(0, 0, size+20, height+5, 1)\n            # print(\"h=\", tt[tti][0], \"min:\", tt[tti][1])\n            drawTime12h(tt[tti][0], tt[tti][1], 2, 2, size, height, 1)\n            oled.text(str(tt[tti][0]) + ':' + str(tt[tti][1]), 0, 54, 1)\n            oled.show()\n            sleep(.1)\n</code></pre>"},{"location":"lessons/screen-drawing/16-drawing-alarm-icon/","title":"Drawing a Scalable Alarm Bell Icon","text":""},{"location":"lessons/screen-drawing/16-drawing-alarm-icon/#sample-prompt","title":"Sample Prompt","text":"<p>Prompt</p> <p>Using the MicroPython poly function, please create a Python function that draws an alarm icon on a 22x24 grid.  The function should have three parameters: x, y and scale where x and y are the upper left corner coordinates.  Just draw the bell body and the clapper.</p> <p>Test the icon at scales from 12 to 36.</p>"},{"location":"lessons/screen-drawing/16-drawing-alarm-icon/#sample-result","title":"Sample Result","text":"<pre><code>from machine import Pin, I2C, SPI\nfrom utime import sleep, localtime\nfrom ds1307 import DS1307\nfrom array import array\n\nimport ssd1306\nimport config\n\nSCL=Pin(config.SPI_SCL_PIN)\nSDA=Pin(config.SPI_SDA_PIN)\nDC = Pin(config.SPI_DC_PIN)\nRES = Pin(config.SPI_RESET_PIN)\nCS = Pin(config.SPI_CS_PIN)\nSPI_BUS = config.SPI_BUS\nWIDTH = config.DISPLAY_WIDTH\nHEIGHT = config.DISPLAY_HEIGHT\n\nspi=SPI(SPI_BUS, sck=SCL, mosi=SDA, baudrate=1000000)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\ni2c_sda = Pin(config.I2C_SDA_PIN)\ni2c_scl = Pin(config.I2C_SCL_PIN)\nI2C_BUS = config.I2C_BUS\nRTC_TYPE = config.RTC_TYPE\nRTC_I2C_ADDR = config.RTC_I2C_ADDR\n\n# I2C setup\ni2c = I2C(I2C_BUS, scl=i2c_scl, sda=i2c_sda, freq=3000000)\nrtc = DS1307(addr=RTC_I2C_ADDR, i2c=i2c)\n\ndef draw_alarm_icon(display, x, y, size=24):\n    \"\"\"\n    Draw an alarm bell icon with time display using polygons.\n\n    Args:\n        display: SSD1306 display instance\n        x, y: Top-left position for the icon\n        size: Base size of the icon (default 24 pixels)\n    \"\"\"\n    # Scale factors\n    scale = size / 24  # Base size is 24 pixels\n\n    # Bell body coordinates (scaled from base design 22 wide and 20 high)\n    bell_body = array('B', [\n        # start at the top right and go 0,4,10,17 and 20 down\n        int(14 * scale), int(0 * scale),    # Top right of dome top row right\n        int(17 * scale), int(4 * scale),    # Top right of dome 2nd row\n        int(19 * scale), int(10 * scale),   # Bottom right curve\n        int(18 * scale), int(16 * scale),   # Right side indent\n        # bottom row\n        int(22 * scale), int(20 * scale),   # Right bottom corner\n        int(0 * scale),  int(20 * scale),   # Bottom left corner\n        # left side\n        int(4 * scale),  int(16 * scale),   # Left up indent\n        int(3 * scale),  int(10 * scale),   # Left up\n        int(5 * scale),  int(4 * scale),    # Top left of dome 2nd row\n        int(8 * scale),  int(0 * scale),    # Top left of dome top row left\n    ])\n\n    # Clapper coordinates\n    clapper = array('B', [\n        int(10 * scale), int(20 * scale),   # Top left\n        int(12 * scale), int(20 * scale),   # Top right\n        int(14 * scale), int(24 * scale),   # Bottom right\n        int(8 * scale), int(24 * scale),   # Bottom left\n    ])\n\n    # Draw the components\n    display.poly(x, y, bell_body, 1, 1)  # Filled bell body\n    display.poly(x, y, clapper, 1, 1)    # Filled clapper\n\ndef demo_alarm_icons(display):\n    \"\"\"\n    Demonstrate the alarm icon at different sizes and positions\n    \"\"\"\n    # Clear the display\n    display.fill(0)\n\n    # Draw three different sized bells\n    draw_alarm_icon(display, 0,  0, size=10)    # Very small bell 10\n    draw_alarm_icon(display, 20, 0, size=14)    # Very small bell 14 \n    draw_alarm_icon(display, 40, 0, size=16)    # Very small bell 16\n    draw_alarm_icon(display, 60, 0, size=20)    # Small bell 20\n    draw_alarm_icon(display, 80, 0, size=24)    # Standard bell 24\n\n    draw_alarm_icon(display, 0,  24, size=28)   # Medium bell 28\n    draw_alarm_icon(display, 30, 24, size=32)   # Medium bell 28\n    draw_alarm_icon(display, 60, 24, size=36)   # Large bell 36\n\n\n    # Update the display\n    display.show()\n\n\ndemo_alarm_icons(oled)\n</code></pre>"},{"location":"prompts/","title":"Prompts","text":"<p>Here is a list of some of the many prompts that we used to generate a learning graph for this course as well as generate content such as lesson plans and sample code.</p> <p>Although we are only listing some of the prompts here, you can use the search function with the \"prompt\" to see many more sample prompts.</p> <p>We believe that great intelligent textbooks not only help you write code, they teach you how to help you effectively use GenAI tools to create better code.</p> <p>Note that most prompts have a \"Copy\" button in the upper right corner of the prompt.  You can use this button to copy the prompt text directly into your generative AI tool.</p> <ul> <li>Course Description</li> <li>Concept Enumeration</li> <li>Concept Dependency</li> <li>Concept Taxonomy</li> <li>Taxonomy Assignments</li> <li>Banner Image</li> <li>FAQ</li> <li>Glossary</li> <li>OLED Test</li> </ul>"},{"location":"prompts/01-course-description/","title":"Generating a Course Description for the Clocks and Watches with AI and MicroPython Course","text":"<p>Prompt</p> <p>Please generate a course description for a 14-week course for high-school students called \"Designing Building Clocks and Watches with AI and MicroPython\".</p> <p>The course is a hands on-course that uses the Raspberry Pi Pico W, low-cost displays, and real-time clocks to create a fun collection of projects for kids learning how to program.</p> <p>We start with a simple clock that uses a LED clock display and then progress to using a web service and an 128x64 OLED graphic display.  We also have demonstrations of building stopwatches and timers by integrating buttons and knobs to adjust settings.</p> <p>An underlying theme is to promote computational thinking including abstraction, decomposition, algorithms and pattern matching.</p> <p>The course provides students with a breadboard, jumper wires, a Raspberry Pi Pico W, LEDs, a SSD1307 128x64 OLED graphical display, buttons, rotery encoders, a DS3231 real-time clock and a speaker.</p> <p>Use the 2001 Bloom Taxonomy to guide the course description.</p>"},{"location":"prompts/01-course-description/#response","title":"Response","text":"<p>Course Title: Designing Building Clocks and Watches with AI and MicroPython Duration: 14 Weeks Appropriate for: High School Students</p> <p>Course Description: In this 14-week, hands-on course, high school students will learn to design and program functional timekeeping devices - from simple LED clocks to sophisticated stopwatches and web-connected displays - using MicroPython on the Raspberry Pi Pico W. Throughout the course, students will be guided by moving from foundational knowledge, and terms to creative invention.</p> <ol> <li>Remember: Students begin by identifying essential electronic components---breadboards, microcontrollers, buttons, knobs, and displays---and recalling the fundamental concepts of MicroPython programming.</li> <li>Understand: Through teacher-led demonstrations, students explore how timing functions, input/output operations, and hardware connections work together to create a basic LED clock. They deepen their grasp of computational thinking by examining concepts like abstraction (focusing on relevant details) and decomposition (breaking large problems into smaller parts).</li> <li>Apply: As their skills grow, students practice wiring and programming a 128\u00d764 OLED display, interfacing with web services to fetch real-time data. They also implement stopwatches and timers, applying algorithms and pattern-matching techniques to manage user inputs and display outputs accurately.</li> <li>Analyze: Learners diagnose and troubleshoot various clock behaviors, studying how code efficiency and hardware choices influence device performance. They dissect timing errors, lag issues, and integration problems, refining both their programming and problem-solving skills.</li> <li>Evaluate: Working in teams, students test multiple clock designs to compare accuracy, power consumption, and user experience. They assess trade-offs---such as display readability vs. complexity---and refine solutions based on feedback, cost, and practicality.</li> <li>Create: Ultimately, students design and assemble their own custom timekeeping projects, combining LEDs, OLED displays, RTCs, push buttons, and rotary encoders. This final challenge showcases their ability to unify hardware and code into a polished, functioning prototype.</li> </ol> <p>By the end of the course, students will have built a diverse collection of digital clocks, stopwatches, and timers while gaining a rich understanding of electronics, computational thinking, and MicroPython. They will leave empowered to continue exploring the world of embedded systems and creative hardware projects.</p>"},{"location":"prompts/02-concept-enumeration/","title":"Concept Enumeration","text":"<p>Prompt</p> <p>You are an expert at generating concept lists for online training courses. Given the course description in the project called 01-course-description.md, please generate a list of the 200 core concepts that need to be covered in this course and the order in which they should be taught.</p> <p>Return numbered list of these core concepts using a single line per concept. For each concept, just return a short concept name and use acronyms or abbreviations when appropriate. They will be used as labels in a graph network. Make sure that the concepts are distinct not duplicated in the list.</p> <p>Use title case for the concept names.</p> <p>Start with the most basic foundational concepts and then proceed to the most complex concepts.</p> <p>Here are some starting concepts</p> <ol> <li>MicroPython</li> <li>Raspberry Pi Pico W</li> <li>Breadboard</li> <li>Powering Your Clocks and Watches</li> <li>USB Power</li> <li>Battery Power</li> <li>Battery Backup</li> <li>Battery Drain Calculation</li> <li>LED Clock Displays</li> <li>Real-time Clock</li> <li>The Thoney IDE</li> <li>Synchronizing time from the PC</li> <li>the localtime function</li> <li>MicroPython Syntax</li> <li>Loops</li> <li>Conditionals</li> <li>Functions</li> <li>Libraries</li> <li>Loading MicroPython Drivers</li> <li>Printing time to the console</li> <li>MicroPython Drawing Libraries</li> <li>Drawing Lines</li> <li>Drawing Text</li> <li>Drawing Pixels</li> <li>Drawing Rectangles</li> <li>Seven Segment Digits</li> <li>Drawing Circles</li> <li>Drawing Ellipses</li> <li>Drawing Arcs</li> <li>Drawing Polygons</li> <li>Changing Fonts</li> <li>Using MicroPython Drivers</li> <li>OLED Displays</li> <li>The Draw_Digit Function</li> <li>SmartWatch Displays</li> <li>Using 16 bits Color</li> <li>Framebuffer</li> <li>SPI Interfaces</li> <li>Updating the Entire Screen with SPI</li> <li>Incremental screen drawing</li> <li>Drawing hands on an analog clock</li> <li>Using the sine and cosine functions</li> <li>Drawing tic marks on a watch face</li> <li>Drawing numbers on a watch face</li> <li>Loading Custom fonts</li> <li>Using Buttons</li> <li>Monitoring Button Presses</li> <li>Writing IRQs for Buttons</li> <li>Debouncing Buttons</li> <li>The Mode Set Button</li> <li>Increment and Decrement buttons</li> <li>Setting Time with Buttons</li> <li>Blinking Digits during set</li> <li>Real time clocks</li> <li>Crystal Vibration Variability</li> <li>The DS3231 real-time clock</li> <li>Lithium Coin Cells</li> <li>Remembering Time During Power Outages</li> <li>Battery Backup</li> <li>Using a Rotary Encoder</li> <li>Setting time with an encoder</li> <li>Playing sound with MicroPython</li> <li>Adding a speaker</li> <li>Using PWM to Play a Tone</li> <li>Changing pitch with PWM</li> <li>Using an Amplifier</li> <li>Using an DAC</li> <li>Storing Sound as a WAV file</li> <li>Comparing Displays</li> <li>NeoPixels (WS2812B) displays</li> <li>E-paper displays</li> <li>The TM1637 Display</li> <li>Shift Register LED Displays</li> <li>The binary display clock</li> <li>The ILI9341 display</li> <li>The ST7735 120x160 color LED display</li> <li>Backlighting</li> <li>The GB9A01 Smartwatch display</li> <li>Adding Accelerometers to a smartwatch</li> <li>Wireless Clocks</li> <li>WiFi on the Pico W</li> <li>Network Time Servers</li> <li>Universal Time</li> <li>Time Zones &amp; UTC Offsets</li> <li>Weather Services</li> <li>Getting Temperature from the DS3231</li> <li>Handling 12-Hour vs. 24-Hour Formats</li> <li>Fast Redraw Techniques (Blitting)</li> <li>Partial Screen Updates for Watch Faces</li> <li>The I2C Bus</li> <li>The SPI Bus</li> <li>Parsing JSON Responses</li> <li>Using the Built-In Filesystem on Pico</li> <li>Logging Time Data to an SD Card</li> <li>Using I\u00b2C Sensors &amp; Modules</li> <li>Menu Systems for Watch Settings</li> <li>Customizing Watch Faces</li> <li>Purchasing Smartwatch Displays</li> <li>Battery Drain Calculation</li> <li>Flicker Reduction Techniques</li> <li>Double Buffering for Smooth Animations</li> </ol>"},{"location":"prompts/02-concept-enumeration/#response","title":"Response","text":"<p>Based on the course description, the example concepts, and the provided course materials, I'll continue the list focusing on additional core concepts that should be covered, ensuring a logical progression from basic to complex topics:</p> <ol> <li>GPIO Pin Configuration</li> <li>Event Handler Implementation</li> <li>Interrupt Handling</li> <li>Power Management Techniques</li> <li>Deep Sleep Mode</li> <li>Timer-Based Events</li> <li>Asynchronous Programming</li> <li>State Machine Design</li> <li>Error Handling And Recovery</li> <li>Watchdog Timer Implementation</li> <li>Daylight Saving Time Adjustments</li> <li>Temperature Sensor Integration</li> <li>Alarm System Design</li> <li>Chronograph Functions</li> <li>Stopwatch Implementation</li> <li>Lap Timer Features</li> <li>Color Animation Effects</li> <li>Color Palette Management</li> <li>Screen Tearing Prevention</li> <li>Memory Management</li> <li>Hardware Documentation</li> <li>Circuit Design Basics</li> <li>Pin Mapping</li> <li>Pull-up Resistor Usage</li> <li>Voltage Level Management</li> <li>Clock Calibration</li> <li>Time Synchronization Methods</li> <li>Multi-timezone Support</li> <li>Date Display Formatting</li> <li>Custom Segment Display Design</li> <li>Animation Frame Timing</li> <li>Touch Input Integration</li> <li>Screen Brightness Control</li> <li>Power Efficient Updates</li> <li>Battery Charging Circuit</li> <li>LiPo Battery Management</li> <li>Real-Time Operating System</li> <li>Task Scheduling</li> <li>Concurrent Operations</li> <li>Data Persistence</li> <li>Configuration Storage</li> <li>Debug Logging</li> <li>Performance Optimization</li> <li>Memory Leakage Prevention</li> <li>Display Driver Architecture</li> <li>Hardware Abstraction Layer</li> <li>Component Interface Design</li> <li>Error Recovery Systems</li> <li>Watch Face Themes</li> <li>User Interface Design</li> <li>Settings Menu Navigation</li> <li>Button Interaction Patterns</li> <li>Encoder Position Tracking</li> <li>Sound Effect Integration</li> <li>Alarm Pattern Design</li> <li>Visual Feedback Systems</li> <li>Power Status Monitoring</li> <li>Low Battery Detection</li> <li>Temperature Compensation</li> <li>Time Drift Correction</li> <li>Network Connection Management</li> <li>API Integration</li> <li>Weather Data Processing</li> <li>JSON Data Handling</li> <li>Binary Time Format</li> <li>Time String Formatting</li> <li>Display Buffer Management</li> <li>Screen Layout Design</li> <li>Font Rendering</li> <li>Anti-Aliasing Techniques</li> <li>Display Contrast Control</li> <li>View Port Management</li> <li>Component Lifecycle</li> <li>Power State Transitions</li> <li>Backup Systems</li> <li>Data Validation</li> <li>Time Zone Conversion</li> <li>Network Time Protocol</li> <li>Real-Time Updates</li> <li>User Preference Storage</li> <li>Animation Framework</li> <li>Touch Event Handling</li> <li>Gesture Recognition</li> <li>Haptic Feedback</li> <li>Audio Feedback</li> <li>Display Power Management</li> <li>Memory Optimization</li> <li>Code Organization</li> <li>Module Architecture</li> <li>Testing Frameworks</li> <li>Debugging Techniques</li> <li>Performance Profiling</li> <li>Power Consumption Analysis</li> <li>Component Integration</li> <li>Interface Protocol Selection</li> <li>Hardware Testing</li> <li>Quality Assurance</li> <li>Project Documentation</li> <li>User Manual Creation</li> </ol> <p>This list builds upon the initial concepts while maintaining a logical progression from fundamental to advanced topics, following the course's computational thinking approach and hands-on learning objectives.</p>"},{"location":"prompts/02-concept-enumeration/#other-lists","title":"Other Lists","text":"<p>MicroPython Raspberry Pi Pico W Breadboard Powering Your Clocks and Watches USB Power Battery Power Battery Backup Battery Drain Calculation LED Clock Displays Real-time Clock (RTC) Overview The Thonny IDE Synchronizing Time from the PC The localtime() Function MicroPython Syntax Loops Conditionals Functions Libraries Loading MicroPython Drivers Printing Time to the Console MicroPython Drawing Libraries Drawing Lines Drawing Text Drawing Pixels Drawing Rectangles Drawing Circles Drawing Ellipses Drawing Arcs Drawing Polygons Changing Fonts Using MicroPython Drivers OLED Displays Smartwatch Displays Using 16 Bits to Represent Color Framebuffer in MicroPython SPI Interfaces Updating the Entire Screen via SPI Incremental Screen Drawing Drawing Hands on an Analog Clock Using math.sin() and math.cos() Drawing Tick Marks on a Watch Face Drawing Numbers on a Watch Face Loading Custom Fonts Using the time Module for Scheduling Using Internal Timers on the Raspberry Pi Pico External RTC Modules (e.g., DS1307, DS3231) Setting the System Clock from an External RTC Network Time Synchronization (NTP) Setting Up Wi\u2011Fi on the Pico W Working with MicroPython\u2019s network Module Parsing JSON (or Other) Time Data from APIs Displaying Date and Day of Week Creating a 7-Segment Style Digital Display Custom Segment-Based Displays Minimizing Power Consumption (Sleep Modes) Waking from Deep Sleep on RTC Alarm Setting Time with Buttons Using Interrupts for Button Input Button Debouncing Techniques Using A Rotary Encoder Setting Alarms with the RTC Connecting Speakers Playing a Sound Sound Encoding Timer-Based Events Playing Chimes Cuckoo Clocks Generating Beep or Alarm Tones Integrating External Sensors Temperature and Humidity Displaying Sensor Data Accelerometers for Orientation Tilt-Based Wake for Watch Display Ultra-Low Power Using E-Paper Displays  Partial Refresh on E-Paper Techniques to Minimize Ghosting on E-Paper Using TFT Displays (e.g., ST7735, ILI9341) Comparing Display Technologies Color Animations on Watch Faces Flicker Reduction Techniques Double Buffering for Smooth Animations Using the micropython-ufont Library Asynchronous Code with uasyncio Time-Based Tasks with uasyncio Handling Concurrency of Time Updates &amp; UI Using a Watchdog Timer for Reliability Logging &amp; Debugging Time Issues Sleep Scheduling Tools for Measuring Battery Usage Hardware Documentation 3D Printing Watch Enclosures Using math Module for Geometry Time Zones &amp; UTC Offsets Daylight Saving Time Using the Built-In Filesystem on Pico Logging Time Data to an SD Card Using I\u00b2C Sensors &amp; Modules Menu Systems for Watch Settings Servo Motors for Mechanical Pointers Converting Between datetime Objects and Timestamps Generating Waveforms for Audio Implementing Clock Themes Fast Redraw Techniques (Blitting) Partial Screen Updates for Watch Faces Color Conversion &amp; Palettes in MicroPython Handling 12-Hour vs. 24-Hour Formats Wi\u2011Fi\u2013Based Weather &amp; Forecast Updates Using Sensors for Step Counting (Pedometer) Adding a LiPo Charging Circuit Chronograph Functionality Timer Stopwatch World Clocks</p>"},{"location":"prompts/03-concept-dependency/","title":"Concept Dependency","text":"<p>Prompt</p> <p>I am creating a course on \"Building Clock and Watches with MicroPython\".</p> <p>The goal of this course is to provide high-school students a fun way to learn computational thinking.</p> <p>I have listed below about 150 concepts taught in this course in a CSV file.  The first column is the ConceptID and the second column is the ConceptLabel.</p> <p>Please create a fully connected concept dependency graph for the concepts in this course.</p> <p>In this step, for each Concept on this list below, create a new list of other concepts on which it depends.  If a concept depends on a specific concept that is not listed, then we will need to add it as a new concept. This will help us determine the teaching order of the Concepts.</p> <p>Return the new list as a CSV file using the following format:</p> <ol> <li>The first column in the CSV file is a numeric concept ID you assigned in the list above.</li> <li>The second column is the concept name.</li> <li>The third column is a pipe-delimited list of the Concept IDs that the concept depends upon.</li> </ol> <p>Check your results to make sure that all concepts are connected to at least one other concept.</p> <p>Foundation Concepts are concepts that have no dependant concepts in this set. Foundation Concepts have an empty third column.</p>"},{"location":"prompts/03-concept-dependency/#result","title":"Result","text":""},{"location":"prompts/04-concept-taxonomy/","title":"Concept Taxonomy","text":"<p>Prompt</p> <p>Given the concepts below, our next step is to create a 10-element taxonomy of these concepts for the book \"Building Clocks and Watches with MicroPython\".</p> <p>Your task is to organize these concepts into a taxonomy by grouping similar Concepts into one of ten categories. Each category should include concepts that share similar characteristics, functions, or applications.</p> <p>Please suggest 10 categories for the taxonomy.  Attempt to create categories that evenly distribute the concepts so that each category has a similar number of concepts in it.</p> <p>Ensure that the categories cover a range of concept types, including abstract ideas, practical applications, common misunderstandings, and real-world examples. Avoid redundancy and ensure that each category is distinct.</p> <p>You can use \"Foundational Concepts\" as your first category. You can use \"Terms and Definitions\" as a second category. You can use \"Example Projects\" as a 10th category.</p>"},{"location":"prompts/04-concept-taxonomy/#chatgpt-o1-response","title":"ChatGPT o1 Response","text":"<p>Thought about taxonomy for course concepts for 2m 17s</p> <p>Below is one possible 10\u2011category taxonomy that groups these 115 concepts into roughly even clusters. Each category highlights a distinct thematic area, from foundational ideas through advanced techniques and ending with example \"capstone\u2011style\" projects. Feel free to adjust or rename categories as needed for your curriculum goals.</p>"},{"location":"prompts/04-concept-taxonomy/#category-1-foundational-concepts","title":"Category 1: Foundational Concepts","text":"<p>These are the most basic building blocks and hardware essentials on which everything else depends.</p> <ol> <li>(0) Timekeeping Components</li> <li>(1) MicroPython</li> <li>(2) Raspberry Pi Pico W</li> <li>(3) Breadboard</li> <li>(4) Power</li> <li>(5) USB Power</li> <li>(6) Battery Power</li> <li>(7) Battery Backup</li> <li>(8) Battery Drain Calculation</li> <li>(10) Real-time Clocks</li> <li>(11) The Thonny IDE</li> <li>(91) Hardware Documentation</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-2-terms-definitions","title":"Category 2: Terms &amp; Definitions","text":"<p>Core programming syntax and \"must-know\" terminology used throughout the course.</p> <ol> <li>(13) The localtime() Function</li> <li>(14) MicroPython Syntax</li> <li>(15) Loops</li> <li>(16) Conditionals</li> <li>(17) Functions</li> <li>(18) Libraries</li> <li>(20) Printing Time to the Console</li> <li>(34) Using 16 Bits to Represent Color</li> <li>(93) Using math Module for Geometry</li> <li>(94) Time Zones &amp; UTC Offsets</li> <li>(95) Daylight Saving Time</li> <li>(101) Converting Between datetime Objects and Timestamps</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-3-displays","title":"Category 3: Displays","text":"<p>An overview of the different display types you might use in clocks/watches.</p> <ol> <li>(9) LED Clock Displays</li> <li>(21) Displays</li> <li>(32) OLED Displays</li> <li>(33) Smartwatch Displays</li> <li>(53) Creating a 7-Segment Style Digital Display</li> <li>(54) Custom Segment-Based Displays</li> <li>(75) Using E-Paper Displays</li> <li>(76) Partial Refresh on E-Paper</li> <li>(77) Techniques to Minimize Ghosting on E-Paper</li> <li>(78) Using TFT Displays (e.g., ST7735, ILI9341)</li> <li>(79) Comparing Display Technologies</li> <li>(103) Implementing Clock Themes</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-4-basic-drawing-font-tools","title":"Category 4: Basic Drawing &amp; Font Tools","text":"<p>Fundamental graphics APIs and driver-loading concepts.</p> <ol> <li>(19) Loading MicroPython Drivers</li> <li>(22) Drawing Lines</li> <li>(23) Drawing Text</li> <li>(24) Drawing Pixels</li> <li>(25) Drawing Rectangles</li> <li>(26) Drawing Circles</li> <li>(27) Drawing Ellipses</li> <li>(28) Drawing Arcs</li> <li>(29) Drawing Polygons</li> <li>(30) Changing Fonts</li> <li>(31) Using MicroPython Drivers</li> <li>(43) Loading Custom Fonts</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-5-advanced-graphics-animations","title":"Category 5: Advanced Graphics &amp; Animations","text":"<p>More complex graphics techniques and math-based rendering.</p> <ol> <li>(35) Framebuffer in MicroPython</li> <li>(39) Drawing Hands on an Analog Clock</li> <li>(40) Using math.sin() and math.cos()</li> <li>(41) Drawing Tick Marks on a Watch Face</li> <li>(42) Drawing Numbers on a Watch Face</li> <li>(80) Color Animations on Watch Faces</li> <li>(81) Flicker Reduction Techniques</li> <li>(82) Double Buffering for Smooth Animations</li> <li>(104) Fast Redraw Techniques (Blitting)</li> <li>(105) Partial Screen Updates for Watch Faces</li> <li>(106) Color Conversion &amp; Palettes in MicroPython</li> <li>(83) Using the micropython-ufont Library</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-6-graphics-asynchronous-concurrency","title":"Category 6: Graphics, Asynchronous, &amp; Concurrency","text":"<p>All about getting time from the internet, using Wi-Fi, and handling multiple tasks.</p> <ol> <li>(12) Synchronizing Time from the PC</li> <li>(45) Using Internal Timers on the Raspberry Pi Pico</li> <li>(48) Network Time Synchronization (NTP)</li> <li>(49) Setting Up WiFi on the Pico W</li> <li>(50) Working the network module</li> <li>(51) Parsing JSON</li> <li>(65) Timer-Based Events</li> <li>(84) Asynchronous Code with uasyncio</li> <li>(85) Time-Based Tasks with uasyncio</li> <li>(86) Handling Concurrency of Time Updates &amp; UI</li> <li>(108) WiFi-Based Weather &amp; Forecast Updates</li> <li>(114) World Clocks</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-7-sensors-modules","title":"Category 7: Sensors &amp; Modules","text":"<p>External hardware modules, from RTC chips to accelerometers and I\u00b2C sensors.</p> <ol> <li>(46) External RTC Modules (DS1307, DS3231)</li> <li>(47) Setting the System Clock from an External RTC</li> <li>(69) Integrating External Sensors</li> <li>(70) Temperature and Humidity</li> <li>(71) Displaying Sensor Data</li> <li>(72) Accelerometers for Orientation</li> <li>(73) Tilt-Based Wake for Watch Display</li> <li>(98) Using I\u00b2C Sensors &amp; Modules</li> <li>(109) Using Sensors for Step Counting (Pedometer)</li> <li>(110) Adding a LiPo Charging Circuit</li> <li>(90) Tools for Measuring Battery Usage</li> <li>(100) Servo Motors for Mechanical Pointers</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-8-user-input-time-functions","title":"Category 8: User Input &amp; Time Functions","text":"<p>Handling buttons, debouncing, rotary encoders, and time-related features.</p> <ol> <li>(52) Displaying Date and Day of Week</li> <li>(57) Setting Time with Buttons</li> <li>(58) Using Interrupts for Button Input</li> <li>(59) Button Debouncing Techniques</li> <li>(60) Using A Rotary Encoder</li> <li>(61) Setting Alarms with the RTC</li> <li>(96) Using the Built-In Filesystem on Pico</li> <li>(97) Logging Time Data to an SD Card</li> <li>(74) Ultra-Low Power</li> <li>(99) Menu Systems for Watch Settings</li> <li>(107) Handling 12-Hour vs. 24-Hour Formats</li> <li>(111) Chronograph Functionality</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-9-audio-power-management","title":"Category 9: Audio &amp; Power Management","text":"<p>Generating sounds, mechanical movements, and minimizing power consumption.</p> <ol> <li>(62) Connecting Speakers</li> <li>(63) Playing a Sound</li> <li>(64) Sound Encoding</li> <li>(66) Playing Chimes</li> <li>(67) Cuckoo Clocks</li> <li>(68) Generating Beep or Alarm Tones</li> <li>(102) Generating Waveforms for Audio</li> <li>(55) Minimizing Power Consumption (Sleep Modes)</li> <li>(56) Waking from Deep Sleep on RTC Alarm</li> <li>(89) Sleep Scheduling</li> <li>(87) Using a Watchdog Timer for Reliability</li> <li>(88) Logging &amp; Debugging Time Issues</li> </ol>"},{"location":"prompts/04-concept-taxonomy/#category-10-example-projects","title":"Category 10: Example Projects","text":"<p>A set of \"capstone\" or real-world style projects/enhancements.</p> <ol> <li>(92) 3D Printing Watch Enclosures</li> <li>(100) [If not placed elsewhere --- but here we used 100 in Category 7, so you can swap if you prefer]</li> <li>(103) [If not used in Displays]</li> <li>(112) Timer Project</li> <li>(113) Stopwatch Project</li> <li>(109) [If not in Sensors]</li> <li>(99) [If not in User Input]</li> <li>( ... )</li> </ol> <p>Depending on how you ultimately shuffle things around, you can populate this \"Example Projects\" category with any concepts that serve well as culminating projects---for example, \"Cuckoo Clocks,\" \"Playing Chimes,\" \"Implementing Clock Themes,\" \"Using Sensors for Step Counting,\" or \"Servo Motors for Mechanical Pointers.\"</p>"},{"location":"prompts/04-concept-taxonomy/#final-notes","title":"Final Notes","text":"<ol> <li> <p>Balancing the Categories</p> <ul> <li>Each category has ~11--12 items (with minor adjustments possible).</li> <li>Some concepts (e.g., \"Servo Motors,\" \"Implementing Clock Themes,\" or \"Cuckoo Clocks\") could fit either under a main topic (like \"Sensors &amp; Modules\" or \"Audio &amp; Power\") or under \"Example Projects,\" depending on whether you treat them as discrete lessons or culminating builds.</li> <li>Avoiding Duplication</li> </ul> </li> </ol> <p>In a real curriculum, certain topics (e.g., \"External RTC Modules\" vs. \"Setting Alarms with the RTC\") might overlap across multiple categories. To keep it simple, each concept is listed once here.</p> <ol> <li>Adapt as Needed</li> </ol> <p>This taxonomy is a starting point. You may decide to rename categories (e.g., split \"Audio &amp; Power Management\" into two) or move individual concepts around to best match your teaching flow.</p> <p>By defining these ten thematic groupings, you'll have a clear roadmap for both the sequence of lessons and the range of coverage in \"Building Clocks and Watches with MicroPython.\"</p> <p>Clock and Watches</p>"},{"location":"prompts/05-taxonomy-assignment/","title":"Taxonomy Assignment","text":"<p>Prompt</p> <p>That is very good.  Now please return a new CSV file that appends the TaxonomyID as the fourth column.  The new CSV file you create now has the following format:</p> <pre><code>1. The first column in the CSV file is a numeric ConceptID\nID you assigned in the CSV file above.\n2. The second column is the ConceptLabel from the CSV file above.\n3. The third column is a pipe-delimited Dependencies of the Concept IDs that the concept depends upon.\n4. The fourth column is the numeric TaxonomyID from the taxonomy you generated above.\n</code></pre>"},{"location":"prompts/05-taxonomy-assignment/#response","title":"Response","text":"<p>Clock and Watches</p>"},{"location":"prompts/06-banner-image/","title":"Generate a Banner Image","text":"<p>Prompt</p> <p>Please generate a banner image for my new website called \"Designing and Building Clocks and Watches with MicroPython and AI\".  Make the banner features high school age students with diverse skin tone having fun working together and building clock and watch projects in a school.  Use bright colors but no text.  Use images of both digital and analog clocks and smartwatches.  Place breadboards, wire, microcontrollers digital watch displays, smartwatch displays and speakers on the table. </p>"},{"location":"prompts/06-banner-image/#sample-result","title":"Sample Result","text":""},{"location":"prompts/07-faq/","title":"FAQ Prompt","text":"<p>Prompt</p> <p>Take a look at the course description and the concepts lists file in this project. Now create a FAQ of the 100 most likely questions that students will ask.</p> <p>Return the FAQ in Markdown format with the question in level 4 headers and  the answers in the body text.  Group the FAQs in level 2 headers.</p>"},{"location":"prompts/07-faq/#result","title":"Result","text":""},{"location":"prompts/07-faq/#building-clocks-and-watches-with-micropython-frequently-asked-questions","title":"Building Clocks and Watches with MicroPython - Frequently Asked Questions","text":""},{"location":"prompts/07-faq/#general-course-information","title":"General Course Information","text":""},{"location":"prompts/07-faq/#what-prior-knowledge-do-i-need-for-this-course","title":"What prior knowledge do I need for this course?","text":"<p>No specific electronics or programming experience is required. However, basic computer literacy and comfort with mathematics at a high school level will be helpful. The course starts with fundamentals and builds up gradually.</p>"},{"location":"prompts/07-faq/#how-long-is-each-class-session","title":"How long is each class session?","text":"<p>While the course runs for 14 weeks, specific class session lengths are determined by your school's schedule. Contact your instructor for the exact timing of your sessions.</p>"},{"location":"prompts/07-faq/#do-i-need-to-purchase-my-own-equipment","title":"Do I need to purchase my own equipment?","text":"<p>Check with your instructor about equipment policies. Generally, core components like the Raspberry Pi Pico W and basic electronics will be provided, but you may want to purchase additional components for your final project.</p>"},{"location":"prompts/07-faq/#what-software-do-i-need-to-install","title":"What software do I need to install?","text":"<p>You'll need the Thonny IDE (a Python editor designed for MicroPython), which is free and works on Windows, Mac, and Linux. Your instructor will guide you through the installation process during the first week.</p>"},{"location":"prompts/07-faq/#technical-questions","title":"Technical Questions","text":""},{"location":"prompts/07-faq/#what-is-micropython-and-how-is-it-different-from-regular-python","title":"What is MicroPython and how is it different from regular Python?","text":"<p>MicroPython is a streamlined version of Python designed to run on microcontrollers. While it maintains Python's core features and syntax, it's optimized for hardware control and has special libraries for working with electronic components.</p>"},{"location":"prompts/07-faq/#what-is-a-raspberry-pi-pico-w","title":"What is a Raspberry Pi Pico W?","text":"<p>The Raspberry Pi Pico W is a small, affordable microcontroller board with built-in Wi-Fi. It's perfect for learning because it's user-friendly, well-documented, and has plenty of input/output pins for connecting different components.</p>"},{"location":"prompts/07-faq/#will-we-be-doing-any-soldering","title":"Will we be doing any soldering?","text":"<p>Most projects will use breadboards for non-permanent connections. Some optional advanced projects might involve soldering, but this will be optional and supervised.</p>"},{"location":"prompts/07-faq/#how-accurate-will-our-clocks-be","title":"How accurate will our clocks be?","text":"<p>The accuracy depends on the components used. With the basic oscillator, clocks might drift a few seconds per day. When we add a Real-Time Clock (RTC) module, accuracy improves significantly to within a few seconds per month.</p>"},{"location":"prompts/07-faq/#project-related-questions","title":"Project-Related Questions","text":""},{"location":"prompts/07-faq/#what-kind-of-displays-will-we-use","title":"What kind of displays will we use?","text":"<p>We'll work with several types: - Simple LEDs for basic digital displays - 128\u00d764 OLED displays for more sophisticated interfaces - Other display options for final projects</p>"},{"location":"prompts/07-faq/#can-i-create-my-own-custom-clock-design-for-the-final-project","title":"Can I create my own custom clock design for the final project?","text":"<p>Yes! The final project is designed to be creative and personal. You can combine different components and features we've learned about to create something unique.</p>"},{"location":"prompts/07-faq/#how-will-we-handle-time-zones-and-daylight-saving-time","title":"How will we handle time zones and daylight saving time?","text":"<p>We'll learn to sync time using web services (when Wi-Fi is available) and program time zone adjustments. Managing daylight saving time will be covered as part of the advanced features.</p>"},{"location":"prompts/07-faq/#learning-and-assessment","title":"Learning and Assessment","text":""},{"location":"prompts/07-faq/#how-will-i-be-graded","title":"How will I be graded?","text":"<p>Assessment typically includes: - Participation in class activities and discussions - Completion of hands-on labs and exercises - Quality and functionality of projects - Final project presentation and documentation</p>"},{"location":"prompts/07-faq/#what-happens-if-my-clock-doesnt-work","title":"What happens if my clock doesn't work?","text":"<p>Troubleshooting is a crucial part of the learning process. You'll have support from instructors and peers, and we'll learn systematic debugging approaches. Making mistakes and fixing them is how we learn!</p>"},{"location":"prompts/07-faq/#can-i-work-with-ai-tools-during-the-course","title":"Can I work with AI tools during the course?","text":"<p>Yes, part of the course includes learning how to effectively use AI tools for design and problem-solving. We'll cover best practices for AI collaboration while ensuring you understand the fundamental concepts.</p>"},{"location":"prompts/07-faq/#hardware-and-components","title":"Hardware and Components","text":""},{"location":"prompts/07-faq/#what-happens-if-i-accidentally-damage-a-component","title":"What happens if I accidentally damage a component?","text":"<p>Don't worry! Learning electronics involves some trial and error. Basic components are relatively inexpensive and replaceable. Just inform your instructor if something breaks.</p>"},{"location":"prompts/07-faq/#how-do-breadboards-work","title":"How do breadboards work?","text":"<p>A breadboard is a reusable platform for creating temporary electrical connections. We'll spend time early in the course understanding how they work and practicing proper connection techniques.</p>"},{"location":"prompts/07-faq/#whats-the-difference-between-digital-and-analog-inputsoutputs","title":"What's the difference between digital and analog inputs/outputs?","text":"<p>Digital signals are either on (1) or off (0), while analog signals can have many values in between. We'll use both types: digital for buttons and simple LEDs, analog for sensors and variable controls.</p>"},{"location":"prompts/07-faq/#programming-concepts","title":"Programming Concepts","text":""},{"location":"prompts/07-faq/#do-i-need-to-memorize-all-the-micropython-commands","title":"Do I need to memorize all the MicroPython commands?","text":"<p>No, you don't need to memorize everything. We'll provide reference materials, and part of learning is knowing how to find and use documentation effectively.</p>"},{"location":"prompts/07-faq/#what-if-i-miss-a-class-and-fall-behind","title":"What if I miss a class and fall behind?","text":"<p>Each concept builds on previous learning, but we'll provide catch-up resources and extra help sessions. Talk to your instructor as soon as possible if you fall behind.</p>"},{"location":"prompts/07-faq/#how-will-we-debug-our-code","title":"How will we debug our code?","text":"<p>We'll learn several debugging techniques: - Using print statements for troubleshooting - Reading error messages - Using the Thonny debugger - Systematic problem-solving approaches</p>"},{"location":"prompts/07-faq/#safety-and-best-practices","title":"Safety and Best Practices","text":""},{"location":"prompts/07-faq/#is-there-any-risk-of-electric-shock","title":"Is there any risk of electric shock?","text":"<p>The Pico W and components we use operate at very low voltages (3.3V or 5V) which are safe to handle. However, we'll still learn and follow proper safety procedures.</p>"},{"location":"prompts/07-faq/#how-do-i-protect-the-electronic-components","title":"How do I protect the electronic components?","text":"<p>We'll cover basic handling procedures including: - Static electricity precautions - Proper connection techniques - Component storage and handling - Avoiding common mistakes that could damage components</p>"},{"location":"prompts/07-faq/#advanced-topics-and-extensions","title":"Advanced Topics and Extensions","text":""},{"location":"prompts/07-faq/#can-we-add-features-like-alarms-or-stopwatch-functions","title":"Can we add features like alarms or stopwatch functions?","text":"<p>Yes! As you progress through the course, you'll learn to add various features including: - Multiple alarms - Stopwatch and timer functions - Custom sounds and alerts - Special display effects</p>"},{"location":"prompts/07-faq/#will-we-learn-about-power-management","title":"Will we learn about power management?","text":"<p>Yes, we'll cover power management including: - Battery operation - Sleep modes - Power-efficient programming - Battery life optimization</p>"},{"location":"prompts/07-faq/#future-applications","title":"Future Applications","text":""},{"location":"prompts/07-faq/#can-i-use-these-skills-for-other-projects","title":"Can I use these skills for other projects?","text":"<p>Absolutely! The skills you'll learn apply to many other electronics and programming projects: - Other types of electronic devices - Home automation projects - Sensor-based systems - IoT (Internet of Things) devices</p>"},{"location":"prompts/07-faq/#how-does-this-course-prepare-me-for-further-study","title":"How does this course prepare me for further study?","text":"<p>This course builds valuable skills for: - Computer science courses - Engineering programs - Electronics projects - General problem-solving - Understanding modern technology</p>"},{"location":"prompts/07-faq/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"prompts/07-faq/#what-online-resources-can-we-use","title":"What online resources can we use?","text":"<p>We'll use various resources including: - MicroPython documentation - Raspberry Pi Pico documentation - Component datasheets - Online simulators - Programming reference guides</p>"},{"location":"prompts/07-faq/#will-we-use-version-control-like-git","title":"Will we use version control like Git?","text":"<p>While not required, we'll introduce basic version control concepts and how they can help manage your code as projects become more complex.</p>"},{"location":"prompts/07-faq/#collaboration-and-community","title":"Collaboration and Community","text":""},{"location":"prompts/07-faq/#can-we-work-in-teams","title":"Can we work in teams?","text":"<p>Yes! Many activities will involve pair programming or team collaboration. The final project can be individual or team-based, depending on complexity and scope.</p>"},{"location":"prompts/07-faq/#how-can-we-share-our-projects-with-others","title":"How can we share our projects with others?","text":"<p>We'll discuss ways to: - Document your work - Create project presentations - Share code responsibly - Collaborate with other students - Showcase your projects</p>"},{"location":"prompts/07-faq/#getting-help","title":"Getting Help","text":""},{"location":"prompts/07-faq/#what-if-i-get-stuck-on-a-problem","title":"What if I get stuck on a problem?","text":"<p>Multiple support options are available: - In-class help from instructors - Peer support - Office hours - Online resources - Lab assistance sessions</p>"},{"location":"prompts/07-faq/#can-i-get-extra-help-outside-of-class","title":"Can I get extra help outside of class?","text":"<p>Yes, instructors will have office hours and may offer additional lab time for students who want extra practice or help.</p>"},{"location":"prompts/07-faq/#course-materials","title":"Course Materials","text":""},{"location":"prompts/07-faq/#what-should-i-bring-to-class","title":"What should I bring to class?","text":"<p>Typically you'll need: - Notebook for taking notes - Computer (if not provided) - Any assigned reading materials - Your project components once distributed</p>"},{"location":"prompts/07-faq/#how-should-i-store-and-transport-my-projects","title":"How should I store and transport my projects?","text":"<p>We'll provide guidance on: - Component storage - Project organization - Safe transport methods - Protecting delicate components</p>"},{"location":"prompts/07-faq/#final-projects","title":"Final Projects","text":""},{"location":"prompts/07-faq/#what-makes-a-good-final-project","title":"What makes a good final project?","text":"<p>Strong final projects typically: - Solve a real problem or fulfill a genuine need - Demonstrate technical skills learned in the course - Show creativity and originality - Are well-documented - Function reliably</p>"},{"location":"prompts/07-faq/#can-i-continue-working-on-my-project-after-the-course-ends","title":"Can I continue working on my project after the course ends?","text":"<p>Yes! You'll have the knowledge to continue developing and improving your projects. We'll discuss ways to extend your learning and continue exploring electronics and programming.</p>"},{"location":"prompts/08-glossary/","title":"Generating a Glossary of Terms","text":""},{"location":"prompts/08-glossary/#prompt","title":"Prompt","text":"<p>Prompt</p> <p>Prompt Name: Glossary for Clocks and Watches with MicroPython Book</p> <p>You are an expert at creating a glossary of terms for books for high-school students.  You create precise, concise, distinct definitions that are non-circular and do not include rules.</p> <p>Your terms are written for the 9th grade reading level.</p> <p>The focus of this glossary is to support a book and website about  how to create DIY Clocks and Watches with MicroPython using the Raspberry Pi Pico W.  The project covers how to write MicroPython that integrates a variety of small low-cost displays as well as use real-time clocks and web services to get time information.</p> <p>For each term, return a term label in a level 4 markdown header. Place a precise, concise, distinct, non-circular definition after the header in a separate paragraph.  Do not include the term in the definitions.</p> <p>Go to the project area and use the file MicroPython_Clock_Concepts.csv    for a complete list of concepts that need definitions.</p> <pre><code>If appropriate create an example of how that term might be\nused in the website.  Use **Example:** with no newline after it.\n\nReturn the entire glossary of terms in a single Markdown file\nfor all concepts in alphabetical order.\n\n## Project Instructions\n\n!!! prompt\n    When I ask you to create a definition for a ter, please create a glossary term\n    entry that complies with the ISO/IEC 11179 metadata registry\n    guidelines for a definition.  These definitions are precise, concise, distinct\n    definitions that are non-circular and do not include rules.  Do not include the\n    term name in the definition itself.  Your terms are written for the 9th grade reading level.\n\n    Return the term in a level 4 markdown header.\n    Return the definition in the body text.\n    If appropriate, give an example using the **Example:** format without a newline.\n</code></pre>"},{"location":"prompts/09-oled-test/","title":"OLED Test Prompt","text":"<p>We can use generative AI tools to build test programs. But in order to get working programs, we need to tell the generative AI about what our hardware is and what our configuration is.  We can leverage the <code>config.py</code> file to tell the generative AI tools about our local configuration.</p>"},{"location":"prompts/09-oled-test/#sample-prompt","title":"Sample Prompt","text":"<p>Prompt</p> <p>You are an expert at helping high-school kids learn computational thinking using MicroPython. I am working on writing a test program written in MicroPython. I have a 128x64 OLED using ssd1306 display driver chip connected to a Raspberry Pi Pico W running MicroPython version 1.24.1 using an SPI bus. I have the ssd1306.py driver loaded into the /lib directory.</p> <p>Please write a MicroPython program that prints \"Hello World!\" on the OLED display.  Use the config.py program in the project to setup the display.</p> <p>If your AI does not have a project feature, you can include the config.py in the prompt:</p> <pre><code># MicroPython hardware configuration file for Raspberry Pi Pico W\n# Using an SPI OLED Display, a DS3231 RTC with EEPROM, and three buttons\n\nSPI_BUS = 0\nSPI_SCL_PIN = 2 # Clock\nSPI_SDA_PIN = 3 # labeled SDI(MOSI) on the back of the display\nSPI_RESET_PIN = 4 # Reset\nSPI_DC_PIN = 5 # Data/command\nSPI_CS_PIN = 6 # Chip Select\n\n# I2C Bus for the DS3231 RTC\nI2C_BUS = 0\nI2C_DT_PIN = 0 # Data\nI2C_SCK_PIN = 1 # Clock\nRTC_ADDRESS = 0x68\nEEPROM_ADDRESS = 0x57\n\n# OLED Screen Dimensions\nDISPLAY_WIDTH=128\nDISPLAY_HEIGHT=64\n\n# Button Pins where the buttons are between the GPIO and GND\n# Make sure to configure the pull-up resistor in the code\nBUTTON_MODE_PIN = 14\nBUTTON_INCREMENT_PIN = 15\nBUTTON_DECREMENT_PIN = 16\n</code></pre>"},{"location":"setup/","title":"A Guide to Setting up Your Clocks and Watches Labs","text":"<p>This section is intended for parents, mentors, teachers and curriculum developers who are responsible for creating a great experience for your students.  Within this audience we have typically seen two extremes.</p> <ol> <li> <p>Value-based purchasers with limited budgets who are good at long-term planning.  They pre-order parts form China on eBay and Alibaba in bulk and avoid high-cost shipping fees.</p> </li> <li> <p>Parents in high-disposable income households with limited time and large budgets.  They just want to click on a few links and have the parts shipped overnight.</p> </li> </ol> <p>This Setup Guide attempts to provide information for both of these groups.  Note that we have used generative AI to help you source the lowest costs parts.  We encourage you to ask your generative AI chatbot about sourcing strategies that balance low-cost and fast delivery.</p>"},{"location":"setup/#minimal-setup","title":"Minimal Setup","text":"<p>The minimal setup consists of just four parts:</p> <ol> <li>A 1/2 size solderless breadboard - about $2</li> <li>20cm jumper wires (male-to-female) - also known as Dupont connectors - about $1</li> <li>A Raspberry Pi Pico - about $4 or $5 with headers presoldered - you can get the \"W\" if you want to go wireless and use WiFi to sync the time</li> <li>A OLED display - which range from $5 to $20 depending on the size</li> </ol> <p>If you are patient and clever you can purchase these parts in bulk and keep the kit price under $10 - although the OLED display will be hard to read from more than a few feet away.</p> <p> Image Caption: An example of a 2.42\" OLED display connected to a 400-tie breadboard holding a Raspberry Pi W with two buttons for changing the display settings.</p>"},{"location":"setup/#sample-amazon-links","title":"Sample Amazon Links","text":"<p>Here are the Amazon Links for these parts:</p> <ol> <li>Half Size Solderless Breadboard Search on Amazon</li> <li>Sample 4-Pack for $6</li> <li>20cm male-to-female Dupont Connectors $4 for 40 connectors</li> <li>Raspberry Pi Pico $8</li> <li>Amazon Keyword Search for 2.42\" OLED Display 128*64 SPI SSD1309</li> <li>Amazon Prime 2.42\" OLED Display for $14 in 4 Colors</li> </ol> <p>Note that MicroCenter sells the Pico for $3.99.  So you are paying about double on Amazon for some of these parts.</p>"},{"location":"setup/#sample-e-bay-links","title":"Sample E-Bay Links","text":"<ol> <li>Half Size Solderless Breadboard Search on EBay</li> <li>10X 400 Point Solderless Breadboard for $14</li> <li>20cm male-to-female dupont connectors</li> <li>10/20/30CM MM, MF, FF Dupont Wire Jumper Cable 40PIN Dupont Line Connector for $4</li> <li>2.42\" OLED Display 128*64 SPI SSD1309</li> </ol>"},{"location":"setup/#other-components","title":"Other Components","text":""},{"location":"setup/#display-cable-harness","title":"Display Cable Harness","text":"<p>Display Cable Harness</p>"},{"location":"setup/#real-time-clocks","title":"Real Time Clocks","text":"<p>Technically you can get a clock or watch running without a real-time clock (RTC). The problem is that the clock will not be very accurate unless you continually sync the time using WiFi or with your host computer.</p> <p>However, learning how to use the a RTC is a key learning concept and learning how to use the I2C serial interface is also a good concept to know.  So it is optional but strongly encouraged.</p>"},{"location":"setup/#the-ds1307","title":"The DS1307","text":"<p>Although this board is old, it is a simple and low-cost part that is easy to use. Most of the development boards come with their own crystal and an I2C interface.</p>"},{"location":"setup/#the-ds3231","title":"The DS3231","text":"<p>The DS3231 is one of the most commonly used real-time clock (RTC) modules paired with microcontrollers like the Raspberry Pi Pico. It's popular because it:</p> <ol> <li>Has high accuracy (temperature-compensated crystal oscillator)</li> <li>Maintains accuracy over a wide temperature range</li> <li>Has built-in temperature compensation</li> <li>Uses the I2C interface, which is easy to implement</li> <li>Includes a battery backup option</li> <li>Is relatively inexpensive</li> <li>Has extensive library support across different platforms</li> </ol> <p>The second most common is probably the DS1307, which is an older and simpler version. While less accurate than the DS3231, it's even less expensive and still perfectly suitable for many basic timekeeping applications.</p> <p>For microcontrollers in particular, the DS3231 tends to be favored because its accuracy doesn't depend on the microcontroller's clock, and it maintains accurate time even when the main microcontroller is reset or loses power.</p>"},{"location":"setup/01-desktop/","title":"Desktop Setup","text":"<p>In this lesson, we will review the steps to get your PC or Mac setup to use the free open source Thonny Python Integrated Development Environment (IDE).  We will assume you are using either the Raspberry Pi Pico or the Raspberry Pi Pico \"W\" for thee lessons.</p>"},{"location":"setup/01-desktop/#about-thonny","title":"About Thonny","text":"<p>Thonny is an ideal tool for writing MicroPython code for students just getting started.  It is free, simple to use, and it runs on PCs running Windows, Macs and Linux systems such as the Raspberry Pi.</p>"},{"location":"setup/01-desktop/#step-1-install-thonny","title":"Step 1: Install Thonny","text":"<p>The installation of Thonny will vary depending on the type of computer you are using.  For both Windows and Mac, you must first download an installer program. The links to these downloads are on the main Thonny page:</p> <p></p> <p>For all the versions of Linux, you can open the command shell and type in the correct installation command.  For people using the Raspberry Pi operating system, Thonny may already be included in your software.</p>"},{"location":"setup/01-desktop/#thonny-versions","title":"Thonny Versions","text":"<p>These screen images were done with Thonny Version 4.0.4.  We also tested the steps on Thonny version 4.1.2 and the seem to work fine.</p>"},{"location":"setup/01-desktop/#step-2-configure-the-micropython-firmware","title":"Step 2: Configure the MicroPython Firmware","text":"<p>After you first plug in a Raspberry Pi Pico, you will need to install the correct runtime library for the Pico.  This just takes a minute and you will only have to do it once for each microcontroller.</p> <p>Since version 4.0.0 Thonny can detect the microcontroller you are using and download the firmware.</p> <p></p>"},{"location":"setup/01-desktop/#manually-downloading-the-firmware","title":"Manually Downloading the Firmware","text":"<p>There are occasions when the automatic firmware download in Thonny may not work.  In this case, you will need to manually download the firmware from the MicroPython website.</p> <p>Here are the links to the Pico Firmware (called RP2-pico):</p> <p>Raspberry Pi Pico Firmware</p> <p></p>"},{"location":"setup/01-desktop/#step-3-configure-interpreter","title":"Step 3: Configure Interpreter","text":"<p>Thonny is designed to automatically detect the correct device and configure the right interpreter.  You can verify this by using the Thonny Tools -&gt; Options menu and move to the Interperter tab.</p> <p></p> <p>Note that the MicroPython (Raspberry Pi Pico) is selected.</p>"},{"location":"setup/01-desktop/#thonny-firmware-list","title":"Thonny Firmware List","text":"<p>You can also get a list of all the different versions of firmware by going directly to the MicroPython site.  Here is what that list will look like:</p> <p></p> <p>After you select a runtime version, Thonny will give you the details about this version.</p> <p></p> <p></p> <p>After Thonny installs the new firmware on the Pico it instructs the Pico to \"restart\" using the new firmware.  This makes the USB drive appear to be removed without a disconnect and results in an error.  This is normal so don't worry.</p> <p></p> <p></p>"},{"location":"setup/01-desktop/#debugging-tips","title":"Debugging Tips","text":"<p>When debugging your Thonny installation, it is important to understand the steps that happen when you plug your Raspberry Pi Pico into the computer.</p> <p>Step 1: Plugging the USB Device The Pico appears as a USB device on your computer when you plug it in.  The operating system should send a request to the USB device asking it for its ID.</p> <p>Step 2: Probing for the USB ID The Pico will respond with a device ID number.  This number reflects two items: the company that made the device (Vendor ID) and the device product type (Product ID).  If you are using a power-only USB cable this number will never get to the operating system.  This means that the data wires are not present in your USB cable or one of the wires is broken or not connecting.</p> <p>Step 3: Looking Up the USB Driver The operating system will take this USB ID and then look-up the right software and then run that software.  In UNIX and Mac systems this will amount to making the USB device appear in the <code>/dev/cu*</code> area.  On Windows it will be a <code>COM</code> port.</p> <pre><code>ls -l /dev/cu.usb*\n\ncrw-rw-rw-  1 root  wheel  0x9000001 Dec 25 08:41 /dev/cu.usbmodem101\n</code></pre> <p>Note that the exact port name might change.  The example above is <code>cu.usbmodem101</code>.</p> <p>If this device does not immediately appear, then you should double-check your cable and make sure the operating system registers the USB device.</p> <p>If you know your cable works fine by testing it on other devices then you may have to reboot your computer.</p>"},{"location":"setup/01-desktop/#setting-usb-permissions-on-macos","title":"Setting USB Permissions on MacOS","text":"<p>In many classrooms with Macs, the security settings for USB connections can get in the way of a good experience for our students.  Since these Macs don't leave our classrooms,  we have decided to permanently allow USB access for your Raspberry Pi Pico on MacOS Sequoia.</p> <p>Here are the steps we use.</p> <ol> <li>On the Mac, go to System Settings &gt; Privacy &amp; Security</li> <li>Scroll to Security</li> <li>Find \"Allow accessories to connect\" and select \"always\"</li> </ol>"},{"location":"setup/01-desktop/#debugging-your-usb-connection","title":"Debugging your USB Connection","text":"<p>Our students have reported many frustrating experiences getting their Raspberry Pi Pico to connect to their MacOS system.  Most of these problems can be quickly solved by checking the security settings on your MacOS.</p> <p>After you plug in the USB it should be listed in the <code>/dev/cu*</code> area:</p> <pre><code>ls /dev/cu*\n</code></pre> <p>A typical response includes this device:</p> <pre><code>/dev/cu.usbmodem1101\n</code></pre> <p>If the <code>usbmodem1101</code> or similar is not listed then Thonny will not connect. This is the time to check your cables and connectors.  Older USB cables frequently have broken wires.</p>"},{"location":"setup/01-desktop/#getting-usb-diagnostic-information-on-the-macos","title":"Getting USB Diagnostic Information on the MacOS","text":"<p>You can also get information about how much current will be provided to the USB using the following shell commnad:</p> <p>You can get the full information on your device using this command:</p> <pre><code>system_profiler SPUSBDataType | grep -B 6 -A 5 \"MicroPython\"\n</code></pre> <p>This command prints the 6 lines before and five lines after the string \"MicroPython\" appears in the output of the system_profiler command.</p> <pre><code>  Product ID: 0x0005\n  Vendor ID: 0x2e8a\n  Version: 1.00\n  Serial Number: e66178c1276d562d\n  Speed: Up to 12 Mb/s\n  Manufacturer: MicroPython\n  Location ID: 0x01100000 / 1\n  Current Available (mA): 500\n  Current Required (mA): 250\n  Extra Operating Current (mA): 0\n</code></pre>"},{"location":"setup/01-desktop/#using-the-macos-io-registry-command","title":"Using the MacOS I/O Registry Command","text":"<p>The MacOS shell command <code>ioreg</code> can also be useful for monitoring USB device status. Here is a command that lists the information of all USB devices. The I/O Registry is a hierarchical database of all the devices and drivers on your Mac.  The <code>ioreg</code> shell command is powerful utility to examine system hardware and device information.</p> <pre><code>ioreg -p IOUSB -w0 -l\n</code></pre> <p>Here are the parameters:</p> <ul> <li><code>-p IOUSB</code>:</li> </ul> <p>Specifies the plane (category of devices) to focus on. In this case, the <code>IOUSB</code> plane, which contains information about all USB devices connected to your system. Other planes include <code>IODeviceTree</code>, <code>IOService</code>, etc.</p> <ul> <li><code>-w0</code>:</li> </ul> <p>Sets the line wrapping for output. <code>0</code> disables wrapping entirely, which means the output will display long lines without being truncated or split. This is useful for keeping all the device details on a single line, making it easier to parse or search.</p> <ul> <li><code>-l</code>:</li> </ul> <p>Displays the output in long format. This includes all properties associated with each object in the I/O Registry. Without <code>-l</code>, the command provides a more concise list with only basic information.</p> <p>+-o Board in FS mode@01100000   <pre><code>{\n  \"sessionID\" = 37899561861259\n  \"USBSpeed\" = 1\n  \"idProduct\" = 5\n  \"iManufacturer\" = 1\n  \"bDeviceClass\" = 239\n  \"IOPowerManagement\" = {\"PowerOverrideOn\"=Yes,\"DevicePowerState\"=2,\"CurrentPowerState\"=2,\"CapabilityFlags\"=32768,\"MaxPowerState\"=2,\"DriverPowerState\"=0}\n  \"bcdDevice\" = 256\n  \"bMaxPacketSize0\" = 64\n  \"iProduct\" = 2\n  \"iSerialNumber\" = 3\n  \"bNumConfigurations\" = 1\n  \"UsbDeviceSignature\" = &lt;8a2e0500000165363631373863313237366435363264ef02010202000a0000&gt;\n  \"USB Product Name\" = \"Board in FS mode\"\n  \"locationID\" = 17825792\n  \"bDeviceSubClass\" = 2\n  \"bcdUSB\" = 512\n  \"kUSBSerialNumberString\" = \"e66178c1276d562d\"\n  \"USB Address\" = 1\n  \"IOCFPlugInTypes\" = {\"9dc7b780-9ec0-11d4-a54f-000a27052861\"=\"IOUSBHostFamily.kext/Contents/PlugIns/IOUSBLib.bundle\"}\n  \"kUSBCurrentConfiguration\" = 1\n  \"bDeviceProtocol\" = 1\n  \"USBPortType\" = 0\n  \"IOServiceDEXTEntitlements\" = ((\"com.apple.developer.driverkit.transport.usb\"))\n  \"USB Vendor Name\" = \"MicroPython\"\n  \"Device Speed\" = 1\n  \"idVendor\" = 11914\n  \"kUSBProductString\" = \"Board in FS mode\"\n  \"USB Serial Number\" = \"e66178c1276d562d\"\n  \"IOGeneralInterest\" = \"IOCommand is not serializable\"\n  \"kUSBAddress\" = 1\n  \"kUSBVendorString\" = \"MicroPython\"\n}\n</code></pre>"},{"location":"setup/01-desktop/#automatic-power-draw-shutoff","title":"Automatic Power Draw Shutoff","text":"<p>If your USB port is drawing too much power, then many computers will disable the port.  This can happen if you are trying to display too many LEDs or a motor.  You will see a message such as \"USB Port Disabled\". </p> <p>Your computer manufacturer will tell you what the maximum current each USB port allows.  This is typically about 1 amp, but it varies based on your computer and what other devices are connected to your computer.</p> <p>The best way to debug this is to purchase a low-cost USB current monitor and monitor how much current your project is using.</p> <p>USB Current Monitor Search on eBay</p>"},{"location":"setup/01-desktop/#large-neopixel-clocks","title":"Large NeoPixel Clocks","text":"<p>In general, each NeoPixel at full brightness will draw up to 20 milliamps and the Pico will also draw about 20  milliamps.</p> <p>For projects that require more than about 500 milliamps, it is strongly recommended that you use an externally powered USB hub.</p>"},{"location":"setup/01-desktop/#debugging-the-usb-port","title":"Debugging the USB Port","text":""},{"location":"setup/01-desktop/#mac-system-profiler","title":"Mac System Profiler","text":"<p>On MacOS we can use the <code>system_profiler</code> command:</p> <pre><code>system_profiler SPUSBDataType\n\nUSB:\n\n    USB 3.1 Bus:\n\n      Host Controller Driver: AppleT8112USBXHCI\n\n    USB 3.1 Bus:\n\n      Host Controller Driver: AppleT8112USBXHCI\n\n        Board in FS mode:\n\n          Product ID: 0x0005\n          Vendor ID: 0x2e8a\n          Version: 1.00\n          Serial Number: e66141040396962a\n          Speed: Up to 12 Mb/s\n          Manufacturer: MicroPython\n          Location ID: 0x00100000 / 1\n          Current Available (mA): 500\n          Current Required (mA): 250\n          Extra Operating Current (mA): 0\n</code></pre> <p>Note that you can see both the Product ID, Vendor ID Manufacturer (MicroPython) and the mode (File System mode) that the device was connected.  The current available and current required are also listed, although these numbers might be somewhat conservative.  They are used for the estimation of current only.</p>"},{"location":"setup/01-desktop/#checking-out-the-clocks-and-watches-code-from-github","title":"Checking out the Clocks and Watches Code from GitHub","text":"<p>You don't need to copy and paste the code samples one-by-one into your local file system.  GitHub allows you to download all the code on the Moving Rainbow site by running the following command:</p> <pre><code># create a projects area to checkout your code\nmkdir ~/projects\ncd projects\n# make a copy of the repo on your local hard drive\ngit clone https://github.com/dmccreary/clocks-and-watches\ncd clocks-and-watches\n# open the files in your file manager\nopen .\n</code></pre> <p>The <code>open</code> is specific to the Mac.</p> <p>You can now go directly to the source for your kit such as:</p> <pre><code>cd src/kits/large-oled\n</code></pre> <p>Once you have done this step you can make the top Files region of Thonny point to the source area and then click the upper right corner that has the \"Upload to /\" menu.  Make sure the bottom area is set to the root, not the /lib area.</p> <p>The following video shows these steps:</p>"},{"location":"setup/01-desktop/#understanding-thonny-and-file-systems","title":"Understanding Thonny and File Systems","text":"<p>To understand how Thonny works, we want to have a clear visual picture of the two parallel file systems that Thonny uses.</p> <ol> <li>Thonny is launched from your desktop or laptop computer.  The Files window at the top will always be open to that file system.</li> <li>Thonny also displays the file system on the microcontroller on the bottom window.  It displays this window after you successfully connect through the correct port.</li> </ol> <p>You can run a program in Thonny from either file system.  But there is one strict rule.  If you don't save your code on your personal GitHub site and verify that the code is there you may not have saved your code.</p>"},{"location":"setup/02-purchasing-parts/","title":"Strategy for Parts Purchasing Guide","text":"<p>We have seen many well intended parent come into our workshops telling stories about a $400 robot kit that was used for an hour and then sat in the back of a closet.  Before you go out and purchase an expensive STEM kit, we suggest you start small and see if your student will really use the kit.</p>"},{"location":"setup/02-purchasing-parts/#breadboards","title":"Breadboards","text":"<p>We strongly suggest purchasing breadboards in bulk at least 10 at a time. We use eBay for purchasing all our breadboards.</p> <p>Many of our projects use the 1/2 size 400-tie breadboards.  This is usually sufficient for simple projects.</p>"},{"location":"setup/02-purchasing-parts/#microcontrollers","title":"MicroControllers","text":"<p>Because all or examples run MicroPython, your microcontroller will also need to run MicroPython. Unfortunately, older microcontrollers like the Arduino Uno only come with 2K of RAM.  Since we need at least 16K of RAM to run MicroPython, the older Arduino systems will not work.</p> <p>Therefore we strongly suggest you go with a newer microcontroller like the Raspberry Pi Pico which typically sells for under $4.</p>"},{"location":"setup/02-purchasing-parts/#purchasing-the-raspberry-pi-pico","title":"Purchasing the Raspberry Pi Pico","text":"<p>We love MicroCenter because they sell the Raspberry Pi Pico for only $3.99.  If there is a MicroCenter near your home, we strongly suggest purchasing the parts there.  </p> <p></p>"},{"location":"setup/02-purchasing-parts/#raspberry-pi-pico-w","title":"Raspberry Pi Pico W","text":"<p>If you are going wireless, you will need to pay an extra dollar to get the Raspberry Pi Pico for $5.99</p> <p></p> <p>If the Raspberry Pi Picos are out of stock, a backup plan might be an ESP-32 microcontroller. There are two challenges you might face with the ESP-32:</p> <ol> <li>The development boards at MicroCenter, SparkFun and Adafruit are 4x more expensive</li> <li>There is a huge variety of these boards from many different manufactures.  So the instructions you get on each website may not match the device you purchase.</li> </ol>"},{"location":"setup/02-purchasing-parts/#displays","title":"Displays","text":""},{"location":"setup/02-purchasing-parts/#oled-displays","title":"OLED Displays","text":"<p>Although the small 1\" OLED displays work, they are hard to read from a distance. We like the 2.42\" inch OLED displays since they are bright and have a wide viewing angle.</p>"},{"location":"setup/02-purchasing-parts/#smartwatch-displays","title":"SmartWatch Displays","text":"<p>Waveshare RP2040-LCD-1.28</p> <p>Ebay Listing for $21</p>"},{"location":"setup/02-purchasing-parts/#led-strips","title":"LED Strips","text":""},{"location":"setup/02-purchasing-parts/#smartwatch-displays_1","title":"Smartwatch Displays","text":""},{"location":"setup/02-purchasing-parts/#real-time-clocks","title":"Real-Time Clocks","text":"<p>Learning how to use a real-time clock (RTC) is a core part of building digital clocks.  So almost all our kits include an RTC.  Here is a description of the two main options for RTCs.</p>"},{"location":"setup/02-purchasing-parts/#the-ds1307","title":"The DS1307","text":"<p>Although the DS1307 is has been around for a long time, it is still a simple low-cost part that is easy to use.  The DS1307 is still perfectly suitable for many basic timekeeping applications and for learning how to use a Most of the development boards come with their own crystal and an I2C interface.  Most of our clock kits have now been upgraded to the newer more accurate DS3231 which we can also purchase for under $1.</p>"},{"location":"setup/02-purchasing-parts/#the-ds3231","title":"The DS3231","text":"<p>The DS3231 is one of the most commonly used real-time clock (RTC) modules paired with microcontrollers like the Raspberry Pi Pico. It's popular because it:</p> <ol> <li>Has high accuracy (temperature-compensated crystal oscillator) +/- 2 seconds per month</li> <li>Maintains accuracy over a wide temperature range suitable for indoor and outdoor use</li> <li>Uses the I2C interface, which is easy to implement</li> <li>Includes a 3V lithium coin-cell battery backup option which allows it to remember the time and alarm settings even when the power is off</li> <li>Is relatively inexpensive (under $1 each)</li> <li>Has extensive library support across different platforms</li> <li>You can also use it to display the temperature</li> <li>Includes the ability to store 4K in EEPROM for information such as when alarms and timers should go off</li> </ol> <p>For microcontrollers in particular, the DS3231 tends to be favored because its accuracy doesn't depend on the microcontroller's clock, and it maintains accurate time even when the main microcontroller is reset or loses power.</p> <p>Here is an example of a DS3231 listing on eBay for under $1:</p> <p></p> <p>AliExpress currently has the DS3231 boards listed for $0.73 each.</p> <p></p>"},{"location":"setup/03-display-cable-harness/","title":"Display Cable Harness","text":"<p>Unlike simple sensors that only have a few wires, displays have up to seven wires that need to be connected. This can be tricky when we use breadboards where we can accidentally pull one wire out.</p> <p>To keep our displays running reliably, we can use a 20 cm ribbon cable and some hot glue to make a connector that is easy to hook up and be much more reliable.  We call this ribbon cable a \"harness\" since it connects the wires together.</p> <p>Here is what our final display cable harness will look like when connected to the display at the right:</p> <p></p> <p>Note that the male pins are on the left side and the red power wire is separated from the rest of the wires which are all hot glued together so they can be easily plugged directly into the breadboard.</p>"},{"location":"setup/03-display-cable-harness/#building-the-display-harness","title":"Building the Display Harness","text":"<p>We start by purchasing some 20cm long Male-Female Dupont ribbon connectors from eBay. The price should be about $8 for 120 connectors. Make sure to get the Male-Female version.  The female pins will go on the display and the male ends will go into our breadboard.</p> <p></p> <p>We then separate out seven of these wires using the black (or brown) and red colors for the VDD (GND) and VCC (3.3V) edge of the group of wires.  Note that some of the Dupont cables use brown for GND rather than black.</p>"},{"location":"setup/03-display-cable-harness/#the-display-connection","title":"The Display Connection","text":"<p>You can see a close-up photograph of each of the colors and their connections in the picture below.</p> <p>There is the backside view of the display harness at the display end: </p> <p>Note that from the backside, the brown wire on the right (near the \"1\") is GND and the purple wire on the left (near the \"7\") is CS (chip select).  Note that \"VSS\" is the same an GND and \"VDD\" is the same and 3.3 volt power.</p> <p>Here is the front side view of display harness at the display end:  Note from this perspective that the brown wire is GND and the purple wire is CS (chip select).</p> <p>At the other end of the cable, we need to make a small change in the order of the cable because ever fifth wire is a GND on the Pico. Here are the changes:</p> <ol> <li>We separate the red wire from the rest of the group and connect the red to the 3.3V regulated output of the Raspberry Pi Pico.  Almost all the displays in our kits run on 3.3V.  Some older LCD displays needed exactly 5 volts, but our OLED displays work fine on either 3.3V or 5V.</li> <li>We move the black GND wire to be in between the blue (DC) and purple (CS) wires. This allows the row of all the wires to be connected in a single block of wires.  We can hot glue these pins together to get a more reliable connection.  This is called a \"Wire Harness\".</li> </ol> <p></p>"},{"location":"setup/03-display-cable-harness/#breadboard-connections","title":"Breadboard Connections","text":"<p>In our kits the USB connector is placed at the top of the breadboard near row 1.  Make sure your breadboard is oriented correctly so the row numbers in this document will make sense.  Note that the breadboard row numbers are on the left and begin with the number \"1\".  Don't confuse this with the logical GPIO numbers inside the Pico that begin with \"0\".  So in our setup, GPIO 0 is on breadboard row 1.</p> <p>We can then plug this group of wires directly into the left side of the breadboard from breadboard rows 3 to 9. This is shown below.  Make sure the black GND is on the Pico GND on row 8 of the breadboard.</p> <p> Note in this figure, the I2C bus uses breadboard rows 1 to 3.  The display cable only uses breadboard rows 4 to 9.</p> <p>We designed these connections with the following rules:</p> <ol> <li>The Clock (SCL) and Data (SDA) MUST be connected to rows 4 and 5 respectively because this is where SPI0 CLK and SPI0 TX are located.</li> <li>The other three signals RES, DC and CS can be on any pin so we will use the rows that make the cable connectors direct to rows 6, 7 and 9. Note that GND is on breadboard row 8 which I mark with a black marker.</li> </ol> <p>We have found that once we create these cable assemblies with hot glue to keep the pins in the right order it makes it much easier to connect the displays.</p> <p>Warning</p> <p>Note that we still MUST make sure that the black (or brown) wire in the wiring harness is connected to the GND. It is easy to get the cable reversed so make sure to double-check the cable orientation before you apply power to the Pico or USB.</p> <p>For younger students, don't be shy about providing a few color-coded hints on the breadboard to guide their assembly process as in the image above.</p>"},{"location":"setup/03-display-cable-harness/#spi-display-to-breadboard-connections","title":"SPI Display to Breadboard Connections","text":"<p>If you use a standard display cable the connectors will be as follows when reading the connection labels from the bottom of the display end to the top of the display:</p> Display Label Name Wire Color Breadboard Row VSS Ground Black or Brown BB Row 8 VCC Power Red 3.3 volt rail or row 5 on the right SCL Clock Orange BB Row 4 - GPIO 2 SDA Data Yellow BB Row 5 - GPIO 3 RES Reset Green BB Row 6 - GPIO 4 DC Data or Command Blue BB Row 7 CS Chip Select Purple BB Row 9 <p>Note that \"BB Row\" refers to the breadboard row which starts at row 1 at the top where the USB is.  Note that any row that ends in \"3\" or \"8\" is a GND.</p>"},{"location":"setup/03-display-cable-harness/#sample-code","title":"Sample Code","text":"<pre><code>import machine\nimport ssd1306\n\n# Pins for our standard display cable harness where GND is in row 8\n# Note the order from row 4 to 6, skip 8 for GND and 9\nSCL = machine.Pin(2) # SPI CLock bb row 4\nSDA = machine.Pin(3) # SPI Data (mosi) bb row 5\nRES = machine.Pin(4) # Reset bb rwo 6\nDC  = machine.Pin(5) # Data/command bb row 7\nCS  = machine.Pin(6) # Chip Select bb row 9\n\nspi=machine.SPI(0, sck=SCL, mosi=SDA)\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\n# erase the entire screen with black (0=black)\noled.fill(0)\n\n# place a hello message at point (0,0) in white (1=white text)\noled.text(\"Hello World!\", 0, 0, 1)\n\n# send the entire frame buffer to the display via the SPI bus\noled.show()\n</code></pre> <p>When you press \"Run\" on Thonny you should see \"Hello World!\" on the display.</p> <p></p>"},{"location":"setup/03-display-cable-harness/#debugging-tips","title":"Debugging Tips","text":"<p>One of the challenges of this project is that there is no status indicator on the display.  It usually works perfectly or it does not work at all.  The OLED displays are pretty robust. I have not had any fail yet.  But they require all seven wires to be hooked up perfectly, which can be a challenge!</p> <p>If your test \"Hello World!\" program does not run, please try the following debugging tips:</p> <ol> <li>Carefully check your connections from the display to the breadboard.  Sometimes the colors get mixed up.</li> <li>Verify that both the GND (black or brown) and the CS (purple) pins on the display are connected correctly.  It is easy to get the connections reversed.</li> <li>Trace the wires from their label on the the display to the right GPIO pin.  Make sure that your code references the right pin.</li> <li>Try checking the conductivity of the wires using an ohm meter with the power disconnected.</li> <li>Double check the pin numbers in your code.  Having just one pin number incorrect will cause the display to not work.</li> <li>With the power applied to the pico, check the voltage at the display ned on the VDD pin.  It should read 3.3 volts.</li> <li>If you have an extra display harness, try swapping that harness in for the current one.</li> <li>If you have another OLED display, try swapping that display in for the current display.</li> <li>According to the SSD1306 Datasheet the Chip Select (CS) pin is active low.  Which means it should be at GND for the device to be working.  With an ohm meter, check the voltage of the CS pin.  It should be near zero.</li> <li>If you have a logic analyzer, hook it up to the the SCL, SDA, DC, Reset and CS.  You should see CS be at GND and a clock signal on the SCL line.  The SDA, DC and RES signals should appear similar to the diagrams in the datasheets.</li> <li>If you see what looks like random noise or \"show\" on the display, it usually means that one of the DC/RES or CS wires has gotten reversed.  This means you are close!</li> </ol>"},{"location":"setup/04-led-clocks/","title":"LED Clocks","text":"<p>Our strategy for teaching is to provide a base set of examples of working clocks and watches. We then also provide a set of \"Challenges\" for students to go further.  One challenge is can you use simple LEDs to create your own clock?  This is where creativity comes in.</p> <p>Much of the creativity in this course relies on displaying time information in creative ways using both simple LEDs as well as using LED strips also known as NeoPixel strips.</p> <p>There are tradeoffs for each of these approaches.  There is no single answer and each student will have different curiosity.</p>"},{"location":"setup/04-led-clocks/#basic-custom-led-circuit-approach","title":"Basic Custom LED Circuit Approach","text":"This LED art-clock used individual RGB LEDs.  Each RGB LED required four independent soldering connections. <p>Using individual LEDs requires more wiring and the need to understand how to use current limiting resistors.  This approach promotes lower-level understanding of concepts such as current, voltage drop, resistors, current measuring and soldering. Students can place the LEDs in any arrangement on foam-core board, plexiglass or wood.</p> <p>Remember that a digit requires seven segments with each segment requiring up to 3 LEDs.  For a four digit clock that means you will need around 70 LEDs.</p>"},{"location":"setup/04-led-clocks/#neopixel-approach","title":"NeoPixel Approach","text":"This 12-element NeoPixel ring is perfect for a clock face.  Different colors can be used to display the hours, minutes and seconds. <p>NeoPixels are connivent since you can wire an entire clock display including the seven-segments for four digits, the flashing colon and the AM/PM indicator with a single LED strip or a string of addressable LED lights.  The focus will be on programming these strips to display the correct time.</p> <p>You can get NeoPixels in strips (the most common) but also in strings that can be easily moved into the pattern of an 7-segment display.</p> <p> </p> The NeoPixel string allows you to easily place the pixels in the shape of a 7-segment digit. <p>For more examples of using NeoPixels with MicroPython, please refer to the Moving Rainbow website.  This site has detailed tutorials appropriate for begging Python students.</p>"},{"location":"setup/04-led-clocks/#references","title":"References","text":"<ul> <li> <p>Daniel Mouritzen NeoPixel Clock in MicroPython - this uses a ESP32 but the code should be mostly the same.</p> </li> <li> <p>LED Arduino Clock on Instructables by Trask River Productions This incredible clock uses 5 packages of 25 RGB LEDs.  Each LED requires four connections for a total of almost 500 connections that must to be manually soldered and tested.</p> </li> </ul>"},{"location":"setup/05-ai-in-the-classroom/","title":"AI in the Classroom","text":""},{"location":"setup/05-ai-in-the-classroom/#sample-prompts","title":"Sample Prompts","text":"<p>This course provides many sample prompts you can use to give generative AI systems to explain code, generate sample code, generate tests and modify our existing code to add new features.</p> <p>Teachers can also use these prompts to create lesson plans and learning artifacts such as MicroSims to complement these resources.</p>"},{"location":"setup/05-ai-in-the-classroom/#leveraging-projects","title":"Leveraging Projects","text":"<p>We also encourage you to load the kit source code into a project area that your generative AI tools can access.  Both Anthropic's Claude.ai and OpenAI ChatGPT.  This allows you to do things like reference a sample program and say just like example 07-clock-face.py but with red digits.</p>"},{"location":"setup/05-button-print-test/","title":"Button Print Test","text":"<p>In this lab we will be testing if the three buttons have been wired up correctly.  When we press any of the three buttons we will see the event printed on the Thonny console.</p> <p>By printing to the console this lab is not dependant on the display being connected.  In the next lab we will also modify the lab to display the button state on the display.</p>"},{"location":"setup/05-button-print-test/#using-interrupt-request-functions","title":"Using Interrupt Request Functions","text":"<p>To print what button is being pressed, we will write three small python functions. We then will then have these functions run when the corresponding button is pressed by running the <code>irq</code> function.</p>"},{"location":"setup/05-button-print-test/#sample-code","title":"Sample Code","text":"<pre><code>from utime import sleep\nfrom machine import Pin\n\n# Sample Raspberry Pi Pico MicroPython three button press example\n\n# Button Pin GPIO Configuration\nBUTTON_1_PIN = 13\nBUTTON_2_PIN = 14\nBUTTON_3_PIN = 15\n\n# Create 3 button objects as inputs with pullup resistors\nbutton_1_pin = Pin(BUTTON_1_PIN, Pin.IN, Pin.PULL_UP)\nbutton_2_pin = Pin(BUTTON_2_PIN, Pin.IN, Pin.PULL_UP)\nbutton_3_pin = Pin(BUTTON_3_PIN, Pin.IN, Pin.PULL_UP)\n\n# These functions gets called every time a button is pressed.\ndef button_1_pressed(pin):\n    print('Button 1 pressed')\ndef button_2_pressed(pin):\n    print('Button 2 pressed')\ndef button_3_pressed(pin):\n    print('Button 3 pressed')\n\n# now we register the button handler functions using the irq setter method for each pin\nbutton_1_pin.irq(trigger=Pin.IRQ_FALLING, handler = button_1_pressed)\nbutton_2_pin.irq(trigger=Pin.IRQ_FALLING, handler = button_2_pressed)\nbutton_3_pin.irq(trigger=Pin.IRQ_FALLING, handler = button_3_pressed)\n\n# we don't do anything in the main loop but sleep\nwhile True:\n    sleep(1)\n</code></pre>"},{"location":"setup/06-pico-w-setup/","title":"Pico W Setup","text":"<p>When installing the Pico \"W\" (Wireless), you will need to download a different version of the MicroPython runtime.</p> <p>The list of runtime images is on the https://micropython.org/download/RPI_PICO_W page.</p> <p>In this example, we are using v1.24.1 (2024-11-29) .uf2.</p> <p>Here is the image from Thonny that shows what version you are using.  Note that you MUST select BOTSEL button before Thonny will download the new MicroPython runtime.</p> <p></p>"},{"location":"setup/07-sound/","title":"Adding Sound to Your Clock","text":"<p>Many students want to add alarm features to their clock projects. The Raspberry Pi Pico can generate tones using Pulse Width Modulation (PWM) in MicroPython. Here are the key options for audio output devices:</p>"},{"location":"setup/07-sound/#piezo-ceramic-disc","title":"Piezo Ceramic Disc","text":"<p>A thin ceramic disc that converts electrical signals into sound through mechanical vibration.</p> <p>Pros: - Extremely low cost (\\(0.50-\\)2 each) - Very simple to connect (just 2 wires) - No additional components needed - Durable and reliable - Perfect for basic beeps and alarms - Uses minimal power</p> <p>Cons: - Limited sound quality - Can only produce simple tones - Relatively quiet - Not suitable for music playback - Can be harsh-sounding at high volumes</p> <p>Typical Educational Lab Cost: $10-15 for a pack of 10 discs</p>"},{"location":"setup/07-sound/#piezo-speakers","title":"Piezo Speakers","text":"<p>Small enclosed speakers with a built-in resonant chamber.</p> <p>Pros: - Low cost ($2-5 each) - Better sound quality than bare ceramic discs - Built-in enclosure improves volume - Simple 2-wire connection - Good for alarms and basic melodies - More pleasant sound than bare discs</p> <p>Cons: - Still limited audio quality - Not suitable for music playback - Slightly more expensive than bare discs - Fixed resonant frequency can affect tone quality</p> <p>Typical Educational Lab Cost: $20-30 for a pack of 10 speakers</p>"},{"location":"setup/07-sound/#standard-speakers","title":"Standard Speakers","text":"<p>Traditional cone speakers with magnets and voice coils.</p> <p>Pros: - Much better sound quality - Can play actual music - Wide frequency response - Available in various sizes - Good volume levels</p> <p>Cons: - More expensive ($4-15 each) - Requires amplification circuit - More complex wiring - Higher power requirements - Takes up more space - More fragile than piezos</p> <p>Typical Educational Lab Cost: $20-60 for a set of 5 small speakers</p>"},{"location":"setup/07-sound/#digital-to-analog-converters-dac","title":"Digital to Analog Converters (DAC)","text":"<p>Chips that convert digital signals to analog audio.</p> <p>Pros: - High-quality audio output - Can play music and complex sounds - Professional audio capabilities - Clean signal output - Multiple channels possible</p> <p>Cons: - Most expensive option ($2-5 per chip) - Requires additional components - Complex wiring and setup - Needs amplification - Requires more advanced programming - May need level shifting circuits</p> <p>Typical Educational Lab Cost: $20-50 for a complete setup with 5 DAC modules</p>"},{"location":"setup/07-sound/#microsd-readers","title":"MicroSD Readers","text":"<p>Card readers for storing and playing audio files.</p> <p>Pros: - Can store many sound files - Allows for custom sounds - Easy to update sounds - Works well with DACs - Flexible storage options</p> <p>Cons: - Additional cost ($2-5 per reader) - Requires SD card library - More complex programming - Needs file system management - Additional power requirements - Must handle card formatting</p> <p>Typical Educational Lab Cost: $30-40 for a set of 5 readers plus cards</p> <p>Recommendation for School Labs: For a basic classroom set serving 20 students:</p> <ul> <li>20 Piezo ceramic discs ($10)</li> <li>10 Piezo speakers ($15)</li> <li>5 small standard speakers ($30)</li> <li>4 DAC modules ($20)</li> <li>4 MicroSD readers ($20)</li> </ul> <p>Total recommended budget: ~$120 for a well-rounded audio lab setup that allows students to experiment with different sound options while keeping the basic piezo components affordable for everyone.</p>"},{"location":"sims/","title":"Clocks and Watches Micro Simulations","text":"<p>Learning Graph</p> <p>Binary Clock</p>"},{"location":"sims/4-digits/","title":"Example of a Four-Digit Digital Clock Face","text":"<p>Four Digit Digital Clock</p>"},{"location":"sims/analog-clock/","title":"Analog Clock","text":"Analog Clock <p>Run Analog Clock MicroSim</p>"},{"location":"sims/analog-clock/#prompt","title":"Prompt","text":"<pre><code>Create a single p5.js sketch file that uses a 400x400 canvas.\nThe file is a simulation of an analog clock face.\nThe clock face has a black background.\nThe clock has white hands for the minute and hour hand.\nThe clock as a red second hand.\nThere are two modes: manual and automtic\nManual mode allows the use to manually set the time using three sliders for hours, minute and seconds.\nAutomatic mode use the local time to update the display.\nAdd labels and values for the sliders.\nMake sure to reenable the controls as we switch back to manual mode.\n</code></pre>"},{"location":"sims/analog-clock/#code","title":"Code","text":"<p>This is a wonderful lab to demonstrate some use of the trigonomic functions sine() and cosine().  We ask the question:</p> <p>Write some Python code that will take in the seconds as a number from 0 to 59 and it will return the x and y positions of the tip of the second hand.</p> <pre><code>// Draw second hand\n// convert seconds to radians\nsecondHand = map(sc, 0, 60, 0, TWO_PI) - HALF_PI;\n// draw a line from the center of the canvas to the endpoint\nline(0, 0, cos(secondHand) * canvasSize / 2.5, \n           sin(secondHand) * canvasSize / 2.5);\n</code></pre>"},{"location":"sims/analog-clock/#full-program-source","title":"FUll Program Source","text":"<pre><code>let canvasSize = 400;\nlet hourHand, minuteHand, secondHand;\nlet hourSlider, minuteSlider, secondSlider;\nlet manualMode = true;\n\nfunction setup() {\n  const canvas = createCanvas(400, 400);\n  // use this line in the web\n  canvas.parent('canvas-container');\n  // use this in editor\n  // createCanvas(canvasSize, canvasSize);\n  background(0);\n\n  // Create sliders for manual mode\n  hourSlider = createSlider(0, 11, 0);\n  hourSlider.position(10, canvasSize + 10);\n\n  minuteSlider = createSlider(0, 59, 0);\n  minuteSlider.position(10, canvasSize + 40);\n\n  secondSlider = createSlider(0, 59, 0);\n  secondSlider.position(10, canvasSize + 70);\n\n  let modeButton = createButton('Switch Mode');\n  modeButton.position(10, canvasSize + 100);\n  modeButton.mousePressed(switchMode);\n}\n\nfunction draw() {\n  background(0);\n  translate(canvasSize / 2, canvasSize / 2);\n\n  let hr, mn, sc;\n  if (manualMode) {\n    hr = hourSlider.value();\n    mn = minuteSlider.value();\n    sc = secondSlider.value();\n  } else {\n    let now = new Date();\n    hr = now.getHours() % 12;\n    mn = now.getMinutes();\n    sc = now.getSeconds();\n  }\n\n  // Draw hour hand\n  stroke(255);\n  strokeWeight(10);\n  hourHand = map(hr, 0, 12, 0, TWO_PI) - HALF_PI;\n  line(0, 0, cos(hourHand) * canvasSize / 4, sin(hourHand) * canvasSize / 4);\n\n  // Draw minute hand\n  strokeWeight(8);\n  minuteHand = map(mn, 0, 60, 0, TWO_PI) - HALF_PI;\n  line(0, 0, cos(minuteHand) * canvasSize / 3, sin(minuteHand) * canvasSize / 3);\n\n  // Draw second hand\n  stroke(255, 0, 0);\n  strokeWeight(4);\n  secondHand = map(sc, 0, 60, 0, TWO_PI) - HALF_PI;\n  line(0, 0, cos(secondHand) * canvasSize / 2.5, sin(secondHand) * canvasSize / 2.5);\n}\n\nfunction switchMode() {\n  manualMode = !manualMode;\n\n  // disable the controls\n  if manualMode {\n    hourSlider.attribute('disabled', !manualMode);\n    minuteSlider.attribute('disabled', !manualMode);\n    secondSlider.attribute('disabled', !manualMode);\n  } else {\n    hourSlider.attribute('enabled', !manualMode);\n    minuteSlider.attribute('enabled', !manualMode);\n    secondSlider.attribute('enabled', !manualMode);\n  }\n\n}\n</code></pre>"},{"location":"sims/analog-clock/#version-2","title":"Version 2","text":"<p>Version 2 - Blue clock with tick marks</p>"},{"location":"sims/architectural-levels/","title":"Architectural Levels","text":""},{"location":"sims/architectural-levels/#architectural-levels-zoom","title":"Architectural  Levels Zoom","text":"<p>P5.js Version</p> <p>React Main</p> <p>Prompt</p> <p>Create a MicroSim that shows different levels of Zoom. The highest level shows a single component and as you increase the Zoom level it shows more components.</p> <p>Level 1: Just the Clock as a rectangle centered on the canvas with the label \"Clock\" in a large font in the center Level 2: The architecture drawing now shows two rectangular components: a \"Display\" at the top and \"Microcontroller\" at the bottom. Each has a label in the center Level 3: The architecture show shows three components: The Display, the \"SPI Bus \"(as a vertical double sided arrow) and the \"Microcontroller\" below Level 4: The architecture now shows a \"Display\", \"SPI Bus\", \"MicroController\" and the \"RTC\" to the right of the Microcontroller Level 5: Same as Level 4 but add a \"I2C Bus\" between the \"Microcontroller\" and the \"RTC\" Level 6: Same as Level 5 but now add \"Buttons\" to the left of the \"MicroContoller\" Level 7: Same as Level 6 but now add \"Power\" below all the components Level 8: Same as Level 7 but now add \"Speaker\" to the left of the \"Microcontroller\" Level 9: Same as level 8 but now show the \"Microcontroller\" as also having \"Core 1\" and \"Core 2\" inside of it Level 10\" Same as Level 9 but now have PIO as an additional component within the \"Microcontroller\"</p>"},{"location":"sims/architectural-levels/#response","title":"Response","text":"<p>I'll help create a MicroSim that shows different architectural zoom levels of your clock system. I'll use React with SVG for the visualization and add a slider to control the zoom level.</p> <p>I've created an interactive visualization that shows the clock architecture at different zoom levels. You can use the slider at the bottom to adjust the zoom level from 1-10, revealing more details of the system architecture at each level:</p> <ol> <li>Level 1 shows just the basic clock component</li> <li>Level 2 adds the Display and Microcontroller</li> <li>Level 3 shows the SPI bus connection</li> <li>Level 4 adds the RTC component</li> <li>Level 5 shows the I2C bus connection to the RTC</li> <li>Level 6 adds the Buttons</li> <li>Level 7 adds the Power system</li> <li>Level 8 includes the Speaker</li> <li>Level 9 shows the dual cores inside the Microcontroller</li> <li>Level 10 adds the PIO within the Microcontroller</li> </ol> <p>The visualization uses SVG for crisp rendering at any scale and includes: - Color-coded components - Labeled connections - Proper arrow markers for buses - A responsive layout that centers in the available space - Smooth transitions between levels</p> <p>You can adjust the zoom level using the slider below the diagram. Would you like me to modify any aspects of the visualization?</p>"},{"location":"sims/battery-drain/","title":"Battery Drain","text":"Battery Drain <p>Run the Battery Drain Demo</p> <p>Edit the Simulation</p>"},{"location":"sims/battery-drain/#about-the-battery-drain-microsim","title":"About The Battery Drain MicroSim","text":"<p>This MicroSim teaches students how batteries work in robots.  The student can adjust the speed of the motor.  But the more power the motor draws, the faster the battery drains.  When the motor is off, there is no drain.  When the battery is fully drained the motor will no longer turn.</p>"},{"location":"sims/battery-drain/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Generate a p5.js file on a 400x400 canvas that demonstrates the\nrate that a battery is discharged when it is powering a motor.\nAdd a slider at the bottom of the canvas that allows the user\nto adjust the speed of the motor.  Place the battery on the\nleft side.  Make the negative sign be at the bottom and \nuse a black filled rect.  Make the battery top be positive\nand use a gold filled rect to draw it.  Draw wires from\nthe battery's positive and negative to a motor in the right side.\nThe motor should drive a circle that spins faster as the slider is changed.\nThe motor should only spin if we have power.\n</code></pre>"},{"location":"sims/battery-drain/#sample-code","title":"Sample Code","text":"<pre><code>// battery drain\n// Animate a motor that drains a battery faster the more power is used\nlet canvasWidth = 400;\nlet drawHeight = 400;\nlet canvasHeight = 430;\nlet motorSpeedSlider;\nlet motorSpeed;\nlet batteryLevel = 100;\nlet dischargeRate;\nlet sliderLeftMargin = 100;\n\nfunction setup() {\n  const canvas = createCanvas(canvasWidth, canvasHeight);\n  //\n  textSize(16);\n\n  motorSpeedSlider = createSlider(0, 100, 50);\n  motorSpeedSlider.position(sliderLeftMargin, drawHeight + 10);\n  motorSpeedSlider.style('width', canvasWidth - sliderLeftMargin - 20 + 'px')\n\n  frameRate(60);\n}\n\nfunction draw() {\n  fill(245);\n  rect(0,0,canvasWidth,drawHeight);\n  fill('white');\n  rect(0,drawHeight,canvasWidth,canvasHeight-drawHeight);\n\n  motorSpeed = motorSpeedSlider.value();\n  // Battery representation\n  drawBattery();\n\n  // Wires from battery to motor\n  stroke(0);\n  // top wire\n  line(50, 50, 350, 50);\n  // bottom wire\n  line(50, 350, 350, 350);\n  line(350, 50, 350, 350);\n\n  // Motor and spinning circle\n  drawMotor();\n\n  // Update battery discharge\n  updateBattery();\n  noStroke();\n  fill('black');\n  text(\"Speed:\"+motorSpeed, 10, drawHeight+25);\n}\n\nfunction drawBattery() {\n  // Battery body\n\n  percentGold = .4\n  // Positive terminal\n  fill('gold'); // Gold color\n  rect(20, 50, 50, 300*percentGold);\n\n  // Negative terminal\n  fill('black');\n  rect(20, 350*percentGold, 50, 350*(1-percentGold));\n\n  // Battery level\n  let levelHeight = map(batteryLevel, 0, 100, 0, 300);\n  fill(0, 255, 0);\n  rect(30, 350 - levelHeight, 30, levelHeight);\n}\n\n// draw a spinning motor if we have power\nfunction drawMotor() {\n  fill(150);\n  ellipse(350, 200, 100, 100); // Motor body\n\n  // draw the spinner if we have power\n  if (batteryLevel &gt; 1) {\n   push();\n      translate(350, 200);\n      rotate(frameCount / 50 * motorSpeed);\n      fill(0, 0, 255);\n      ellipse(0, 40, 20, 20); // Spinning circle\n   pop();\n  }\n}\n\n// the battery level goes down with time\nfunction updateBattery() {\n  dischargeRate = motorSpeedSlider.value() / 1000;\n  batteryLevel -= dischargeRate;\n  batteryLevel = max(batteryLevel, 0);\n}\n</code></pre> <p>Challenges</p> <ol> <li>Add a label that shows the percent of charge remaining</li> <li>Add a label that predicts how long the battery will last at the current discharge rate</li> <li>Add another button called \"Recharge\" that will slowly recharge the battery</li> <li>Add animation to the wires of red dots moving along the wires.  Make the dots go faster at a higher power.</li> <li>Make the battery explode if you charge it too quickly</li> </ol>"},{"location":"sims/battery-drain/#lesson-plans","title":"Lesson Plans","text":""},{"location":"sims/battery-drain/#5th-grade-robotics-class-lesson-plan","title":"5th Grade Robotics Class Lesson Plan","text":""},{"location":"sims/battery-drain/#objective","title":"Objective","text":"<ul> <li>Understand the concept of battery discharge and its application in powering motors, particularly in robotics.</li> <li>Develop an understanding of how adjusting variables (like motor speed) can impact power consumption.</li> <li>Ask questions about what we do with batteries when they are discharged?</li> </ul>"},{"location":"sims/battery-drain/#duration","title":"Duration","text":"<ul> <li>1 hour</li> </ul>"},{"location":"sims/battery-drain/#materials","title":"Materials","text":"<ul> <li>Computers with internet access to use the p5.js Web Editor.</li> <li>Projector to demonstrate the p5.js simulation.</li> <li>Printed screenshots of the p5.js canvas setup (for reference).</li> </ul>"},{"location":"sims/battery-drain/#introduction-10-minutes","title":"Introduction (10 minutes)","text":"<ul> <li>Interactive Questioning: Begin by asking students about their experiences with batteries. \"What devices at home use batteries?\" \"Have you noticed how the performance changes as the battery drains?\"</li> <li>Relevance to Robotics: Discuss why robots need batteries, linking to their own experiences with battery-powered devices.</li> </ul>"},{"location":"sims/battery-drain/#demonstration-of-the-simulation-10-minutes","title":"Demonstration of the Simulation (10 minutes)","text":"<ul> <li>Show the p5.js Simulation: Project the simulation on the screen. Demonstrate how the motor's speed changes with the slider and how this affects battery discharge.</li> <li>Explain the Components: Point out the battery, the wires, the motor, and the spinning circle, explaining their roles.</li> </ul>"},{"location":"sims/battery-drain/#group-activity-experimenting-with-the-simulation-20-minutes","title":"Group Activity: Experimenting with the Simulation (20 minutes)","text":"<ul> <li>Hands-On Exploration: Students work in pairs on computers to experiment with the simulation.</li> <li>Guided Inquiry: Encourage students to observe what happens as they adjust the motor speed. Does the battery discharge faster at higher speeds?</li> </ul>"},{"location":"sims/battery-drain/#discussion-and-reflection-15-minutes","title":"Discussion and Reflection (15 minutes)","text":"<ul> <li>Group Discussion: Reconvene as a class and discuss observations. Key questions: \"How did changing the motor speed affect the battery life?\" \"Why is this important for designing robots?\"</li> <li>Connecting to Real Life: Relate the activity to real-world scenarios. \"How might this knowledge impact the way we design battery-powered devices or robots?\"</li> </ul>"},{"location":"sims/battery-drain/#conclusion-5-minutes","title":"Conclusion (5 minutes)","text":"<ul> <li>Summarize Key Learnings: Reinforce the importance of understanding battery usage in robotics and everyday devices.</li> <li>Reflect on the Activity: Ask students to share one new thing they learned and how they might apply this knowledge.</li> </ul>"},{"location":"sims/battery-drain/#assessment","title":"Assessment","text":"<ul> <li>Participation and engagement during the activity.</li> <li>Responses during the discussion, reflecting understanding of the concept.</li> </ul>"},{"location":"sims/battery-drain/#follow-up","title":"Follow-Up","text":"<ul> <li>In the next lesson, explore other factors affecting battery life in robots, like weight or the type of task performed.</li> <li>Assign a small project where students design a simple battery-powered device or robot, considering battery life.</li> </ul>"},{"location":"sims/binary-clock/","title":"Binary Clock","text":"<p>Run the Binary Clock Vertical Column MicroSim</p> <p>Run the Vertical Column Binary Clock MicroSim Edit the Vertical Column Binary Clock  MicroSim</p>"},{"location":"sims/binary-clock/#using-an-iframe","title":"Using an IFrame","text":"<pre><code>&lt;iframe src=\"./binary-clock-vertical.html\" width=\"420\" height=\"295\" scrolling=\"no\"\n  style=\"overflow: hidden;\"&gt;&lt;/iframe&gt;\n</code></pre> <pre><code>\n</code></pre>"},{"location":"sims/binary-clock/#horizontal-binary-clock-microsim","title":"Horizontal Binary Clock MicroSim","text":"<p>Edit the Horizontal Microsim</p>"},{"location":"sims/binary-number/","title":"Binary Number","text":"<p>A binary number is one where each of the digits can only be a 0 or a 1.  The values will double with each position.  So the left-most digit is 0 or 1,   the second bit is 0 or 2, the third is 0 or 4 and the fourth is 0 or 8. You can generate any number from 0 to 15 by adding the values.</p> <ul> <li>Binary Number 4-Bit Demo</li> <li>Binary Number 8-Bit Demo</li> </ul>"},{"location":"sims/binary-number/#prompt","title":"Prompt","text":"<pre><code>Create a simulation of a 4-bit binary number.\nAdd buttons that toggle each of the four bits. \nAdd a text output that shows the decimal equivalent of the binary number.\n</code></pre>"},{"location":"sims/binary-number/#sample-response","title":"Sample Response","text":"<pre><code>// Global canvas dimensions\nlet canvasWidth = 330;\nlet canvasHeight = 120;\n\n// Binary bits and decimal value\nlet bits = [0, 0, 0, 0];\nlet decimalValue = 0;\n\nfunction setup() {\n  createCanvas(canvasWidth, canvasHeight);\n  textSize(24);\n  background(245);\n\n  // Create toggle buttons for each bit with correct labeling\n  for (let i = 0; i &lt; 4; i++) {\n    let btn = createButton('Bit ' + i);\n    btn.position(20 + (3 - i) * 80, 50); // Placing buttons with Bit 3 on the left and Bit 0 on the right\n    btn.mousePressed(() =&gt; toggleBit(i));\n  }\n}\n\nfunction draw() {\n  // Clear the previous frame\n  clear();\n  background(245);\n\n  // Draw binary bits\n  for (let i = 0; i &lt; bits.length; i++) {\n    text(bits[i], 40 + (3 - i) * 80, 30); // Displaying bits with Bit 3 on the left and Bit 0 on the right\n  }\n\n  // Calculate and draw the decimal value\n  decimalValue = binaryToDecimal(bits);\n  text('Decimal: ' + decimalValue, 20, 110);\n}\n\n// Toggle bit value\nfunction toggleBit(index) {\n  bits[index] = bits[index] === 0 ? 1 : 0;\n}\n\n// Convert binary array to decimal\nfunction binaryToDecimal(binaryArray) {\n  let decimal = 0;\n  for (let i = 0; i &lt; binaryArray.length; i++) {\n    decimal += binaryArray[i] * Math.pow(2, i);\n  }\n  return decimal;\n}\n</code></pre>"},{"location":"sims/binary-number/#learnings-from-the-response","title":"Learnings from The Response","text":"<ol> <li>How to set up an array of buttons each with different actions</li> <li>How to use the pow(2, i) to convert a binary to decimal value</li> <li>How to setup a tobbleBit(index) function using the <code>?</code> and <code>:</code> syntax</li> </ol>"},{"location":"sims/binary-number/#lesson-plan","title":"Lesson Plan","text":"<p>Objective:</p> <p>Students will understand the binary number system and how it is used in computer science.  They will learn to convert binary numbers to decimal numbers and vice versa.</p> <p>Grade Level: 9th Grade</p> <p>Duration: 1-2 class periods (45-90 minutes)</p> <p>Materials:</p> <ol> <li>Computers with internet access (or offline environment set up with p5.js).</li> <li>Projector to demonstrate the simulation.</li> <li>Link to the simulation.</li> <li>Worksheets or online notebooks for binary-to-decimal conversion exercises.</li> <li>Whiteboard and markers.</li> </ol>"},{"location":"sims/binary-number/#lesson-outline","title":"Lesson Outline:","text":"<ol> <li> <p>Introduction to Binary Numbers (15 minutes):</p> </li> <li> <p>Begin with a discussion on number systems, focusing on the decimal system.</p> </li> <li>Introduce the binary number system, explaining its base-2 nature.</li> <li> <p>Discuss the significance of binary numbers in computer science.</p> </li> <li> <p>Demonstration of the Simulation (10 minutes):</p> </li> <li> <p>Project the simulation on the screen.</p> </li> <li>Explain the interface, pointing out the bits, their significance, and the decimal conversion.</li> <li> <p>Demonstrate toggling the bits and observing the decimal output.</p> </li> <li> <p>Interactive Session with Simulation (20 minutes):</p> </li> <li> <p>Allow students to experiment with the simulation on their computers.</p> </li> <li>Encourage them to predict the decimal output before toggling the bits.</li> <li> <p>Facilitate a discussion about their observations and insights.</p> </li> <li> <p>Binary to Decimal Conversion Exercise (15 minutes):</p> </li> <li> <p>Distribute worksheets with binary numbers.</p> </li> <li>Instruct students to convert them to decimal numbers using the simulation as a reference.</li> <li> <p>Review the answers as a class, discussing any common errors or misconceptions.</p> </li> <li> <p>Group Activity: Real-World Applications (15-30 minutes):</p> </li> <li> <p>Divide students into small groups.</p> </li> <li>Assign each group to research and present a short explanation about a real-world application of binary numbers (e.g., digital storage, computer processors).</li> <li> <p>Facilitate a class discussion on these applications, linking them back to the simulation.</p> </li> <li> <p>Wrap-up and Reflection (5-10 minutes):</p> </li> <li> <p>Summarize key takeaways from the lesson.</p> </li> <li>Encourage students to reflect on what they learned and how they might see binary numbers in their daily lives.</li> <li>Answer any remaining questions.</li> </ol>"},{"location":"sims/binary-number/#assessment","title":"Assessment","text":"<ul> <li>Evaluate students based on their participation in activities and discussions.</li> <li>Review their worksheets for accuracy in binary to decimal conversion.</li> <li>Assess group presentations for understanding of real-world applications.</li> </ul>"},{"location":"sims/binary-number/#extension-activities","title":"Extension Activities","text":"<ul> <li>Extend the simulation to be 8, 16, 32 and 64 bits</li> <li>Discuss what the shift-left and shift-right functions will do.  Hint: how would you double the number?</li> <li>Introduce the concept of hexadecimal numbers and how they relate to binary and decimal systems.</li> <li>Create a project where students develop their own simple binary-based simulations or games using p5.js.</li> <li>Discuss the process of adding binary numbers.</li> </ul>"},{"location":"sims/binary-number/#references","title":"References","text":"<ul> <li>ChatGPT Transcript - this demonstrates the iterative nature of prompting including giving up and fixing the code myself after multiple attempts.</li> </ul>"},{"location":"sims/learning-graph/","title":"Learning Graph for Clocks and Watches with MicroPython","text":"<p>View Learning Graph MicroSim</p>"},{"location":"sims/seven-segment-display/","title":"7-Segment Display","text":"<p>Demo</p>"},{"location":"sims/shift-register/","title":"Shift Register MicroSim","text":"<p>Run Shift Register MicroSim</p> <p>Logic Analyzer View</p>"},{"location":"sims/stopwatch/","title":"Stopwatch MicroSim","text":"<p>Run the Stopwatch MicroSim</p> <p>Edit the Stopwatch MicroSim</p> <p>The Stopwatch MicroSim allows you to simulate the actual stopwatch lab here: Stopwatch Lab</p>"},{"location":"sims/templates/","title":"MicroSim Templates","text":"<p>Run the MicroSim Template Edit this MicroSim</p> <p>These templates are used to help guild your generative AI responses for consistency of the user interface.</p> <p>{ .md-button .md-button--primary }</p>"},{"location":"sims/themes/","title":"Clock Face Themes","text":"<p>Analog Clock Face Themes</p>"},{"location":"sims/themes/#background-color","title":"Background Color","text":""},{"location":"sims/themes/#color-selection","title":"Color Selection","text":""},{"location":"sims/themes/#hand-types","title":"Hand Types","text":""},{"location":"sims/themes/#tic-mark-types","title":"Tic Mark Types","text":""},{"location":"sims/themes/#digit-types","title":"Digit Types","text":""},{"location":"sims/themes/#four-digits","title":"Four Digits","text":""},{"location":"sims/themes/#12-digits","title":"12 Digits","text":""}]}