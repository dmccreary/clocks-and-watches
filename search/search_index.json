{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MicroPython Clocks and Watches","text":"<p>Welcome to the MicroPython Clocks and Watchs website.</p> <p></p>"},{"location":"#our-mission","title":"Our Mission","text":"<p>The mission of this website is to serve as a resource for teachers, mentors and students who want to learn how to us the popular MicroPython language to enable high-school students design their own digital clocks and watches using Python. It contains instructions for finding low-cost parts (under $20) and customizing your own custom clock and watch displays.</p> <p>These projects have only recently been possible due to the following developments:</p> <ol> <li>The availability of low-cost high-contrast OLED and TFT displays for as low as $7 each.  When we use the $4 Raspberry Pi Pico our classrooms can create a development systems for under $15.</li> <li>The support of highly optimized drawing of complex ellipse and polygon shapes into the Framebuf by the MicroPython runtime. This only became avaialbe in version 20 of the standard MicroPython runtime relaseed in April of 2023.  Before this every clock and watch project used custom math functions that slowed drawing times.</li> <li>The ability of WiFi enabled microcontrollers that can synchronize with centralized time services using standard WiFi networks. We use the $5 Raspberry Pi Pico W in many of our projects.</li> </ol> <p>Our goal is to provide fun ways to teach computational thinking to a wide variety of students from 6th to 12th grade.  If you can type we have fun lesson plans from drawing simple shapes to complex clock and watch face designs.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>I want to thank everyone in the MicroPython community for sharing their code.  Each of the displays require MicroPython drivers that require special features to keep drawing fast.  We could not have the high-quality lesson plans without your contributions.  If I have not referenced the cool features of your drivers, please let me know!</p>"},{"location":"#feedback-and-comments","title":"Feedback and Comments","text":"<p>If you have any comments or feedback, please feel free to post these to our GitHub Issues.  I don't check these issues every day, so please be patient and connect with others in the MicroPython community if you have urgent questions for a classroom.</p> <p>Good Luck! Dan McCreary on LinkedIn</p> <p>Demo code for the Waveshare RP2040 watch display.</p> <p>Waveshare RP2040-LCD-1.28</p> <p>Ebay Listing for $21</p>"},{"location":"about/","title":"About the MicroPython Clocks and Watchs Site","text":"<p>My STEM students often hold a special facination with timekeeping. I don't know exactly what it is that gets them so excited about these projects.  But the bottom line is they quickly become motiviated to learn Python to create their own timekeeping devices that are customized to their interests.</p> <p>At the core of  Project Based Learning (PBL)  is the desire to allow students to pick their own projects.  My role  as a mentor is to have a rich set of projects they can get  started on.  They may not understand all the components, but  to fix and modify the projects they end up learning  faster than if I gave them a dozen lectures with PowerPoint.</p> <p>## The Timeless Allure of Timekeeping: Sparking a Passion for Coding with MicroPython Clocks and Watches</p> <p>In a world driven by digital innovation, the essence of time remains universally compelling. From the ancient sundials to the modern-day smartwatches, humans have always been fascinated by the pursuit of measuring time. This intrigue, particularly among the younger generation, is why a library of fun MicroPython Clocks and Watches serves as an exceptional entry point into the universe of coding and computational thinking.</p>"},{"location":"about/#tapping-into-the-childs-natural-curiosity","title":"Tapping into the Child's Natural Curiosity","text":"<p>Children possess an innate sense of wonder. The ticking of a clock or the changing digits on a digital watch captivates their imagination. They question how it works, what makes it tick, and how they can possibly create one of their own. By introducing them to a collection of engaging MicroPython timekeeping projects, we are not only answering their questions but also kindling a flame of creativity and innovation.</p>"},{"location":"about/#from-boring-lectures-to-tangible-results","title":"From Boring Lectures to Tangible Results","text":"<p>Traditional pedagogical methods, characterized by long hours of lectures, often fail to hold the attention of young learners. However, project-based learning flips this paradigm. When a child is given the tools and guidance to create their very own digital clock or watch, the learning process transforms. They're no longer passive recipients of information but active creators, brimming with ideas and enthusiasm.</p> <p>A MicroPython Clock project, for instance, isn\u2019t just a coding endeavor; it's a journey. From understanding the concept, drafting the design, writing the first line of code, to finally witnessing their creation come to life \u2013 every step is a lesson in problem-solving, critical thinking, and perseverance.</p>"},{"location":"about/#building-blocks-of-computational-thinking","title":"Building Blocks of Computational Thinking","text":"<p>Computational thinking is a cornerstone of modern education. It\u2019s not just about writing code, but a way of approaching problems logically, breaking them down into smaller tasks, and finding efficient solutions. By creating a timekeeping device, children undergo a practical exercise in computational thinking. They decide the features they want, debug issues, and constantly refine their work, all while having fun!</p>"},{"location":"about/#the-joy-of-shared-creation","title":"The Joy of Shared Creation","text":"<p>Imagine a library where each clock or watch has its unique story, representing a young coder's journey. Sharing these creations allows children to learn from each other, celebrate their achievements, and draw inspiration. Such a collaborative environment fosters not just coding skills but also empathy, teamwork, and a sense of community.</p>"},{"location":"about/#in-conclusion","title":"In Conclusion","text":"<p>A library of MicroPython Clocks and Watches isn't just a collection of projects; it\u2019s a treasure trove of experiences, learnings, and memories. By introducing children to the magic of timekeeping in the digital age, we are equipping them with skills for the future, fostering a love for coding, and most importantly, reminding them that learning can be both fun and profoundly meaningful. The timeless allure of time, coupled with the dynamic world of coding, creates a perfect blend to mold the innovators and thinkers of tomorrow.</p>"},{"location":"contact/","title":"Contact","text":"<p>Dan McCreary on LinkedIn</p>"},{"location":"references/","title":"References","text":"<ol> <li>watchmaker</li> <li>Makerfabs GC9A01 1.28 Inch Round LCD Module </li> <li>Dronebotworksho Using GC9A01 Round LCD Modules</li> <li>DroneBot Workshop YouTube Video</li> <li>Mr. Volt YouTube Exotic Round Displays and How to Use Them  - this videos demonstrates some very new round displays up to 5 inches.  These would be ideal for robot faces but they cost up to $200 for the larger displays.</li> <li>NTP Pool Project</li> <li>Pico Displays and Fonts</li> <li>Analog Clock Face Generator - a wonderful way to try out different designs.  This web app allows you to change the format of the markers, digits and hands.</li> <li>Blocklayer Clock Face</li> </ol>"},{"location":"kits/","title":"Introduction to Clock and Watch Kits","text":""},{"location":"kits/#standard-oled","title":"Standard OLED","text":""},{"location":"kits/#raspberry-pi-and-monchorme-oled","title":"Raspberry Pi and Monchorme OLED","text":""},{"location":"kits/#raspberry-pi-w-and-monchorme-oled","title":"Raspberry Pi W and Monchorme OLED","text":""},{"location":"kits/#lilygo-rp240","title":"LilyGo RP240","text":""},{"location":"kits/gc9a01/","title":"GC9A01 Display","text":"<p>The gc9a01 is a chip that drives a 240x240 round display that is connected to a microcontroller by an SPI display.</p> <p>The current gc9a01 drivers are not compatable with the current release of framebuf in the standard MicroPython runtime.  Therefore the standard framebuf functions such as <code>ellipse()</code> and <code>poly()</code> functions do not work.  This limits the portability of many of or clock and watch example.</p> <p>The good news is that you can do some drawing operations faster and your code does not have to run the <code>show()</code> command.  Functions such as <code>line()</code> will draw directly to the display.</p> <p>To connect we need to either use a firmware version or load the driver into the /lib directory and we can then use the following code:</p> <pre><code>from machine import Pin, SPI\nimport gc9a01 as gc9a01\n\n# hardware config\nSCL_PIN = 2\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\nRST_PIN = 6\nspi = SPI(0, baudrate=60000000, sck=Pin(SCL_PIN), mosi=Pin(SDA_PIN))\n\n# initialize the display\ntft = gc9a01.GC9A01(\n    spi,\n    dc=Pin(DC_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT),\n    reset=Pin(RST_PIN, Pin.OUT),\n    rotation=0)\n\ntft.fill(gc9a01.BLACK)\n\n# x, y, width, height\n# red\ntft.fill_rect(50,  75, 50, 60, gc9a01.color565(255,0,0))\n# green\ntft.fill_rect(100, 75, 50, 60, gc9a01.color565(0,255,0))\n# blue\ntft.fill_rect(150, 75, 50, 60, gc9a01.color565(0,0,255))\n</code></pre>"},{"location":"kits/gc9a01/#rotation","title":"Rotation","text":"<p>The driver supports 8 different types of rotations:</p> <ul> <li>0 - PORTRAIT</li> <li>1 - LANDSCAPE</li> <li>2 - INVERTED PORTRAIT</li> <li>3 - INVERTED LANDSCAPE</li> <li>4 - PORTRAIT MIRRORED</li> <li>5 - LANDSCAPE MIRRORED</li> <li>6 - INVERTED PORTRAIT MIRRORED</li> <li>7 - INVERTED LANDSCAPE MIRRORED</li> </ul> <p>In our labs we have the connector at the bottom so we use the Portrait rotation of 0 which is the default rotation.</p>"},{"location":"kits/gc9a01/#references","title":"References","text":"<ol> <li>Russ Hughes - Russ provides firmware images that you can use for both the Pico and Pico W.<ol> <li>Raspberry Pi Pico</li> <li>Raspberry Pi Pico W</li> </ol> </li> </ol>"},{"location":"kits/gc9a01/01-hello-world/","title":"Hello World Test","text":"<p>We begin by carefully setting up the 7 wires that connect from the gc9a01 graphics controller to the breadboard that we have our Raspberry Pi Pico W connected.</p> <pre><code># 01-hello-world-firmware.py\n# \nfrom machine import Pin, SPI\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\ntft.init()\ntft.fill(0) # fill the screen with black\ntft.text(font, \"Hello world!\", 20, 100, gc9a01.color565(255,0,0), gc9a01.color565(0,0,255))\n</code></pre>"},{"location":"kits/gc9a01/02-display-time/","title":"Display Time and Date","text":"<p>Here is a program that will display the time and date including the day-of-the-week and the name of the month.</p> <p>We use the ``localtime()``` function to get the current time in an array of integers that looks like this:</p> <pre><code>(2023, 9, 30, 13, 18, 9, 5, 273)\n</code></pre> <p>The fields are:</p> <ol> <li>Year</li> <li>Month</li> <li>Day of Month</li> <li>Hour in 24-hour format</li> <li>Minutes</li> <li>Seconds</li> <li>Day of Week (Monday = 0, Sunday = 6)</li> <li>Day of the Year</li> </ol> <p>We could convert each of these numbers to strings and display them. However, most people like to do a bit of formatting such as displaing a 12-hour am/pm format and returning the name of the month and day of the week.  Here is the complete progam with the formatting.</p> <pre><code># 02-display-time.py\n# \nfrom machine import Pin, SPI\nfrom utime import sleep, localtime\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\ntft.init()\ntft.fill(0) # fill the screen with black\n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\n# I limit the month names to 5 characters max\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef day_of_week(now):\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    return day_name\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {}, {}\".format(month_name, now[2], now[0])\n\ntft.fill(0) # erase the screen to black\nwhite = gc9a01.color565(255, 255, 255)\nwhile(True):\n    # get the time from the local real-time clock\n    now = localtime()\n    print(now)    \n    tft.text(font, format_time(now), 35, 50, white)\n    tft.text(font, day_of_week(now), 50, 80, white)\n    tft.text(font, format_date(now), 5, 110, white)\n    #tft.show()\n    sleep(1)\n</code></pre>"},{"location":"kits/gc9a01/03-display-hand/","title":"Display Second Hand","text":"<p>In this lesson we will use a bit of trigonometry to display a second hand that ticks every second.</p> <pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nHAND_LENGTH = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nwhite = gc9a01.color565(255, 255, 255)\n\nwhile True:\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    print(radians, x, y)\n    tft.fill(0)\n    tft.line(CENTER, CENTER, CENTER+x,CENTER+y, white)\n    sleep(1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre>"},{"location":"kits/gc9a01/04-cycle-fonts/","title":"Cycle Through the Builtin Fonts","text":"<p>This program will cycle through the built-in fonts showing greetings in different fonts, langauges and colors.</p> <pre><code># Adapted from the hersey.py program\nfrom machine import Pin, SPI\nfrom utime import sleep, localtime\nimport random\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0)\n\n# Load several frozen fonts from flash\n\nimport greeks\nimport italicc\nimport italiccs\nimport meteo\nimport romanc\nimport romancs\nimport romand\nimport romanp\nimport romans\nimport scriptc\nimport scripts\n\n\ndef cycle(p):\n'''\n    return the next item in a list\n    '''\n    try:\n        len(p)\n    except TypeError:\n        cache = []\n        for i in p:\n            yield i\n            cache.append(i)\n        p = cache\n    while p:\n        yield from p\n\n\nCOLORS = cycle([0xe000, 0xece0, 0xe7e0, 0x5e0, 0x00d3, 0x7030])\n\nFONTS = cycle([\n    greeks, italicc, italiccs, meteo, romanc, romancs,\n    romand, romanp, romans, scriptc, scripts])\n\nGREETINGS = cycle([\n    \"bonjour\", \"buenas noches\", \"buenos dias\",\n    \"good day\", \"good morning\", \"hey\",\n    \"hi-ya\", \"hi\", \"how are you\", \"how goes it\",\n    \"howdy-do\", \"howdy\", \"shalom\", \"welcome\",\n    \"what's happening\", \"what's up\"])\n\ntft.init()\nrow = 120\n\nwhile True:\n    color = next(COLORS)\n    tft.fill(gc9a01.BLACK)\n    tft.draw(next(FONTS), next(GREETINGS), 0, row, color)\n    sleep(0.5)\n</code></pre>"},{"location":"kits/gc9a01/04-cycle-fonts/#references","title":"References","text":"<ol> <li>Russ Hughes Example</li> </ol>"},{"location":"kits/gc9a01/05-draw-ticks/","title":"Draw Clock Face Ticks","text":"<p>This program draws 12 short white radial lines around a watch face.</p> <p></p> <p>We use the same math we used to draw a single hand.  However, in this example we just need to iterate through a range of 0 to 12.</p> <pre><code>for i in range(0,12):\n    radians = (i/12)*TWO_PI\n    x1 = int(math.sin(radians)*TICK_START)\n    y1 = -int(math.cos(radians)*TICK_START)\n    x2 = int(math.sin(radians)*TICK_END)\n    y2 = -int(math.cos(radians)*TICK_END)\n    tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, WHITE)\n</code></pre> <p>Instead of just drawing from the center to a point at (x,y), we need to calculate four numbers.  These are the start and ending points of each tick.</p>"},{"location":"kits/gc9a01/05-draw-ticks/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nTICK_START = 80\nTICK_END = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nWHITE = gc9a01.color565(255, 255, 255)\nBLACK = gc9a01.color565(0, 0, 0)\ntft.fill(BLACK)\nfor i in range(0,12):\n    radians = (i/12)*TWO_PI\n    x1 = int(math.sin(radians)*TICK_START)\n    y1 = -int(math.cos(radians)*TICK_START)\n    x2 = int(math.sin(radians)*TICK_END)\n    y2 = -int(math.cos(radians)*TICK_END)\n    print(i, radians, x1, y1, x2, y2)  \n    tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, WHITE)\n</code></pre>"},{"location":"kits/gc9a01/07-draw-12-digits/","title":"Draw Clock Dial Digits","text":"<p>This program builds on the previous progam that draws the ticks. It also draws a ditit at the end of each tick.</p> <p></p> <p>We use the same math we used to draw a single hand.  However, in this example we just need to iterate through a range of 0 to 12.</p> <p>We have to remember to load our 16x32 fonts.  Although this is a bit large for most watch faces, they are easy to read.</p> <p>Here is the line we added: <pre><code>import vga1_bold_16x32 as font\n</code></pre></p> <p>Note that there are other sizes we can use.  A list of the other fonts is here:</p> <p>GitHub Site for Russ Hughes for GC9a01 bitmap fonts</p> <p>These fonts include the following sizes:</p> <ol> <li>8x8</li> <li>8x16</li> <li>16x16</li> <li>16x32</li> </ol> <p>Here is the appropriate line for the normal 16x16:</p> <pre><code>import vga1_16x16 as font\n</code></pre> <p><pre><code>if i == 0:\n    num_str = \"12\"\nelse:\n    num_str = str(i)\ntft.text(font, num_str, CENTER+x3-8, CENTER+y3-16, WHITE)\n</code></pre> Note because the fonts are 16 wide and 32 high we move 8 to the left and 16 up.</p>"},{"location":"kits/gc9a01/07-draw-12-digits/#full-program","title":"Full Program","text":"<pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nTICK_START = 50\nTICK_END = 80\nNUM_POS = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nWHITE = gc9a01.color565(255, 255, 255)\nBLACK = gc9a01.color565(0, 0, 0)\nBLUE = gc9a01.color565(0, 0, 255)\ntft.fill(BLACK)\nfor i in range(0,12):\n    radians = (i/12)*TWO_PI\n    x1 = int(math.sin(radians)*TICK_START)\n    y1 = -int(math.cos(radians)*TICK_START)\n    x2 = int(math.sin(radians)*TICK_END)\n    y2 = -int(math.cos(radians)*TICK_END)\n    x3 = int(math.sin(radians)*NUM_POS)\n    y3 = -int(math.cos(radians)*NUM_POS)\n    print(i, radians, x1, y1, x2, y2)  \n    tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, BLUE)\n    if i == 0:\n        num_str = \"12\"\n    else:\n        num_str = str(i)\n    tft.text(font, num_str, CENTER+x3-8, CENTER+y3-16, WHITE)\n</code></pre> <p>If you use the 16x16 font the offset in the last line are:</p> <pre><code>    if i == 0:\n        num_str = \"12\"\n        xOffest = 16\n    else:\n        num_str = str(i)\n        xOffest = 8\n    tft.text(font, num_str, CENTER+x3-xOffest, CENTER+y3-8, WHITE)\n</code></pre> <p>The exception is for the \"12\" at the top of the dial.  The \"12\" needed to be exactly centered above the top tick mark.</p> <p></p>"},{"location":"kits/gc9a01/07-draw-12-digits/#full-code-for-16x16-clock-face-digits","title":"Full Code for 16x16 Clock Face Digits","text":"<pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\nimport vga1_16x16 as font\n\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nTICK_START = 70\nTICK_END = 100\nNUM_POS = 111\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nWHITE = gc9a01.color565(255, 255, 255)\nBLACK = gc9a01.color565(0, 0, 0)\nBLUE = gc9a01.color565(0, 0, 255)\ntft.fill(BLACK)\nfor i in range(0,12):\n    radians = (i/12)*TWO_PI\n    x1 = int(math.sin(radians)*TICK_START)\n    y1 = -int(math.cos(radians)*TICK_START)\n    x2 = int(math.sin(radians)*TICK_END)\n    y2 = -int(math.cos(radians)*TICK_END)\n    x3 = int(math.sin(radians)*NUM_POS)\n    y3 = -int(math.cos(radians)*NUM_POS)\n    print(i, radians, x1, y1, x2, y2)  \n    tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, BLUE)\n    if i == 0:\n        num_str = \"12\"\n        xOffest = 16\n    else:\n        num_str = str(i)\n        xOffest = 8\n    tft.text(font, num_str, CENTER+x3-xOffest, CENTER+y3-8, WHITE)\n</code></pre>"},{"location":"kits/gc9a01/08-draw-filled-triangle/","title":"Draw a Filled Triangle","text":"<p>Analog clock hands can be draw with simple lines.  But the display will be more pleasing if we use clock hands that are made of triangles.</p> <p>If the framebuf functions were supported in the driver drawing a filled triangle would be easy.  We would just put the three points in an array and call the <code>poly()</code> with a fill option.</p> <p>However, the current driver does not support the framebuf functions.  To overcome this limiation we will need to write our own function that will fill all the points in a triangle.</p> <p>Our founction must take in the three points and a color and draw the traingle.</p>"},{"location":"kits/gc9a01/08-draw-filled-triangle/#draw-filled-triangle","title":"Draw Filled Triangle","text":"<p>Without going into too much detail, here is the algorithm we will use dto draw a filled triangle. Note that only the last line does drawing using the <code>line()</code> function. You will note that it must get the points in order before the main loops run. This version also checks for divide by zero errors.</p> <pre><code>def drawFilledTriangle(x1, y1, x2, y2, x3, y3, color=WHITE):\n    def swap(x, y):\n        return y, x\n\n    # get our points in order\n    if y1 &gt; y2:\n        x1, x2 = swap(x1, x2)\n        y1, y2 = swap(y1, y2)\n    if y1 &gt; y3:\n        x1, x3 = swap(x1, x3)\n        y1, y3 = swap(y1, y3)\n    if y2 &gt; y3:\n        x2, x3 = swap(x2, x3)\n        y2, y3 = swap(y2, y3)\n\n    for y in range(y1, y3+1):\n        if y2 - y1 != 0 and y &lt; y2:\n            xa = x1 + (x2 - x1) * (y - y1) // (y2 - y1)\n        elif y3 - y1 != 0:\n            xa = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if y3 - y2 != 0 and y &gt;= y2:\n            xb = x2 + (x3 - x2) * (y - y2) // (y3 - y2)\n        elif y3 - y1 != 0:\n            xb = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if xa &gt; xb:\n            xa, xb = swap(xa, xb)\n\n        for x in range(xa, xb+1):\n            # sleep(.1)\n            tft.line(x, y, x, y, color)\n</code></pre>"},{"location":"kits/gc9a01/08-draw-filled-triangle/#full-test-program","title":"Full Test Program","text":"<p>To test our alforithm we can genrate three random points near the center of the display and then call the traingle fill on these points.  If you would like to see how the algorithm does the drawing, you can uncomment the sleep function just before the <code>tft.line()</code> above.</p> <pre><code># 01-display-test.py\n# \nfrom machine import Pin, SPI\nimport random\nimport gc9a01\nimport vga1_16x16 as font\nfrom utime import sleep\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\nWHITE = gc9a01.color565(255,255,255)\nBLUE = gc9a01.color565(0,0,255)\nBLACK = gc9a01.color565(0,0,0)\n\ntft.init()\ntft.fill(0) # fill the screen with black\ntft.text(font, \"Draw Filled Triangle Test\", 20, 10, BLUE, BLACK)\n\n\n\ndef drawFilledTriangle(x1, y1, x2, y2, x3, y3, color=WHITE):\n    def swap(x, y):\n        return y, x\n\n    if y1 &gt; y2:\n        x1, x2 = swap(x1, x2)\n        y1, y2 = swap(y1, y2)\n    if y1 &gt; y3:\n        x1, x3 = swap(x1, x3)\n        y1, y3 = swap(y1, y3)\n    if y2 &gt; y3:\n        x2, x3 = swap(x2, x3)\n        y2, y3 = swap(y2, y3)\n\n    for y in range(y1, y3+1):\n        if y2 - y1 != 0 and y &lt; y2:\n            xa = x1 + (x2 - x1) * (y - y1) // (y2 - y1)\n        elif y3 - y1 != 0:\n            xa = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if y3 - y2 != 0 and y &gt;= y2:\n            xb = x2 + (x3 - x2) * (y - y2) // (y3 - y2)\n        elif y3 - y1 != 0:\n            xb = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if xa &gt; xb:\n            xa, xb = swap(xa, xb)\n\n        for x in range(xa, xb+1):\n            tft.line(x, y, x, y, color)\n\n\nmin = 50\nmax = 150\nwhile True:\n    tft.fill(BLACK)\n    x1 = random.randint(min, max)\n    y1 = random.randint(min, max)\n    x2 = random.randint(min, max)\n    y2 = random.randint(min, max)\n    x3 = random.randint(min, max)\n    y3 = random.randint(min, max)\n    drawFilledTriangle(x1, y1, x2, y2, x3, y3, WHITE)\n    sleep(.1)\n</code></pre>"},{"location":"kits/gc9a01/08-draw-filled-triangle/#crazy-triangles","title":"Crazy Triangles","text":"<pre><code># lab 15: Filled Triangles\n# \nfrom machine import Pin, SPI\nimport random\nimport gc9a01\nimport vga1_16x16 as font\nfrom utime import sleep\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\nWHITE = gc9a01.color565(255,255,255)\nBLUE = gc9a01.color565(0,0,255)\nBLACK = gc9a01.color565(0,0,0)\n\ntft.init()\ntft.fill(0) # fill the screen with black\ntft.text(font, \"Triangles\", 57, 22, BLUE, BLACK)\n\ndef drawFilledTriangle(x1, y1, x2, y2, x3, y3, color=WHITE):\n    def swap(x, y):\n        return y, x\n\n    if y1 &gt; y2:\n        x1, x2 = swap(x1, x2)\n        y1, y2 = swap(y1, y2)\n    if y1 &gt; y3:\n        x1, x3 = swap(x1, x3)\n        y1, y3 = swap(y1, y3)\n    if y2 &gt; y3:\n        x2, x3 = swap(x2, x3)\n        y2, y3 = swap(y2, y3)\n\n    for y in range(y1, y3+1):\n        if y2 - y1 != 0 and y &lt; y2:\n            xa = x1 + (x2 - x1) * (y - y1) // (y2 - y1)\n        elif y3 - y1 != 0:\n            xa = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if y3 - y2 != 0 and y &gt;= y2:\n            xb = x2 + (x3 - x2) * (y - y2) // (y3 - y2)\n        elif y3 - y1 != 0:\n            xb = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n\n        if xa &gt; xb:\n            xa, xb = swap(xa, xb)\n\n        for x in range(xa, xb+1):\n            # for wathing the drawing\n            # sleep(.001)\n            tft.line(x, y, x, y, color)\n\nmin = 40\nmax = 220\nwhile True:\n    # tft.fill(BLACK)\n    x1 = random.randint(min, max)\n    y1 = random.randint(min, max)\n    x2 = random.randint(min, max)\n    y2 = random.randint(min, max)\n    x3 = random.randint(min, max)\n    y3 = random.randint(min, max)\n    red = random.randint(0, 255)\n    green = random.randint(0, 255)\n    blue = random.randint(0, 255)\n    color = gc9a01.color565(red,green,blue)\n    drawFilledTriangle(x1, y1, x2, y2, x3, y3, color)\n    # slow down the drawing here\n    sleep(.1)\n</code></pre>"},{"location":"kits/gc9a01/09-watch-face/","title":"Watch Face","text":"<ol> <li>Ticks</li> <li>Second hand</li> <li>Minute hand</li> <li>Hour hand</li> </ol> <pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n# A full circle is 2*Pi radians\nTWO_PI = 3.1415926*2\nWHITE = gc9a01.color565(255, 255, 255)\nBLUE = gc9a01.color565(0, 0, 255)\nGREEN = gc9a01.color565(0, 255, 0)\nPURPLE = gc9a01.color565(255, 0, 255)\nBLACK = gc9a01.color565(0, 0, 0)\ntft.fill(BLACK)\nCENTER = 120\nMIN_TICK_START = 80\nMIN_TICK_END = 98\nSEC_TICK_START = 100\nSEC_TICK_END = 120\n\ndef drawFilledTriangle(x1, y1, x2, y2, x3, y3, color=WHITE):\n    def swap(x, y):\n        return y, x\n    if y1 &gt; y2:\n        x1, x2 = swap(x1, x2)\n        y1, y2 = swap(y1, y2)\n    if y1 &gt; y3:\n        x1, x3 = swap(x1, x3)\n        y1, y3 = swap(y1, y3)\n    if y2 &gt; y3:\n        x2, x3 = swap(x2, x3)\n        y2, y3 = swap(y2, y3)\n    for y in range(y1, y3+1):\n        if y2 - y1 != 0 and y &lt; y2:\n            xa = x1 + (x2 - x1) * (y - y1) // (y2 - y1)\n        elif y3 - y1 != 0:\n            xa = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n        if y3 - y2 != 0 and y &gt;= y2:\n            xb = x2 + (x3 - x2) * (y - y2) // (y3 - y2)\n        elif y3 - y1 != 0:\n            xb = x1 + (x3 - x1) * (y - y1) // (y3 - y1)\n        else:\n            continue\n        if xa &gt; xb:\n            xa, xb = swap(xa, xb)\n        for x in range(xa, xb+1):\n            tft.line(x, y, x, y, color)\n\ndef drawTicks():\n    for i in range(0,60):\n        radians = (i/60)*TWO_PI\n        x1 = int(math.sin(radians)*SEC_TICK_START)\n        y1 = -int(math.cos(radians)*SEC_TICK_START)\n        x2 = int(math.sin(radians)*SEC_TICK_END)\n        y2 = -int(math.cos(radians)*SEC_TICK_END)\n        # print(i, radians, x1, y1, x2, y2)  \n        tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, BLUE)\n\n    for i in range(0,12):\n        radians = (i/12)*TWO_PI\n        x1 = int(math.sin(radians)*MIN_TICK_START)\n        y1 = -int(math.cos(radians)*MIN_TICK_START)\n        x2 = int(math.sin(radians)*MIN_TICK_END)\n        y2 = -int(math.cos(radians)*MIN_TICK_END)\n        # print(i, radians, x1, y1, x2, y2)  \n        tft.line(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, GREEN)\n\nCENTER = 120\nSEC_HAND_LENGTH = 118\ndef drawSecondHand(sec):\n    # print('sec=', sec)\n    if sec ==0:\n        radians = 0\n    else: radians = (sec/60)*TWO_PI\n    x = int(math.sin(radians)*SEC_HAND_LENGTH)\n    y = -int(math.cos(radians)*SEC_HAND_LENGTH)\n    # print(radians, x, y)\n    tft.line(CENTER, CENTER, CENTER+x,CENTER+y, WHITE)\n    sleep(.1)\n    tft.line(CENTER, CENTER, CENTER+x,CENTER+y, BLACK)\n\n\nMIN_HAND_LENGTH = 90\nMIN_HAND_WIDTH = 5\ndef drawMinuteHand(min, color):\n    radians = (min/60)*TWO_PI\n    x1 = -int(math.cos(radians)*MIN_HAND_WIDTH)\n    y1 = -int(math.sin(radians)*MIN_HAND_WIDTH)\n    x2 = int(math.sin(radians)*MIN_HAND_LENGTH)\n    y2 = -int(math.cos(radians)*MIN_HAND_LENGTH)\n    x3 = int(math.cos(radians)*MIN_HAND_WIDTH)\n    y3 = int(math.sin(radians)*MIN_HAND_WIDTH)\n    # print('min:', x1, y1, x2, y2, x3, y3)\n    drawFilledTriangle(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, CENTER+x3, CENTER+y3, color)\n\nHOUR_HAND_LENGTH = 60\nHOUR_HAND_WIDTH = 6\ndef drawHourHand(hour, color):\n    radians = (hour/12)*TWO_PI\n    x1 = -int(math.cos(radians)*HOUR_HAND_WIDTH)\n    y1 = -int(math.sin(radians)*HOUR_HAND_WIDTH)\n    x2 = int(math.sin(radians)*HOUR_HAND_LENGTH)\n    y2 = -int(math.cos(radians)*HOUR_HAND_LENGTH)\n    x3 = int(math.cos(radians)*HOUR_HAND_WIDTH)\n    y3 = int(math.sin(radians)*HOUR_HAND_WIDTH)\n    # print('hour:', x1, y1, x2, y2, x3, y3)\n    drawFilledTriangle(CENTER+x1, CENTER+y1, CENTER+x2, CENTER+y2, CENTER+x3, CENTER+y3, color)\n\ncounter = 0\nmin = 58\nhour = 6\ndrawMinuteHand(min, GREEN)\ndrawHourHand(hour, PURPLE)\nhour = 6\nwhile True:\n    # this is the flicker\n    # tft.fill(BLACK)\n    drawTicks()\n\n    drawSecondHand(counter)\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        drawMinuteHand(min, BLACK)\n        counter = 0\n        min += 1\n        drawMinuteHand(min, GREEN)\n        if min &gt; 59:\n            min=0\n            drawHourHand(hour, BLACK)\n            hour += 1\n            drawHourHand(hour, PURPLE)\n            if hour &gt; 11:\n                hour = 0\n    counter += 1\n    # sleep(.5)\n</code></pre>"},{"location":"kits/ili9341/","title":"ILI9341 Display","text":""},{"location":"kits/ili9341/#driver","title":"Driver","text":"<p>dagger GitHub Repo</p>"},{"location":"kits/ili9341/#characteristics","title":"Characteristics","text":"<p>Direct write No support for standard micropython framebuf</p>"},{"location":"kits/ili9341/#souce-code","title":"Souce Code","text":""},{"location":"kits/ili9341/01-rainbow-test/","title":"Rainbow Test","text":"<pre><code>from ili9341 import Display, color565\nfrom machine import Pin, SPI\n\n# Use these PIN definitions.  SCK must be on 2 and data (SDL) on 3 for SPI bus 0\nSCK_PIN = 2\nMISO_PIN = 3 # labeled SDI(MOSI) on the back of the display\nDC_PIN = 4\nRESET_PIN = 5\nCS_PIN = 6\nROTATION = 90\n\nWIDTH=320\nHEIGHT=240\n\nspi = SPI(0, baudrate=40000000, sck=Pin(SCK_PIN), mosi=Pin(MISO_PIN))\ndisplay = Display(spi, dc=Pin(DC_PIN), cs=Pin(CS_PIN), rst=Pin(RESET_PIN), width=WIDTH, height=HEIGHT, rotation=ROTATION)\n\nRED = color565(255,0,0)\nORANGE = color565(255,128,0)\nYELLOW = color565(255,255,0)\nGREEN = color565(0,255,0)\nBLUE = color565(0,0,255)\nPURPLE = color565(255,0,255)\nWHITE = color565(255,255,255)\nBLACK = color565(0,0,0)\n\ndisplay.fill_rectangle(0,0, 50,HEIGHT, RED)\ndisplay.fill_rectangle(50,0, 50,HEIGHT, ORANGE)\ndisplay.fill_rectangle(100,0, 50,HEIGHT, YELLOW)\ndisplay.fill_rectangle(150,0, 50,HEIGHT, GREEN)\ndisplay.fill_rectangle(200,0, 50,HEIGHT, BLUE)\ndisplay.fill_rectangle(250,0, 50,HEIGHT, PURPLE)\ndisplay.fill_rectangle(300,0, 20,HEIGHT, WHITE)\n\nprint('Done')\n</code></pre>"},{"location":"kits/ili9341/01-rainbow-test/#color-definitions","title":"Color Definitions","text":"<p>We can also use this same process for storing all of the common constants that we duplicate in our examples.  For example all the named color defintions can be moved into a serate color-defs.py file like this:</p> <p>Sample colors.py <pre><code>from ili9341 import color565\n\nWHITE = color565(255,255,255)\nBLACK = color565(0,0,0)\nRED = color565(255,0,0)\nORANGE = color565(255,128,0)\nYELLOW = color565(255,255,0)\nGREEN = color565(0,255,0)\nBLUE = color565(0,0,255)\nCYAN = color565(0,255,255)\nPURPLE = color565(255,0,255)\n</code></pre></p> <p>This sample program imports both the config and the colors file:</p> <pre><code>from ili9341 import Display, color565\nfrom machine import Pin, SPI\nimport config\nimport colors\n\n# Use these PIN definitions.  SCK must be on 2 and data (SDL) on 3\nSCK_PIN = config.SCK_PIN\nMISO_PIN = config.MISO_PIN # labeled SDI(MOSI) on the back of the display\nDC_PIN = config.DC_PIN\nRESET_PIN = config.RESET_PIN\nCS_PIN = config.CS_PIN\n\nWIDTH=config.WIDTH\nHEIGHT=config.HEIGHT\nROTATION=config.ROTATION\n\n# mosi=Pin(23)\n# miso=Pin(MISO_PIN)\nspi = SPI(0, baudrate=40000000, sck=Pin(SCK_PIN), mosi=Pin(MISO_PIN))\ndisplay = Display(spi, dc=Pin(DC_PIN), cs=Pin(CS_PIN), rst=Pin(RESET_PIN), width=WIDTH, height=HEIGHT, rotation=ROTATION)\n\ndisplay.fill_rectangle(0,0, 50,HEIGHT, colors.RED)\ndisplay.fill_rectangle(50,0, 50,HEIGHT, colors.ORANGE)\ndisplay.fill_rectangle(100,0, 50,HEIGHT, colors.YELLOW)\ndisplay.fill_rectangle(150,0, 50,HEIGHT, colors.GREEN)\ndisplay.fill_rectangle(200,0, 50,HEIGHT, colors.BLUE)\ndisplay.fill_rectangle(250,0, 50,HEIGHT, colors.PURPLE)\ndisplay.fill_rectangle(300,0, 20,HEIGHT, colors.WHITE)\n\nprint('Done')\n</code></pre> <p>Note that the string <code>colors.</code> must appear before each color name.  You can shorten this to be just <code>c.</code> if you want to keep your code smaller and easier to read.</p>"},{"location":"kits/ili9341/01-rainbow-test/#hiding-hardware-initialization","title":"Hiding Hardware Initialization","text":"<p>We could take this one step further and put the lines that setup the SPI and the Display into a separate function.  However, in our labs we want to keep some of this code explicit so we will leave the SPI and Display initialization in our examples.</p>"},{"location":"kits/ili9341/02-config/","title":"Creating a Hardware Configuration File","text":"<p>Rather than hard coding the pin numbers in every example, lets put all our hardware configuration data in a single file.  All the examples from here on can use that configuration data.</p>"},{"location":"kits/ili9341/02-config/#hardware-configuration-file","title":"Hardware Configuration File","text":"<pre><code># Dan's Robot Labs configuration file for ILI9341 clock project\n# The colors on the SPI bus cable are:\n# 3.3v power - red\n# SCK - orange\n# MISO/Data - yellow\n# DC - green\n# RESET - blue\n# GND - black\n# CS - purple\nSCK_PIN = 2\nMISO_PIN = 3 # labeled SDI(MOSI) on the back of the display\nDC_PIN = 4\nRESET_PIN = 5\nCS_PIN = 6\nROTATION = 90\n\nWIDTH=320\nHEIGHT=240\n</code></pre>"},{"location":"kits/ili9341/02-config/#sample-use-of-hardwre-configuration-file","title":"Sample Use of Hardwre Configuration File","text":"<pre><code># print out \"Hello World!\" using the rotation=3 using 32-bit high font\n# the default is white text on a black background\nfrom ili9341 import Display, color565\nfrom machine import Pin, SPI\nimport config\n\n# Use these PIN definitions.  SCK must be on 2 and data (SDL) on 3\nSCK_PIN = config.SCK_PIN\nMISO_PIN = config.MISO_PIN # labeled SDI(MOSI) on the back of the display\nDC_PIN = config.DC_PIN\nRESET_PIN = config.RESET_PIN\nCS_PIN = config.CS_PIN\n\nWIDTH=config.WIDTH\nHEIGHT=config.HEIGHT\nROTATION=config.ROTATION\n\n# mosi=Pin(23)\n# miso=Pin(MISO_PIN)\nspi = SPI(0, baudrate=40000000, sck=Pin(SCK_PIN), mosi=Pin(MISO_PIN))\ndisplay = Display(spi, dc=Pin(DC_PIN), cs=Pin(CS_PIN), rst=Pin(RESET_PIN), width=WIDTH, height=HEIGHT, rotation=ROTATION)\n\nRED = color565(255,0,0)\nORANGE = color565(255,128,0)\nYELLOW = color565(255,255,0)\nGREEN = color565(0,255,0)\nBLUE = color565(0,0,255)\nPURPLE = color565(255,0,255)\nWHITE = color565(255,255,255)\nBLACK = color565(0,0,0)\n\ndisplay.fill_rectangle(0,0, 50,HEIGHT, RED)\ndisplay.fill_rectangle(50,0, 50,HEIGHT, ORANGE)\ndisplay.fill_rectangle(100,0, 50,HEIGHT, YELLOW)\ndisplay.fill_rectangle(150,0, 50,HEIGHT, GREEN)\ndisplay.fill_rectangle(200,0, 50,HEIGHT, BLUE)\ndisplay.fill_rectangle(250,0, 50,HEIGHT, PURPLE)\ndisplay.fill_rectangle(300,0, 20,HEIGHT, WHITE)\n\nprint('Done')\n</code></pre>"},{"location":"kits/led-strips/","title":"LED Strip Clocks","text":"<p>In this section we will present two clocks that use and LED strip.</p> <ol> <li>The first kit displays binary numbers.  Hard to read but very geeky.</li> <li>The second requires building four seven-segment displays from the LED strip (or LED string)</li> </ol>"},{"location":"kits/led-strips/01-binary-clock/","title":"Binary Clock","text":"<p>This kit just needs a Pico and a short segment of an LED strip - about 14 pixels.</p> <p>We can create a very simple binary clock using a single LED strip.</p> <p>The strip will have three color bands:</p> <ol> <li>One binary number will be the hour (0 to 12) (4 red pixels)</li> <li>One binary number will be the minutes (0 to 59) (6 green pixels)</li> <li>One binary number will be the seconds (0 to 59) (6 blue pixels)</li> </ol> <p>We can also put spaces between the bands</p> <p>We can optionally also have the seconds displayed by:</p> <ol> <li>A single LED that blinks on and off</li> <li>Two decimal digits</li> <li>A single binary from (0 to 60)</li> </ol>"},{"location":"kits/led-strips/01-binary-clock/#sample-code","title":"Sample Code","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom utime import sleep, localtime\n# get the configuration information\nimport config\n\nnp = config.NUMBER_PIXELS\nstrip = NeoPixel(Pin(config.NEOPIXEL_PIN), np)\n\nsec_bits = [0,0,0,0,0,0]\nmin_bits = [0,0,0,0,0,0]\nhr_bits = [0,0,0,0,0,0]\n\ndef decimal_to_binary(n, a):\n    global sec_bits\n    for i in range(0,6):\n        if n % 2:\n            a[i] = 1\n        else:\n            a[i] = 0\n        ## n halfed\n        n //= 2\n\ndef display_binary(binary, index, color):\n    for i in range(0, 6):\n        # print(i, ' ', end='')\n        if binary[i] == 1:\n            strip[index+i] = color\n        else:\n            strip[index+i] = (0,0,0)\n    strip.write()\n\n# light mark and write\ndef display_mark(loc):\n    strip[loc] = (5,5,5)\n    strip.write()\n\n# update from the first time\n# sec\ndisplay_mark(0)\ndisplay_mark(7)\n\n# min\ndisplay_mark(9)\ndisplay_mark(16)\n\n# min\ndisplay_mark(19)\ndisplay_mark(26)\n\nnow = localtime()\nhour = now[3]\n# use AM/PM 12 hour time\nif hour &gt; 12:\n    hour = hour - 12\nminute = now[4]\n\n# this is not working\ndecimal_to_binary(minute, min_bits)\nprint('initial min:', minute, min_bits)\ndisplay_binary(min_bits, 10, (0,10,0))\n\ndecimal_to_binary(hour, hr_bits)\nprint('initial hour:', hour, hr_bits)\ndisplay_binary(hr_bits, 20, (0,0,10))\n\nwhile True:\n    now = localtime()\n    hour = now[3]\n    # use AM/PM 12 hour time\n    if hour &gt; 12:\n        hour = hour - 12\n    minute = now[4]\n    sec = now[5]\n    print(hour, ':', minute, ' ', sec, sep='')\n    strip.write()\n    decimal_to_binary(sec, sec_bits)\n    print('sec:', sec, sec_bits)\n    display_binary(sec_bits, 1, (10,0,0))\n    if sec == 60:\n        minute = minute + 1\n        sec = 0\n        decimal_to_binary(minute, min_bits)\n        print('min:', minute, min_bits)\n        display_binary(min_bits, 10, (0,10,0))\n        if minute == 60:\n            decimal_to_binary(hour, hr_bits)\n            print('hour:', hour, hr_bits)\n            display_binary(hr_bits, 20, (0,0,10))\n            hour = hour + 1\n            minute = 0\n            if hour == 24:\n                hour = 0\n    sleep(1)\n</code></pre>"},{"location":"kits/led-strips/01-binary-clock/#references","title":"References","text":"<ul> <li>Moving Rainbow Clock</li> </ul>"},{"location":"kits/led-strips/02-seven-segment-clock/","title":"Seven Segment Clock","text":"<p>We can create a large, bright clock visible in a large classroom by lighting up selective pixels of an LED strip and arranging the pixels in the shape of seven segment displays.  We can use three pixels per segment.</p> <p></p> <ul> <li>We can use three pixels per segment.</li> <li>21 pixels per digit</li> <li>63 pixels + 6 for the \"1\" + two for the colon = 70 pixels</li> </ul> <p></p> <p>eBay 50 for $12</p> <p>Drawing Digits</p> <p>Lessons</p> <p>We can create an array of the segments like this:</p> <pre><code>segmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n</code></pre>"},{"location":"kits/led-strips/02-seven-segment-clock/#digit-pixel-map","title":"Digit Pixel Map","text":"<p>TBD</p> <ul> <li>a: n, n+1, n+2</li> <li>b: n+3, n+4, n+5</li> </ul> <p><pre><code>def set_pixels(digit, value, color):\n    # look up start pixel for digit\n    # for value turn on pixels\n    n = startVals[digit]\n\n    segmentOn = segmentMapping[value];\n    for i in range(0, 9):\n        if (segmentOn[i]):\n            o = i*3 // offset\n            strip(n+o) = color\n            strip(n+o+1) = color\n            strip(n+o+2) = color\n</code></pre> ```</p> <p>7-Segment Display Demo with P5.js</p> <p>Moving Rainbow Arduino Sign</p>"},{"location":"kits/lilygo/","title":"LILYGO T-Display RP2040","text":"<p>LILYGO makes low-cost and high-quality microcontroller development boards that include small displays.  Although most of their boards run on C programs on ESP-32 processors, they do have one that runs MicroPython on an RP2040.  This \"kit\" is really just that development board placed on a breadboard.  The device has two buttons on it which can be used to adjust the time.</p> <p>This is a color 1.14 inch LCD display PS with 240*135 resolution. It uses the ST7789V chip that has an extreamly high quality driver created by Russ Hughes that allows for flicker-free drawing.</p> <p>I purchased mine on Ebay for $10.66 and three dollars for shipping.</p> <p>Although the display is too small for most robotic applications where the robot is on the floor and we are standing, it is a good example of how we can get both clocks and watches to look great.  My hope is that LILYGO comes out with a larger display in the future.</p> <p>Lilygo also sells their own \"wearable\" watch kits] for $35 to $45.  However, I have not purchased any of these that can be programmed with an RP2040 and MicroPython yet.  Here is a GitHub Page for the T-Watch that implies it might be on the way.  Note that using this requires extensive knowledge of the ESP32 development system.</p>"},{"location":"kits/lilygo/#getting-started","title":"Getting Started","text":"<p>To use the ST7789V driver we MUST use a custom image provide by Rull Hughes.  This is because the driver is written in low-level C code and the python driver requires it to be combiled into the firmware image.</p> <p>I downloaded the custom image here:</p> <p>T-DISPLAY RP2040 Firmware</p> <p>I then held the Boot button down while I powered up the device.</p> <p>I soldered my own header pins on the LILYGO and placed it on a breadboard.  Unfortunatly this makes it impossible to hold down the boot button with the device on the breadboard.</p>"},{"location":"kits/lilygo/#pinouts","title":"Pinouts","text":"<p>The pinouts are very different from the Raspberry Pi Pico.</p> <p></p>"},{"location":"kits/lilygo/#config-file","title":"Config File","text":"<p>This implementation puts the driver in a hidden C program, but it does have a configuration file that we must upload and place in the /lib directory.</p> <p>Here is a Link to the File for the T-Display RP2040</p> <pre><code>\"\"\"TTGO T-Display RP2040 display\"\"\"\n\nfrom machine import Pin, SPI\nfrom time import sleep\nimport st7789\n\nTFA = 40    # top free area when scrolling\nBFA = 40    # bottom free area when scrolling\n\ndef config(rotation=0, buffer_size=0, options=0):\n\n    Pin(22, Pin.OUT, value=1)\n\n    spi = SPI(0,\n        baudrate=62500000,\n        polarity=1,\n        phase=0,\n        sck=Pin(2, Pin.OUT),\n        mosi=Pin(3, Pin.OUT),\n        miso=None)\n\n    return st7789.ST7789(\n        spi,\n        135,\n        240,\n        cs=Pin(5, Pin.OUT),\n        dc=Pin(1, Pin.OUT),\n        backlight=Pin(4, Pin.OUT),\n        rotation=rotation,\n        options=options,\n        buffer_size=buffer_size)\n</code></pre>"},{"location":"kits/lilygo/#blink-the-onboard-led","title":"Blink The Onboard LED","text":"<p>This red LED is on the bottom of the board.</p> <p>Blink Timer example:</p> <pre><code>from machine import Pin, Timer\nled = Pin(25,Pin.OUT)\ntim = Timer()\ndef tick(timer):\n    global led\n    led.toggle()\ntim.init(freq=2.5, mode=Timer.PERIODIC, callback=tick)\n</code></pre>"},{"location":"kits/lilygo/#display-example","title":"Display Example","text":"<pre><code>\"\"\"\ndisplay-test.py\nFills the screen with red, green and blue\n\"\"\"\n\nfrom utime import sleep\nimport st7789\nimport tft_config\ntft = tft_config.config(1)\ntft.init()\n\nwhile True:\n    tft.fill(st7789.RED)\n    sleep(1)\n    tft.fill(st7789.GREEN)\n    sleep(1)\n    tft.fill(st7789.BLUE)\n    sleep(1)\n</code></pre>"},{"location":"kits/lilygo/#drawing-text","title":"Drawing Text","text":"<p>For this example to work, you will need to load a font library into the /lib directory.</p> <pre><code>import random\nimport utime\nimport st7789\nimport tft_config\nimport vga2_bold_16x32 as font\n\ntft = tft_config.config(1)\ntft.init()\n\n# draw text using a 16X32 font using blue text on a white background\ntft.text(\n        font,\n        'Hello World!',\n        tft.width()//2-100, # x position to start writing\n        tft.height()//2-50, # y position\n        st7789.BLUE, # font in blue\n        st7789.WHITE # background in white\n)\n</code></pre>"},{"location":"kits/lilygo/#referneces","title":"Referneces","text":"<p>Item on Aliexpress Sample GitHub repo: https://github.com/Xinyuan-LilyGO/LILYGO-T-display-RP2040</p> <p>ST7789V Submodule: Russ Hughes GitHub Repo</p> <p>Config: Sample Config File</p>"},{"location":"kits/pico-oled/","title":"Pico OLED Kits","text":"<p>These are our most popular kits.  They use a bright monochrome 128x64 OLED with either the Raspberry Pi Pico or the Rasberry Pi Pico W.</p> <p>The OLEDs are mounted on a piece of plastic with a half-size breaboard.</p> <p></p> <p>Each board has two buttons so you can adjust the time and alarm clock settings.</p>"},{"location":"kits/pico-oled/#individual-exercises","title":"Individual Exercises","text":""},{"location":"kits/pico-oled/#hello-world","title":"Hello World","text":"<p>Go to Hello world lab</p>"},{"location":"kits/pico-oled/01-hello-world/","title":"Hello World","text":"<p>To get started, let's just draw the string \"Hello world!\" on the display.</p> <p>Here is the code:</p> <pre><code>import machine\nimport ssd1306\n\nSCL=machine.Pin(2) # SPI CLock\nSDA=machine.Pin(3) # SPI Data\n\nRES = machine.Pin(4) # Reset\nDC = machine.Pin(5) # Data/command\nCS = machine.Pin(6) # Chip Select\n\nspi=machine.SPI(0, sck=SCL, mosi=SDA)\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\n# erase the entire screen with black\noled.fill(0)\n\n# place a hello message at point (0,0) in white\noled.text(\"Hello world!\", 0, 0, 1)\n\n# send the entire frame buffer to the display via the SPI bus\noled.show()\n</code></pre> <p>Challenges</p> <ol> <li>Can you change the message from \"Hello world!\" to have your name in it?</li> <li>Can you change the location of the text on the screen by changing the location point from (0,0) to another place on the screen?  The screen is 128 pixels wide by 64 pixels high.</li> <li>How far down can you display the message without going off the screen?</li> <li>How many characters wide can a message be before it goes off the right edge of the dipsplay?</li> <li>Can you display multiple messages on different lines?</li> </ol>"},{"location":"kits/pico-oled/02-display-time/","title":"Display Time","text":""},{"location":"kits/pico-oled/02-display-time/#the-localtime-function","title":"The Localtime function","text":"<pre><code>from time import localtime\n\nprint(localtime())\n</code></pre> <pre><code>import machine\nimport ssd1306\nimport config\nfrom time import localtime\n\nSCL=machine.Pin(config.SCL_PIN) # SPI CLock\nSDA=machine.Pin(config.SDA_PIN) # SPI Data\n\nRES = machine.Pin(config.RESET_PIN) # Reset\nDC = machine.Pin(config.DC_PIN) # Data/command\nCS = machine.Pin(config.CS_PIN) # Chip Select\n\nspi=machine.SPI(config.SPI_BUS, sck=SCL, mosi=SDA, baudrate=100000)\noled = ssd1306.SSD1306_SPI(config.WIDTH, config.HEIGHT, spi, DC, RES, CS)\n\nyear = localtime()[0]\nmonth = localtime()[1]\nday = localtime()[2]\nhour = localtime()[3]\nminute = localtime()[4]\n\n# display the time in hour and minute on the first line\noled.text(str(hour) + \":\" + str(minute), 0, 0, 1)\n\n# display the date on the second line\noled.text(str(month) + \"/\" + str(day) + \"/\" + str(year), 0, 10, 1)\noled.show()\n</code></pre>"},{"location":"kits/pico-oled/02-hello-config/","title":"Hello Configuraiton","text":""},{"location":"kits/pico-oled/03-display-localtime/","title":"Display Localtime","text":"<pre><code>import machine\nimport ssd1306\nimport config\nfrom time import localtime\n\nSCL=machine.Pin(config.SCL_PIN) # SPI CLock\nSDA=machine.Pin(config.SDA_PIN) # SPI Data\n\nRES = machine.Pin(config.RESET_PIN) # Reset\nDC = machine.Pin(config.DC_PIN) # Data/command\nCS = machine.Pin(config.CS_PIN) # Chip Select\n\nspi=machine.SPI(config.SPI_BUS, sck=SCL, mosi=SDA, baudrate=100000)\noled = ssd1306.SSD1306_SPI(config.WIDTH, config.HEIGHT, spi, DC, RES, CS)\n\nyear = localtime()[0]\nmonth = localtime()[1]\nday = localtime()[2]\nhour = localtime()[3]\nminute = localtime()[4]\n\n# display the time in hour and minute on the first line\noled.text(str(hour) + \":\" + str(minute), 0, 0, 1)\n\n# display the date on the second line\noled.text(str(month) + \"/\" + str(day) + \"/\" + str(year), 0, 10, 1)\noled.show()\n</code></pre> <p>Challenges</p> <ol> <li>Change the display format of the date and time.  Place the date and time in the center of the display.</li> <li>Add code to add a \"AM\" or \"PM\" string if the hour is greater than 12 noon</li> <li>Adding additional text to display if it is morning or evening</li> </ol>"},{"location":"kits/pico-oled/04-display-localtime-updates/","title":"Display Local Time with Updates","text":"<p>Now let's update the display every second.</p> <pre><code>import machine\nimport ssd1306\nimport config\nfrom time import localtime\n\nSCL=machine.Pin(config.SCL_PIN) # SPI CLock\nSDA=machine.Pin(config.SDA_PIN) # SPI Data\n\nRES = machine.Pin(config.RESET_PIN) # Reset\nDC = machine.Pin(config.DC_PIN) # Data/command\nCS = machine.Pin(config.CS_PIN) # Chip Select\n\nspi=machine.SPI(config.SPI_BUS, sck=SCL, mosi=SDA, baudrate=100000)\noled = ssd1306.SSD1306_SPI(config.WIDTH, config.HEIGHT, spi, DC, RES, CS)\n\nwhile True:\n    # clear the entire screen\n\n    oled.fill(0)\n    year = localtime()[0]\n    month = localtime()[1]\n    day = localtime()[2]\n    hour = localtime()[3]\n    minute = localtime()[4]\n    second = localtime()[5]\n\n    # display the time in hour and minute on the first line\n    oled.text(str(hour) + \":\" + str(minute) + \":\" + str(second) , 0, 0, 1)\n\n    # display the date on the second line\n    oled.text(str(month) + \"/\" + str(day) + \"/\" + str(year), 0, 10, 1)\n    # send the entire screen to the display via SPI\n    oled.show()\n</code></pre>"},{"location":"kits/pico-oled/05-clock-hands/","title":"Clock Hands","text":"<p>Now lets display the hands on a clock.  We will need to do a little math to calculate were on the clock face to draw the hands to from the center.</p> <pre><code>import machine\nimport ssd1306\nimport config\nfrom time import sleep, localtime\nimport math\n\nSCL=machine.Pin(config.SCL_PIN) # SPI CLock\nSDA=machine.Pin(config.SDA_PIN) # SPI Data\n\nRES = machine.Pin(config.RESET_PIN) # Reset\nDC = machine.Pin(config.DC_PIN) # Data/command\nCS = machine.Pin(config.CS_PIN) # Chip Select\n\nspi=machine.SPI(config.SPI_BUS, sck=SCL, mosi=SDA, baudrate=100000)\noled = ssd1306.SSD1306_SPI(config.WIDTH, config.HEIGHT, spi, DC, RES, CS)\nTWO_PI = 3.14159 * 2\n\nLENGTH = config.HEIGHT // 2\nCENTER_X = config.WIDTH // 2\nCENTER_Y = config.HEIGHT // 2\n\noled.fill(0)\n\nfor i in range(0,61):\n    radians = (i/60)*TWO_PI\n    x = int(math.sin(radians)*LENGTH)\n    y = -int(math.cos(radians)*LENGTH)\n    # print(i, radians, x, y, x, y)  \n    oled.line(CENTER_X, CENTER_Y, CENTER_X + x, CENTER_Y + y, 1)\n    oled.show()\n    sleep(.1)\n    oled.line(CENTER_X, CENTER_Y, CENTER_X + x, CENTER_Y + y, 0)\n</code></pre>"},{"location":"kits/waveshare/","title":"Waveshare RP2040","text":"<p>The Waveshare RP2040 1.28\" IPS LCD Board is a wonderful developent board with a build in RP2040 processor that currently sells for about $18.  The board has a USB-C connector, a place for a LiPo battery connection and built in Accelerometer &amp; Gyroscope.  It is a great value and a wonderful way to start to learn Python for smart watches!</p> <ol> <li>Waveshare SKU: 22668</li> <li>Waveshare Part Number: RP2040-LCD-1.28</li> <li>Link to Waveshare site</li> </ol> <p>Note that this watch does not have a real-time clock and has no ability to connect to time syhronization using WiFi. However, it is an ideal development tool for learning to program watch displays and integrate sensors.</p>"},{"location":"kits/waveshare/#micropython-version","title":"MicroPython Version","text":"<p>To use these lessions you much use MicroPython runtime v1.19.1-854-g35524a6fd released on 2023-02-07 or later. This version supports all the native framebuf drawing libraries (ellipse and polygon)</p> <p>See the documentation here: MicroPython Framebuffer Functions</p>"},{"location":"kits/waveshare/#lessons","title":"Lessons","text":"<ol> <li>Hello world! Lesson</li> <li>Color Lab</li> <li>Drawing Analog Hands</li> <li>5x8 Fonts</li> </ol>"},{"location":"kits/waveshare/#detailed-components","title":"Detailed Components","text":"Component Description USB Type-C connector USB 1.1 with device and host support ETA6096 high efficiency Lithium battery recharge manager Battery Header MX1.25 header, for 3.7V Lithium battery, allows recharging the battery and powering the board at the same time QMI8658C IMU, includes a 3-axis gyroscope and a 3-axis accelerometer 1.27mm pitch headers Adapting all GPIO and Debug pins W25Q16JVUXIQ 2MB NOR-Flash RP2040 Dual-core processor, up to 133MHz operating frequency RESET Button Reset the processor BOOT Button press it when resetting to enter download mode"},{"location":"kits/waveshare/#references","title":"References","text":"<p>wiki</p> <p>Instructable by Tony Goodhew - note that this  version does not leverage the built-in drawing libraries that were made available in version 19 of the MicroPython release. See The MicroPython FrameBuf Library</p> <p>Github Gist by Alasdair Allan</p>"},{"location":"kits/waveshare/01-hello-world/","title":"Waveshare Hello World","text":""},{"location":"kits/waveshare/01-hello-world/#step-1-load-the-library","title":"Step 1: Load the Library","text":""},{"location":"kits/waveshare/01-hello-world/#step-2-load-a-test-program","title":"Step 2: Load a Test Program","text":"<pre><code>from LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \nLCD.set_bl_pwm(65535)\n\nLCD.fill(LCD.black)    \nLCD.text(\"Hello world!\", 50, 100, LCD.white)\nLCD.show()\n</code></pre> <p>You should see \"Hello world!\" in a small white font near the center of the screen.</p> <p>Challenges</p> <ol> <li>Can you move the text around the screen by changing the x and y starting position of the text?</li> <li>Can you change the background fill from black to another color?</li> <li>Can you change the color of the text from white to be another color?</li> <li>Can you change the font size? (hint: this is not easy!)</li> </ol>"},{"location":"kits/waveshare/02-color-test/","title":"Color Tests","text":"<p>Now let's try to make the background screen change colors:</p> <pre><code>from LCD_1inch28 import LCD_1inch28\nfrom utime import sleep\n\nLCD = LCD_1inch28()  \nLCD.set_bl_pwm(65535)\n\nLCD.fill(LCD.black)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.white)\nsleep(1)\nLCD.show()\nLCD.fill(LCD.red)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.green)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.blue)\nLCD.show()\nprint('done')\n</code></pre> <p>What happens when you change the color \"red\" to be \"orange\"?  You shouild see:</p> <pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 10, in &lt;module&gt;\nAttributeError: 'LCD_1inch28' object has no attribute 'orange'\n</code></pre> <p>This shows you that although the driver knows about some basic colors, (black, white, red, green and blue), it has no understanding of other colors.</p> <p>To draw these colors we need to add our own color lists.</p>"},{"location":"kits/waveshare/02-color-test/#custom-color-lists","title":"Custom Color Lists","text":"<p>In order to get more nuanced colors, we need to define them using the binary of their red, green and blue values.  With this display, we order the bits, blue, red and green.</p> <p>We can use the following binary notation to represent the colors:</p> <pre><code># binary representations of colors B=Blue bits, R=Red bits, G=Green bits\n# color = 0bBBBBBRRRRRGGGGGG\n# Cyan has all the blue and green bits on and the red bits off\ncyan = cyan = 0b1111100000111111\n</code></pre> <pre><code>from machine import Pin,I2C,SPI,PWM,ADC\nfrom time import sleep\nfrom LCD_1inch28 import LCD_1inch28, QMI8658\n\nCENTER = 120\nLCD = LCD_1inch28()\nLCD.set_bl_pwm(65535)\n\n# draw readability\nON = 1\nOFF = 0\nNO_FILL = 0\nFILL = 1\n# hex representation of colors\n# note that the bit order is blue, red, green\nblack = 0x0000\nred   = 0x07E0\ngreen = 0x001f\nblue  = 0xf800\nwhite = 0xffff\n\n# binary representations of colors\n# binary representations of colors B=5 Blue bits, R=5 Red bits, G=6 green bits\n# color = 0bBBBBBRRRRRGGGGGG\nyellow = 0b0000011111111111\norange = 0b0000001111000010\ncyan = 0b1111100000111111\nbrown = 0b0000000001000001\ngold = 0b0000001110011110\npurple = 0b1111111111000000\nmagenta = 0b0000001100011000\npink = 0b0000111111000010\nolive = 0b0000000001000010\ngray = 0b00001000010000100\nlightGreen = 0b0000100001111111\ndarkGreen  = 0b0000000000000001\n\nColorList =  (red,    green,   blue,   white,   yellow,  orange,\n              cyan, brown, gold, purple, magenta, pink, olive, gray, lightGreen, darkGreen)\nColorNames = ('red', 'green', 'blue', 'white', 'yellow', 'orange',\n              'cyan', 'brown', 'gold', 'purple', 'magenta', 'pink', 'olive', 'gray', 'lightGreen', 'darkGreen')\n\nradius = 120\nLCD.fill(LCD.black)\n\nfor i in range(0, len(ColorList)):\n    print(ColorNames[i])\n    # LCD.ellipse(CENTER, CENTER, radius, radius, ColorList[i], FILL)\n    LCD.fill(ColorList[i])\n    LCD.text(ColorNames[i], 100, 100, 1)\n    LCD.text(ColorNames[i], 100, 120, white)\n    LCD.show()\n    sleep(1)\n</code></pre> <p>Note that we are using the fill function to draw on all the pixels on the screen. We could have used the ellipse funtion to draw into the frame buffer, but the fill function is a bit easier.</p>"},{"location":"kits/waveshare/02-color-test/#converting-rgb888-to-brg556","title":"Converting RGB888 to BRG556","text":"<pre><code>def convert_color_RGB888_RGB565(R,G,B): # Convert RGB888 to RGB565\n    return (((G&amp;0b00011100)&lt;&lt;3) +((B&amp;0b11111000)&gt;&gt;3)&lt;&lt;8) + (R&amp;0b11111000)+((G&amp;0b11100000)&gt;&gt;5)\n</code></pre>"},{"location":"kits/waveshare/02-display-text/","title":"Display Time and Date in Text","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {} {}, {}\".format(day_name, month_name, now[2], now[0])\n\nwhile(True):\n    now = localtime()\n    # print(now)\n    LCD.fill(LCD.black)    \n    LCD.text(format_time(now), 77, 50, LCD.white)\n    LCD.text(format_date(now), 40, 80, LCD.white)\n    LCD.show()\n    sleep(1)\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/","title":"Drawing Analog Hands","text":"<p>Drawing a analog hand requirs drawing a line from the center of the screen to a point on the edge of the circle.  The point positon varies periodically, just like the sine and cosine functions vary.  We can demonstrate this will a counter that goes from 0 to 360 degrees.</p> <p>Consider the following:</p> <ol> <li>Since the sine(0) = 0 we can use that function for the displacement from the center on the x-axis.</li> <li>Since the cosine(0) = 1, we can use that as the negative Y displacement from the center.  Remember in drawing pixels, (0,0) is in the upper-left corner of the screen.</li> </ol> <p>There is one other bit of math we need to review.  The sine() and cosine() function take in a number called <code>radians</code> which is usually a number between 0 and two times Pi.  They then return a value between 0 and 1.  We need multiple both of these values by the length of the watch hand to get to the right part of the watch face.</p> <pre><code>from utime import sleep\nfrom LCD_1inch28 import LCD_1inch28\nimport math\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nHAND_LENGTH = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nwhile True:\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    print(radians, x, y)\n    LCD.fill(LCD.black)\n    LCD.line(CENTER, CENTER, CENTER+x,CENTER+y, LCD.white)\n    LCD.show()\n    sleep(1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre> <p>You should now see a narrow white line moving much like a second hand on a watch!</p>"},{"location":"kits/waveshare/03-drawing-hands/#adding-bling-to-your-hands","title":"Adding bling to your hands","text":"<p>Although drawing a single white line is a clean efficent design, many people like to add other features such as an arrow head at the tip of the hand.  To do this we can use the poly function to draw the arrow.  To get this right, we also need to orient the arrow in the right direction.</p>"},{"location":"kits/waveshare/03-drawing-hands/#drawing-a-triangle","title":"Drawing a Triangle","text":"<p>We can use the MicroPython standard poly function to draw a triangle.  The poly </p> <p><code>`FrameBuffer.poly(x, y, coords, c[, f])</code></p> <p>This will draw an arbitrary polygon at the given x, y location using the given color (c).</p> <p>The coords must be specified as a array of integers, e.g. array('h', [x0, y0, x1, y1, ... xn, yn]).</p> <p>The optional f parameter can be set to True to fill the polygon. Otherwise just a one pixel outline is drawn.</p> <p>Let's start with drawing a basic triangle in the center of the screen like this:</p> <p>LCD.</p> <pre><code># draw a triangle on a blue background\nfrom utime import sleep\nfrom LCD_1inch28 import LCD_1inch28\nimport math\nfrom array import array\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n# draw a blue background\nLCD.fill(LCD.blue)\n\n# distance from the center to the tip of the traiangle\nd = 50\nmy_array = array('B', [CENTER-d,CENTER+d, CENTER,CENTER-d, CENTER+d,CENTER+d])\nLCD.poly(0,0, my_array, LCD.white, FILL)\nLCD.show()\nprint('done')\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/#drawing-a-triangle-rotating","title":"Drawing a Triangle Rotating","text":"<p>Now we will modify the draw triangle program to rotate each of the three points. We do this by passing the CENTER and either a positve or negative value of the x and y which varies as we move around the circle.</p> <p>Here is the line that is the most difficult to understand:</p> <pre><code>my_array = array('B', [CENTER-x,CENTER-y, CENTER+y,CENTER-x, CENTER+x,CENTER+y])\n</code></pre> <p>Note that the first point is in the lower left corner:</p> <pre><code>(CENTER-x, CENTER-y)\n</code></pre> <p>The second point is at the top of the trainagle and the X is initially zero (sine(0) = y)</p> <pre><code>(CENTER+y, CENTER-x)\n</code></pre> <p>The third point is to the lower right where we need to add to both the X and Y:</p> <pre><code>(CENTER+x, CENTER-y)\n</code></pre> <p>Here is the full program:</p> <pre><code># draw rotating triangle\nfrom utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\nfrom array import array\nimport math\nTWO_PI = 3.145175*2\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n\n# distance from the center to the tip of the traiangle\nd = 50\n\ncounter = 0\nwhile True:\n    LCD.fill(LCD.blue)\n    radians = (counter/60)*TWO_PI\n    x = int(math.cos(radians)*d)\n    y = int(math.sin(radians)*d)\n\n    # the three points of the triangle are rotated in a circle\n    my_array = array('B', [CENTER-x,CENTER-y, CENTER+y,CENTER-x, CENTER+x,CENTER+y])\n    print(CENTER-x, CENTER+y)\n\n    LCD.poly(0,0, my_array, LCD.white, FILL)\n    LCD.show()\n    sleep(.1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre> <p>You might have to stare at the code and the drawing for a while to get this figured out.</p>"},{"location":"kits/waveshare/03-drawing-hands/#create-a-draw-triangle-function","title":"Create a Draw Triangle Function","text":"<p>Now we are ready to package our triangle drawing experiment into a single function to make it easier to use.  We will pass in four parameters:</p> <ol> <li>The center of the triangle's X and Y coordinates</li> <li>The size of the triangle measured from the center to the tip</li> <li>The number of seconds on the clock (0 to 59) which we will convert to radians.  This becomes the agle of the triangle.</li> </ol> <pre><code>def drawTriangle(x, y, size, seconds):\n    radians = (seconds/60)*TWO_PI\n    # calculate the offsets\n    xo = int(math.cos(radians)*size)\n    yo = int(math.sin(radians)*size)\n    # build the array - use B if we have under 255 and h if over 255\n    arr = array('B', [x-xo,y-yo,  x+yo,y-xo,  x+xo,y+yo])\n    LCD.poly(0,0, arr, LCD.white, FILL)\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/#full-program","title":"Full Program","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\nfrom array import array\nimport math\nTWO_PI = 3.145175*2\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\nHAND_LENGTH = 100\nTRIANGLE_SIZE = 10\n\ndef drawTriangle(x, y, size, seconds):\n    radians = (seconds/60)*TWO_PI\n    # calculate the offsets\n    xo = int(math.cos(radians)*size)\n    yo = int(math.sin(radians)*size)\n    # build the array - use B if we have under 255 and h if over 255\n    arr = array('B', [x-xo,y-yo,  x+yo,y-xo,  x+xo,y+yo])\n    LCD.poly(0,0, arr, LCD.white, FILL)\n\ncounter = 0\nwhile True:\n    LCD.fill(LCD.blue)\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    LCD.line(CENTER, CENTER, CENTER+x,CENTER+y, LCD.white)\n    drawTriangle(CENTER+x, CENTER+y, TRIANGLE_SIZE, counter)\n    LCD.show()\n    sleep(.1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0```\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/#drawing-x-and-y-axis","title":"Drawing X and Y Axis","text":"<pre><code># draw thin blue axis lines through the center\n# vertical line\nLCD.line(CENTER, 0, CENTER, 2*CENTER, blue)\n# horizontal line\nLCD.line(0, CENTER, 2*CENTER, CENTER, blue)\n</code></pre>"},{"location":"kits/waveshare/04-5x8-font/","title":"5x8 Font Test","text":"<p>We can create custom functions for drawing larger fonts.  Here we have a byte array of 5X8 fonts.  The function <code>character()</code> draws individual characters one at a time.</p> <pre><code>from LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\n# Standard ASCII 5x8 font\n# https://gist.github.com/tdicola/229b3eeddc12d58fb0bc724a9062aa05\nFONT_HEIGHT = 8\nFONT_WIDTH = 5\nFONT = bytes([\n    0x00, 0x00, 0x00, 0x00, 0x00, # &lt;space&gt;\n    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,\n    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,\n    0x1C, 0x3E, 0x7C, 0x3E, 0x1C,\n    0x18, 0x3C, 0x7E, 0x3C, 0x18,\n    0x1C, 0x57, 0x7D, 0x57, 0x1C,\n    0x1C, 0x5E, 0x7F, 0x5E, 0x1C,\n    0x00, 0x18, 0x3C, 0x18, 0x00,\n    0xFF, 0xE7, 0xC3, 0xE7, 0xFF,\n    0x00, 0x18, 0x24, 0x18, 0x00,\n    0xFF, 0xE7, 0xDB, 0xE7, 0xFF,\n    0x30, 0x48, 0x3A, 0x06, 0x0E,\n    0x26, 0x29, 0x79, 0x29, 0x26,\n    0x40, 0x7F, 0x05, 0x05, 0x07,\n    0x40, 0x7F, 0x05, 0x25, 0x3F,\n    0x5A, 0x3C, 0xE7, 0x3C, 0x5A,\n    0x7F, 0x3E, 0x1C, 0x1C, 0x08,\n    0x08, 0x1C, 0x1C, 0x3E, 0x7F,\n    0x14, 0x22, 0x7F, 0x22, 0x14,\n    0x5F, 0x5F, 0x00, 0x5F, 0x5F,\n    0x06, 0x09, 0x7F, 0x01, 0x7F,\n    0x00, 0x66, 0x89, 0x95, 0x6A,\n    0x60, 0x60, 0x60, 0x60, 0x60,\n    0x94, 0xA2, 0xFF, 0xA2, 0x94,\n    0x08, 0x04, 0x7E, 0x04, 0x08, # UP\n    0x10, 0x20, 0x7E, 0x20, 0x10, # Down\n    0x08, 0x08, 0x2A, 0x1C, 0x08, # Right\n    0x08, 0x1C, 0x2A, 0x08, 0x08, # Left\n    0x1E, 0x10, 0x10, 0x10, 0x10,\n    0x0C, 0x1E, 0x0C, 0x1E, 0x0C,\n    0x30, 0x38, 0x3E, 0x38, 0x30,\n    0x06, 0x0E, 0x3E, 0x0E, 0x06,\n    0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x5F, 0x00, 0x00,\n    0x00, 0x07, 0x00, 0x07, 0x00,\n    0x14, 0x7F, 0x14, 0x7F, 0x14,\n    0x24, 0x2A, 0x7F, 0x2A, 0x12,\n    0x23, 0x13, 0x08, 0x64, 0x62,\n    0x36, 0x49, 0x56, 0x20, 0x50,\n    0x00, 0x08, 0x07, 0x03, 0x00,\n    0x00, 0x1C, 0x22, 0x41, 0x00,\n    0x00, 0x41, 0x22, 0x1C, 0x00,\n    0x2A, 0x1C, 0x7F, 0x1C, 0x2A,\n    0x08, 0x08, 0x3E, 0x08, 0x08,\n    0x00, 0x80, 0x70, 0x30, 0x00,\n    0x08, 0x08, 0x08, 0x08, 0x08,\n    0x00, 0x00, 0x60, 0x60, 0x00,\n    0x20, 0x10, 0x08, 0x04, 0x02,\n    0x3E, 0x51, 0x49, 0x45, 0x3E,\n    0x00, 0x42, 0x7F, 0x40, 0x00,\n    0x72, 0x49, 0x49, 0x49, 0x46,\n    0x21, 0x41, 0x49, 0x4D, 0x33,\n    0x18, 0x14, 0x12, 0x7F, 0x10,\n    0x27, 0x45, 0x45, 0x45, 0x39,\n    0x3C, 0x4A, 0x49, 0x49, 0x31,\n    0x41, 0x21, 0x11, 0x09, 0x07,\n    0x36, 0x49, 0x49, 0x49, 0x36,\n    0x46, 0x49, 0x49, 0x29, 0x1E,\n    0x00, 0x00, 0x14, 0x00, 0x00,\n    0x00, 0x40, 0x34, 0x00, 0x00,\n    0x00, 0x08, 0x14, 0x22, 0x41,\n    0x14, 0x14, 0x14, 0x14, 0x14,\n    0x00, 0x41, 0x22, 0x14, 0x08,\n    0x02, 0x01, 0x59, 0x09, 0x06,\n    0x3E, 0x41, 0x5D, 0x59, 0x4E,\n    0x7C, 0x12, 0x11, 0x12, 0x7C, # A\n    0x7F, 0x49, 0x49, 0x49, 0x36,\n    0x3E, 0x41, 0x41, 0x41, 0x22,\n    0x7F, 0x41, 0x41, 0x41, 0x3E,\n    0x7F, 0x49, 0x49, 0x49, 0x41,\n    0x7F, 0x09, 0x09, 0x09, 0x01,\n    0x3E, 0x41, 0x41, 0x51, 0x73,\n    0x7F, 0x08, 0x08, 0x08, 0x7F,\n    0x00, 0x41, 0x7F, 0x41, 0x00,\n    0x20, 0x40, 0x41, 0x3F, 0x01,\n    0x7F, 0x08, 0x14, 0x22, 0x41,\n    0x7F, 0x40, 0x40, 0x40, 0x40,\n    0x7F, 0x02, 0x1C, 0x02, 0x7F,\n    0x7F, 0x04, 0x08, 0x10, 0x7F,\n    0x3E, 0x41, 0x41, 0x41, 0x3E,\n    0x7F, 0x09, 0x09, 0x09, 0x06,\n    0x3E, 0x41, 0x51, 0x21, 0x5E,\n    0x7F, 0x09, 0x19, 0x29, 0x46,\n    0x26, 0x49, 0x49, 0x49, 0x32,\n    0x03, 0x01, 0x7F, 0x01, 0x03,\n    0x3F, 0x40, 0x40, 0x40, 0x3F,\n    0x1F, 0x20, 0x40, 0x20, 0x1F,\n    0x3F, 0x40, 0x38, 0x40, 0x3F,\n    0x63, 0x14, 0x08, 0x14, 0x63,\n    0x03, 0x04, 0x78, 0x04, 0x03,\n    0x61, 0x59, 0x49, 0x4D, 0x43,\n    0x00, 0x7F, 0x41, 0x41, 0x41,\n    0x02, 0x04, 0x08, 0x10, 0x20,\n    0x00, 0x41, 0x41, 0x41, 0x7F,\n    0x04, 0x02, 0x01, 0x02, 0x04,\n    0x40, 0x40, 0x40, 0x40, 0x40,\n    0x00, 0x03, 0x07, 0x08, 0x00,\n    0x20, 0x54, 0x54, 0x78, 0x40,\n    0x7F, 0x28, 0x44, 0x44, 0x38,\n    0x38, 0x44, 0x44, 0x44, 0x28,\n    0x38, 0x44, 0x44, 0x28, 0x7F,\n    0x38, 0x54, 0x54, 0x54, 0x18,\n    0x00, 0x08, 0x7E, 0x09, 0x02,\n    0x18, 0xA4, 0xA4, 0x9C, 0x78,\n    0x7F, 0x08, 0x04, 0x04, 0x78,\n    0x00, 0x44, 0x7D, 0x40, 0x00,\n    0x20, 0x40, 0x40, 0x3D, 0x00,\n    0x7F, 0x10, 0x28, 0x44, 0x00,\n    0x00, 0x41, 0x7F, 0x40, 0x00,\n    0x7C, 0x04, 0x78, 0x04, 0x78,\n    0x7C, 0x08, 0x04, 0x04, 0x78,\n    0x38, 0x44, 0x44, 0x44, 0x38,\n    0xFC, 0x18, 0x24, 0x24, 0x18,\n    0x18, 0x24, 0x24, 0x18, 0xFC,\n    0x7C, 0x08, 0x04, 0x04, 0x08,\n    0x48, 0x54, 0x54, 0x54, 0x24,\n    0x04, 0x04, 0x3F, 0x44, 0x24,\n    0x3C, 0x40, 0x40, 0x20, 0x7C,\n    0x1C, 0x20, 0x40, 0x20, 0x1C,\n    0x3C, 0x40, 0x30, 0x40, 0x3C,\n    0x44, 0x28, 0x10, 0x28, 0x44,\n    0x4C, 0x90, 0x90, 0x90, 0x7C,\n    0x44, 0x64, 0x54, 0x4C, 0x44,\n    0x00, 0x08, 0x36, 0x41, 0x00,\n    0x00, 0x00, 0x77, 0x00, 0x00,\n    0x00, 0x41, 0x36, 0x08, 0x00,\n    0x02, 0x01, 0x02, 0x04, 0x02,\n    0x3C, 0x26, 0x23, 0x26, 0x3C,\n    0x1E, 0xA1, 0xA1, 0x61, 0x12, # Extension starts here\n    0x3A, 0x40, 0x40, 0x20, 0x7A,\n    0x38, 0x54, 0x54, 0x55, 0x59,\n    0x21, 0x55, 0x55, 0x79, 0x41,\n    0x22, 0x54, 0x54, 0x78, 0x42, # a-umlaut\n    0x21, 0x55, 0x54, 0x78, 0x40,\n    0x20, 0x54, 0x55, 0x79, 0x40,\n    0x0C, 0x1E, 0x52, 0x72, 0x12,\n    0x39, 0x55, 0x55, 0x55, 0x59,\n    0x39, 0x54, 0x54, 0x54, 0x59,\n    0x39, 0x55, 0x54, 0x54, 0x58,\n    0x00, 0x00, 0x45, 0x7C, 0x41,\n    0x00, 0x02, 0x45, 0x7D, 0x42,\n    0x00, 0x01, 0x45, 0x7C, 0x40,\n    0x7D, 0x12, 0x11, 0x12, 0x7D, # A-umlaut\n    0xF0, 0x28, 0x25, 0x28, 0xF0,\n    0x7C, 0x54, 0x55, 0x45, 0x00,\n    0x20, 0x54, 0x54, 0x7C, 0x54,\n    0x7C, 0x0A, 0x09, 0x7F, 0x49,\n    0x32, 0x49, 0x49, 0x49, 0x32,\n    0x3A, 0x44, 0x44, 0x44, 0x3A, # o-umlaut\n    0x32, 0x4A, 0x48, 0x48, 0x30,\n    0x3A, 0x41, 0x41, 0x21, 0x7A,\n    0x3A, 0x42, 0x40, 0x20, 0x78,\n    0x00, 0x9D, 0xA0, 0xA0, 0x7D,\n    0x3D, 0x42, 0x42, 0x42, 0x3D, # O-umlaut\n    0x3D, 0x40, 0x40, 0x40, 0x3D,\n    0x3C, 0x24, 0xFF, 0x24, 0x24,\n    0x48, 0x7E, 0x49, 0x43, 0x66,\n    0x2B, 0x2F, 0xFC, 0x2F, 0x2B,\n    0xFF, 0x09, 0x29, 0xF6, 0x20,\n    0xC0, 0x88, 0x7E, 0x09, 0x03,\n    0x20, 0x54, 0x54, 0x79, 0x41,\n    0x00, 0x00, 0x44, 0x7D, 0x41,\n    0x30, 0x48, 0x48, 0x4A, 0x32,\n    0x38, 0x40, 0x40, 0x22, 0x7A,\n    0x00, 0x7A, 0x0A, 0x0A, 0x72,\n    0x7D, 0x0D, 0x19, 0x31, 0x7D,\n    0x26, 0x29, 0x29, 0x2F, 0x28,\n    0x26, 0x29, 0x29, 0x29, 0x26,\n    0x30, 0x48, 0x4D, 0x40, 0x20,\n    0x38, 0x08, 0x08, 0x08, 0x08,\n    0x08, 0x08, 0x08, 0x08, 0x38,\n    0x2F, 0x10, 0xC8, 0xAC, 0xBA,\n    0x2F, 0x10, 0x28, 0x34, 0xFA,\n    0x00, 0x00, 0x7B, 0x00, 0x00,\n    0x08, 0x14, 0x2A, 0x14, 0x22,\n    0x22, 0x14, 0x2A, 0x14, 0x08,\n    0x55, 0x00, 0x55, 0x00, 0x55, # 176 (25% block) missing in old code\n    0xAA, 0x55, 0xAA, 0x55, 0xAA, # 50% block\n    0xFF, 0x55, 0xFF, 0x55, 0xFF, # 75% block\n    0x00, 0x00, 0x00, 0xFF, 0x00,\n    0x10, 0x10, 0x10, 0xFF, 0x00,\n    0x14, 0x14, 0x14, 0xFF, 0x00,\n    0x10, 0x10, 0xFF, 0x00, 0xFF,\n    0x10, 0x10, 0xF0, 0x10, 0xF0,\n    0x14, 0x14, 0x14, 0xFC, 0x00,\n    0x14, 0x14, 0xF7, 0x00, 0xFF,\n    0x00, 0x00, 0xFF, 0x00, 0xFF,\n    0x14, 0x14, 0xF4, 0x04, 0xFC,\n    0x14, 0x14, 0x17, 0x10, 0x1F,\n    0x10, 0x10, 0x1F, 0x10, 0x1F,\n    0x14, 0x14, 0x14, 0x1F, 0x00,\n    0x10, 0x10, 0x10, 0xF0, 0x00,\n    0x00, 0x00, 0x00, 0x1F, 0x10,\n    0x10, 0x10, 0x10, 0x1F, 0x10,\n    0x10, 0x10, 0x10, 0xF0, 0x10,\n    0x00, 0x00, 0x00, 0xFF, 0x10,\n    0x10, 0x10, 0x10, 0x10, 0x10,\n    0x10, 0x10, 0x10, 0xFF, 0x10,\n    0x00, 0x00, 0x00, 0xFF, 0x14,\n    0x00, 0x00, 0xFF, 0x00, 0xFF,\n    0x00, 0x00, 0x1F, 0x10, 0x17,\n    0x00, 0x00, 0xFC, 0x04, 0xF4,\n    0x14, 0x14, 0x17, 0x10, 0x17,\n    0x14, 0x14, 0xF4, 0x04, 0xF4,\n    0x00, 0x00, 0xFF, 0x00, 0xF7,\n    0x14, 0x14, 0x14, 0x14, 0x14,\n    0x14, 0x14, 0xF7, 0x00, 0xF7,\n    0x14, 0x14, 0x14, 0x17, 0x14,\n    0x10, 0x10, 0x1F, 0x10, 0x1F,\n    0x14, 0x14, 0x14, 0xF4, 0x14,\n    0x10, 0x10, 0xF0, 0x10, 0xF0, # ok\n    0x00, 0x00, 0x1F, 0x10, 0x1F,\n    0x00, 0x00, 0x00, 0x1F, 0x14,\n#   0x00, 0x00, 0x00, 0xFC, 0x14, # any new after this line breaks\n    0x00, 0x00, 0x00, 0x00, 0x00  # 255 also a &lt;space&gt;\n])\n\ndef convert_color_RGB888_RGB565(R,G,B): # Convert RGB888 to RGB565\n    return (((G&amp;0b00011100)&lt;&lt;3) + ((B&amp;0b11111000)&gt;&gt;3)&lt;&lt;8) + (R&amp;0b11111000) + ((G&amp;0b11100000)&gt;&gt;5)\n\ndef character(asc, xt, yt, sz, r, g, b):  # Single character sz is size: 1 or 2\n    cc = convert_color_RGB888_RGB565(r,g,b)\n    code = asc * 5    # 5 bytes per character\n    for ii in range(5):\n        line = FONT[code + ii]\n        for yy in range(8):\n            if (line &gt;&gt; yy) &amp; 0x1:\n                LCD.pixel(ii*sz+xt,yy*sz+yt,cc) \n                if sz &gt; 1:\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt,cc)\n                    LCD.pixel(ii*sz+xt,yy*sz+yt+1,cc)\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt+1,cc)\n                if sz == 3:\n                    LCD.pixel(ii*sz+xt,  yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt+1,cc)\n\n# Print a string\ndef prnt_st(asci, xx, yy, sz,r,g,b):  # Text string\n    if sz == 1: move = 6\n    if sz == 2: move = 11\n    if sz == 3: move = 17 \n    for letter in(asci):\n        asci = ord(letter)\n        character(asci,xx,yy,sz,r,g,b)\n        xx = xx + move\n\n# Center text string\ndef cntr_st(s,y,sz,r,g,b): # Centres text on line y\n    if sz == 1: w = 6\n    if sz == 2: w = 11\n    if sz == 3: w = 17 \n    gap = int((width - len(s) * w)/2)\n    prnt_st(s,gap,y,sz,r,g,b)\n\nLCD.fill(LCD.black)    \nprnt_st(\"Hello world! Red\", 20, 80, 2, 255, 0, 0)\nprnt_st(\"Hello world! Green\", 20, 100, 2, 0, 255, 0)\nprnt_st(\"Hello world! Blue\", 20, 120, 2, 0, 0, 255)\nprnt_st(\"Hello world! White\", 20, 140, 2, 255, 255, 255)\nLCD.show()\n</code></pre>"},{"location":"lessons/","title":"Python Project-Based Learning: Building Clocks and Watches with Smart Watch Displays","text":"<p>These lessons are general to all of our kits.  We often use the Pico OLED for many examples since that is the kit we have been using for the longest time.</p> <p>These lessons focus on using functions like the  MicroPython localtime() to get the time in your current timezone.</p> <p>They also focus on drawing scalable numbers on different size displays and drawing times on larger color displays.</p> <p>Here are some sample lesson plans for a 14-week semimester hich school course on learning computational thining by using MicroPython to write clock and smartwatch application.  This course assumes no prior knowledge of programming.</p>"},{"location":"lessons/#weeks-1-2-introduction-to-python-and-basic-concepts","title":"Weeks 1-2: Introduction to Python and Basic Concepts","text":""},{"location":"lessons/#lesson-1-introduction-to-python","title":"Lesson 1: Introduction to Python","text":"<ul> <li>What is Python?</li> <li>Why learn Python?</li> <li>Data Science</li> <li>Artificial Intellegence</li> <li>Python Installation and Setup</li> </ul>"},{"location":"lessons/#lesson-2-hello-world","title":"Lesson 2: Hello, World!","text":"<ul> <li>Writing the first Python program</li> <li>Drawing a simple rectangle to the screen</li> <li>Making the rectangle bounce around the screen</li> <li>Understanding Python syntax</li> <li>Using the graphics library for your clock or watch</li> </ul>"},{"location":"lessons/#lesson-3-variables-and-data-types","title":"Lesson 3: Variables and Data Types","text":"<ul> <li>Introduction to variables</li> <li>Common data types (integers, floats, strings, booleans)</li> <li>Drawing with pixels, lines and rectangles</li> <li>Chainging color</li> </ul>"},{"location":"lessons/#lesson-4-basic-operations","title":"Lesson 4: Basic Operations","text":"<ul> <li>Arithmetic operations</li> <li>Concatenation and repetition</li> <li>Assignment operators</li> <li>Lists of colors</li> </ul>"},{"location":"lessons/#weeks-3-4-control-structures-and-functions","title":"Weeks 3-4: Control Structures and Functions","text":""},{"location":"lessons/#lesson-5-conditionals","title":"Lesson 5: Conditionals","text":"<ul> <li><code>if</code>, <code>else</code>, and <code>elif</code> statements</li> <li>Alternating the color of your lines</li> <li>Horizontal and radial lines</li> </ul>"},{"location":"lessons/#lesson-6-loops","title":"Lesson 6: Loops","text":"<ul> <li><code>for</code> and <code>while</code> loops</li> <li>Loop control with <code>break</code> and <code>continue</code></li> <li>Draing the tick marks on a watch</li> </ul>"},{"location":"lessons/#lesson-7-functions","title":"Lesson 7: Functions","text":"<ul> <li>Defining and calling functions</li> <li>Arguments and return values</li> </ul>"},{"location":"lessons/#weeks-5-6-working-with-libraries-and-hardware","title":"Weeks 5-6: Working with Libraries and Hardware","text":""},{"location":"lessons/#lesson-8-importing-libraries","title":"Lesson 8: Importing Libraries","text":"<ul> <li>What is a library?</li> <li>Importing and using libraries</li> </ul>"},{"location":"lessons/#lesson-9-introduction-to-hardware-interaction","title":"Lesson 9: Introduction to Hardware Interaction","text":"<ul> <li>Communicating with smart watch displays</li> <li>Sending and receiving data</li> </ul>"},{"location":"lessons/#weeks-7-8-project-1-basic-digital-clock","title":"Weeks 7-8: Project 1: Basic Digital Clock","text":""},{"location":"lessons/#lesson-10-planning-the-project","title":"Lesson 10: Planning the Project","text":"<ul> <li>Project overview</li> <li>Creating a project plan</li> </ul>"},{"location":"lessons/#lesson-11-building-a-basic-digital-clock","title":"Lesson 11: Building a Basic Digital Clock","text":"<ul> <li>Displaying time on the smart watch display</li> <li>Updating the time</li> </ul>"},{"location":"lessons/#weeks-9-10-intermediate-python-concepts","title":"Weeks 9-10: Intermediate Python Concepts","text":""},{"location":"lessons/#lesson-12-lists-and-dictionaries","title":"Lesson 12: Lists and Dictionaries","text":"<ul> <li>Creating and manipulating lists and dictionaries</li> </ul>"},{"location":"lessons/#lesson-13-error-handling","title":"Lesson 13: Error Handling","text":"<ul> <li><code>try</code> and <code>except</code> blocks</li> </ul>"},{"location":"lessons/#weeks-11-12-project-2-analog-clock-display","title":"Weeks 11-12: Project 2: Analog Clock Display","text":""},{"location":"lessons/#lesson-14-planning-the-project","title":"Lesson 14: Planning the Project","text":"<ul> <li>Project overview</li> <li>Creating a project plan</li> </ul>"},{"location":"lessons/#lesson-15-building-an-analog-clock-display","title":"Lesson 15: Building an Analog Clock Display","text":"<ul> <li>Designing an analog clock</li> <li>Rotating clock hands based on the current time</li> </ul>"},{"location":"lessons/#weeks-13-14-advanced-python-concepts-and-optimization","title":"Weeks 13-14: Advanced Python Concepts and Optimization","text":""},{"location":"lessons/#lesson-16-more-about-functions","title":"Lesson 16: More About Functions","text":"<ul> <li>Lambda functions, higher-order functions</li> </ul>"},{"location":"lessons/#lesson-17-optimization-techniques","title":"Lesson 17: Optimization Techniques","text":"<ul> <li>Improving code efficiency</li> </ul>"},{"location":"lessons/#weeks-15-16-final-project-customizable-clockwatch","title":"Weeks 15-16: Final Project: Customizable Clock/Watch","text":""},{"location":"lessons/#lesson-18-planning-the-project","title":"Lesson 18: Planning the Project","text":"<ul> <li>Project overview</li> <li>Creating a project plan</li> </ul>"},{"location":"lessons/#lesson-19-building-a-customizable-clockwatch","title":"Lesson 19: Building a Customizable Clock/Watch","text":"<ul> <li>Adding customization options (color, style, etc.)</li> <li>Implementing user input for customization</li> </ul>"},{"location":"lessons/#lesson-20-final-project-presentations","title":"Lesson 20: Final Project Presentations","text":"<ul> <li>Students present their final projects</li> <li>Review and feedback session</li> </ul>"},{"location":"lessons/#ongoing-reflection-and-feedback","title":"Ongoing: Reflection and Feedback","text":"<ul> <li>After each project, have students reflect on what went well, what they struggled with, and what they learned.</li> <li>Continuously solicit feedback from students to improve the learning experience.</li> </ul> <p>This outline provides a balance between teaching Python concepts and applying them to real-world projects, which can keep students engaged and help them to better retain what they've learned. Tailor this outline to meet the specific needs and pace of your students, and ensure to provide plenty of opportunities for students to practice their skills, ask questions, and get feedback.</p>"},{"location":"lessons/00-hardware-config/","title":"Hardware Configuration Files","text":"<p>All our current displays use the SPI interface.  The alternative microcontroller bus, I2C, is about 10x slower than SPI.  The SPI intrface interface typically uses 7 wires, which can get a little complex.  Just a single wire broken or two wires crossed can will cause the display to not work.</p> <p>We have dozens of sample programs for each kit.  And the exact connections on our kits vary.  Rather than hard-coding the hardware pin numbers in each example, we can move them to a separate config.py file.  We can then just import that file into each of our examples.</p> <p>Here is a sample config.py file:</p> <pre><code># Dan's Robot Labs configuration file for ILI9341 clock project\n# The colors on the SPI bus cable are:\n# 3.3v power - red\n# SCK - orange\n# MISO/Data - yellow\n# DC - green\n# RESET - blue\n# GND - black\n# CS - purple\n\nSCK_PIN = 2\nMISO_PIN = 3 # labeled SDI(MOSI) on the back of the display\nDC_PIN = 4\nRESET_PIN = 5\nCS_PIN = 6\nROTATION = 90\n\nWIDTH=320\nHEIGHT=240\n</code></pre> <p>To use this configuration file you will need to do two things:</p> <ol> <li>import the config file (don't add the .py extension)</li> <li>Add the prefix <code>config.</code> to each value you would like to reference.</li> </ol> <pre><code>import config\n\nWIDTH=config.WIDTH\n</code></pre>"},{"location":"lessons/01-drawing-coordinates/","title":"Drawing Coordinates","text":"<p>Screen Coordinates Lab on Robot Faces</p>"},{"location":"lessons/01-get-local-time/","title":"Getting Local Time","text":""},{"location":"lessons/01-get-local-time/#lesson-overview","title":"Lesson Overview","text":"<p>In this lesson, we will learn how to get the local date and time from the MicroPython runtime.  We will learn the components of the list of numbers returned by these functions.</p> <p>MicroPython provides a very convenient function called <code>localtime()</code> that will get the time from the host computer that you connect to via your USB cable.  Your local computer has a clock and knows the time in the local timezone.  This information is sent to MicroPython runtime when the computer is connected to the USB cable.</p> <p>Note</p> <p>The <code>gmtime()</code> function returns the time in UTC (Coordinated Universal Time) time.  Use this if you want time stamps that are not dependent on time zone and daylight savings rules.  For example, log files should use this function.</p>"},{"location":"lessons/01-get-local-time/#sample-code","title":"Sample Code","text":"<pre><code>import time\n\nprint(time.localtime())\n</code></pre>"},{"location":"lessons/01-get-local-time/#result","title":"Result","text":"<p>Local time returns a read-only tuple:</p> <pre><code>(2023, 2, 28, 18, 54, 7, 1, 59)\n</code></pre>"},{"location":"lessons/01-get-local-time/#extracting-specific-datetime-components","title":"Extracting Specific Date/Time Components","text":"<pre><code>from time import localtime\n\nnow = localtime()\nprint(now)\n\nprint('year:',    now[0])\nprint('month:',   now[1])\nprint('day:',     now[2])\nprint('hour:',    now[3])\nprint('minute:',  now[4])\nprint('sec:',     now[5])\nprint('weekday:', now[6])\nprint('day of year:', now[7])\n</code></pre>"},{"location":"lessons/01-get-local-time/#format-of-the-localtime","title":"Format of the Localtime","text":"<p>The format is a \"8-tuple\" of integers in the format (year, month, mday, hour, minute, second, weekday, yearday)</p> <p>Most of the values are pretty intuitive to figure out.  There are a few notes.</p> <ol> <li>Hour is the hour in 24-hour format.  If we want to display the hour in 12-hour format we will need to do some formatting.</li> <li>Weekday is a numeric code that runs from 0 for Monday to 6 for Sunday.</li> <li>Yearday is the day of the year.  January 1st is the fist day of the year so it is a 1.</li> </ol>"},{"location":"lessons/01-get-local-time/#printing-formatted-dates","title":"Printing Formatted Dates","text":""},{"location":"lessons/01-get-local-time/#sample-code_1","title":"Sample Code","text":"<pre><code>import time\n\nnow = time.localtime()\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\nfor i in range(8):\n    print(label[i], ':', now[i])\n\nprint()\nprint(\"Date: {}/{}/{}\".format(now[1], now[2], now[0]))\nprint(\"Time: {}:{}\".format(now[3], now[4]))\n</code></pre>"},{"location":"lessons/01-get-local-time/#results","title":"Results","text":"<pre><code>year : 2023\nmonth : 2\nmday : 28\nhour : 19\nminute : 20\nsecond : 26\nweekday : 1\nyearday : 59\n\nDate: 2/28/2023\nTime: 19:20\n</code></pre>"},{"location":"lessons/01-get-local-time/#label-formatting","title":"Label Formatting","text":"<p>We can also add labels to make the date and time easier to read.</p> <pre><code>import time\n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\n\nnow = time.localtime()\n\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\nmonth_number = now[1]\nmonth_name = months[month_number]\nweekday_number = now[6]\nday_name = days[weekday_number]\nhour_number = now[3]\nif hour_number &lt; 13:\n    hour_12 = hour_number\n    am_pm = 'am'\nelse:\n    hour_12 = hour_number - 12\n    am_pm = 'pm'\n\nprint()\nprint(\"Date: {} {} {}, {}\".format(day_name, month_name, now[2], now[0]))\nprint(\"Time: {}:{} {}\".format(hour_12, now[4], am_pm))\n</code></pre>"},{"location":"lessons/01-get-local-time/#label-formatted-results","title":"Label Formatted Results","text":"<pre><code>Date: Tuesday March 28, 2023\nTime: 7:46 pm\n</code></pre>"},{"location":"lessons/01-get-local-time/#modifying-the-thonny-parameters","title":"Modifying the Thonny Parameters","text":"<p>By default Thonny syncs the host time at power up.</p> <p></p> <p>We can disable this.</p> <pre><code>import time\nprint(time.localtime())\n</code></pre> <p><pre><code>(2021, 1, 1, 0, 0, 22, 4, 1)\n</code></pre> This was printed 22 seconds after power up.</p> <p>The Pico \"W\" can sync with the NTP functions.</p> <pre><code>from mpython import *\nimport ntptime\nimport secrets\n\n# summary\nmywifi=wifi()\nmywifi.connectWiFi(secrets.wifi_ssid, secrets.wifi_pass)\n\nprint(\"Local time before synchronization\uff1a%s\" %str(time.localtime()))\nntptime.settime()\nprint(\"Local time after synchronization\uff1a%s\" %str(time.localtime()))\n</code></pre> <p>Result:</p> <pre><code>Local time before synchronization\uff1a(2021, 1, 1, 0, 3, 31, 4, 1)\nLocal time after synchronization\uff1a(2023, 10, 16, 20, 16, 59, 0, 289)\n</code></pre>"},{"location":"lessons/01-get-local-time/#references","title":"References","text":"<ul> <li>MicroPython Time Documents</li> <li>Bhavesh Kakwani's blog Sync time in MicroPython using NTP - although the blog uses an ESP32, the concepts are the same on other processors such as the Raspberry Pi Pico.</li> </ul>"},{"location":"lessons/02-display-text/","title":"Display Time and Date in Text","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {} {}, {}\".format(day_name, month_name, now[2], now[0])\n\nwhile(True):\n    now = localtime()\n    # print(now)\n    LCD.fill(LCD.black)    \n    LCD.text(format_time(now), 77, 50, LCD.white)\n    LCD.text(format_date(now), 40, 80, LCD.white)\n    LCD.show()\n    sleep(1)\n</code></pre>"},{"location":"lessons/03-drawing-face/","title":"Drawing Watch Faces","text":"<p>An analog watch ususally has hands that are drawn from the center to the edge of the display.</p> <p>The lines or marks that indicate the hours are often referred to as \"hour indices\" or \"hour markers.\"</p> <p>The smaller lines that indicate the minutes are called \"minute indices\" or \"minute markers.\"</p> <p>For simple lines, we can use the <code>line(x1,y1, x2,y2,color)</code> function which draws a sinle pixel line from the starting point at (x1,y1) to the end pint at (x2,y2) using the fifth color parameter.  For monochrome clocks the color 1 is whtie and 0 is black.</p> <p>For thinker lines we can use the display.rect() function.</p> <p>Some watches have more complex hands that are composed of  multiple geometries such as triangles.</p> <p>For most modern display drivers we can use the MicroPython poly() function to draw polygons on the screen. These are part of the MicroPython framebuf function.</p> <p>Some older drivers don't yet support these functions, so we might have to craft our own functions.</p>"},{"location":"lessons/03-drawing-face/#references","title":"References","text":"<p>Instructables on Filled Circles and Triangles by TonyGo2</p>"},{"location":"lessons/04-larger-fonts/","title":"Larger Fonts","text":"<p>Many display libraries use the MicroPython framebuf standards that only provide for a single font.  This is sometimes fine for simple small displays, but it is sometimes insufficient for some projects where either a smaller or larger font is used.</p> <p>The ssd1306 driver is a good example of the default behaviour of text drawing.  Only a single font is suppied.</p> <pre><code>display.text('Hello, World!', 0, 0, 1)\ndisplay.show()\n</code></pre> <p>Some display drivers allow you to change the default font:</p> <p>LCD160 Set Font</p> <p>Font to Py Command</p> <p>Sample Font Files</p>"},{"location":"lessons/04-larger-fonts/#references","title":"References","text":"<p>Peter Hinch's Font to Python Utility -  a utility takes input a font file in ttf or otf form together with a height in pixels and outputs a Python source file containing the font as a bitmap.</p> <p>Peter Hinch's Nano GUI</p> <p>Les' Lab: Designing your own Pico fonts - Raspberry Pi Pico display fonts in MicroPython: How to design fonts for your Pi Pico project.</p>"},{"location":"lessons/05-buttons/","title":"Buttons","text":"<p>Our standard watch kit places two buttons on the breadboard. You can use these buttons to set the time.</p> <p>The buttons are connected to the lower-left corner of the pico using GPIO 14 and GPIO 15.</p> <p>Instructions on how to use these buttons are covered in our MicroPython class:</p> <p>Using Buttons in MicroPython</p> <p>We suggest using the top blue button to change the mode of operation.  As you press this you cycle through various modes of your clock or watch.  Here are some sample modes for a clock:</p> <ol> <li>Run mode</li> <li>Set current time hour</li> <li>Set current time minute</li> <li>Set alarm hour</li> <li>Set alarm minute</li> </ol> <p>After you are in a given mode, the bottom button can be used to cycle through the options. Remember to get the current value for the cycle for each mode.  So if you are adjusting the hour you have to make sure the cycle value starts at the current hour.</p>"},{"location":"lessons/05-buttons/#sample-button-mode-code","title":"Sample Button Mode Code","text":"<pre><code>ifrom utime import sleep, ticks_ms\nfrom machine import Pin\n\n# Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler\n\n# Config\nMODE_BUTTON_PIN = 14\nCYCLE_BUTTON_PIN = 15\nmode = 0 # the count of times the button has been pressed\ncycle = 0\nlast_time = 0 # the last time we pressed the button\n\nbuiltin_led = machine.Pin(25, Pin.OUT)\n# The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail\nmode_pin = machine.Pin(MODE_BUTTON_PIN, machine.Pin.IN, machine.Pin.PULL_UP)\ncycle_pin = machine.Pin(CYCLE_BUTTON_PIN, machine.Pin.IN, machine.Pin.PULL_UP)\n\n# This function gets called every time the button is pressed.  The parameter \"pin\" is not used.\ndef button_pressed_handler(pin):\n    global mode, cycle, last_time\n    new_time = ticks_ms()\n    # if it has been more that 1/5 of a second since the last event, we have a new event\n    if (new_time - last_time) &gt; 200:\n        # this should be pin.id but it does not work\n        if '14' in str(pin):\n            mode +=1\n        else:\n            cycle +=1\n        # last, we update the last time we got an ISR here\n        last_time = new_time\n\n\n# now we register the handler function when the button is pressed\nmode_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\ncycle_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\n\n# This is for only printing when a new button press count value happens\nold_mode = 0\nold_cycle = 0 \n\nwhile True:\n    # only print on change in the button_presses value\n    if mode != old_mode:\n        print('New Mode:', mode)\n        builtin_led.toggle()\n        old_mode = mode\n    if cycle != old_cycle:\n        print('New Cycle:', cycle)\n        builtin_led.toggle()\n        old_cycle = cycle\n    sleep(.1)\n</code></pre>"},{"location":"lessons/06-draw-performance/","title":"Drawing Performance","text":"<p>One of the challenges we face when updating the watch display is that refreshing an entire screen using a relatively slow SPI interface means that we need to be thoughtful about updating the displays.</p> <p>By default, many screen drivers update every pixel of the screen when the user does a <code>show()</code> operation.  For small monochrome screens this is not usually a problem.  But for larger color screens the draw times can lead to slow updates.</p> <p>Let's do a little math to see when drawing performance becomes a problem.  Remember that the human eye can's really see screen updates that occur faster than about 30 frames per second.  That is why most film movies were filled at 25 frames per second.</p> <p>To calculate the full-screen draw time we need to calculate the total number of bits we need to send and then calculate the time it takes to send these bits.  We can then check our math by looking at timestamps just before we draw and after we finish the drawing.</p> <p>Let's start out with our favorite clock screen: the 128X64 monochrome OLED screen.</p> <ol> <li>Width = 128</li> <li>Height = 64</li> <li>Bits per Pixel = 1</li> </ol> <p>Total bits = 128 * 64 * 1 = 8,192 bits = 1024 bytes</p> <p>Now we need to also know the transfer speed of our display interface.  Although there are both I2C and SPI versions of these displays, we usually prefer the SPI that should transfer data at about </p> <p>Pi Pico SPI LCD using a frame buffer to get 30fps animation - ILI9341 and ST7789 MicroPython drivers</p>"},{"location":"lessons/06-draw-performance/#sample-timer-code","title":"Sample Timer Code","text":"<p>We can calculate the time to draw the full screen by recording the number of clock ticks in microseconds before and after we do a screen update.</p> <pre><code>from utime import ticks_us\n\nstart = ticks_us()\nscreen_update()\nend = ticks_us()\nprint('Execution time in microseconds:', end - start)\n</code></pre> <p>On the OLED screen, we get a result that is around 10 milliseconds which is 100 screen updates per second.</p>"},{"location":"lessons/06-draw-performance/#references","title":"References","text":"<ol> <li>Notes on the very slow refresh rate for ST7735 </li> </ol>"},{"location":"lessons/07-drawing-digits/","title":"Drawing Clock Digits","text":""},{"location":"lessons/07-drawing-digits/#the-seven-segments-of-a-numeric-digit","title":"The Seven Segments of a Numeric Digit","text":"<p>Since the early history of computing, numeric displays used a grouping of seven individaul lights to display a single digit.  This is shown in the image below:</p> <p></p> <p>The segments are labeled \"a\" through \"g\" starting at the top and going around in a clockwise direction.  The center element is the \"g\" element.</p> <p>Technically, many displays have an 8th segment for the decimal point (DP).  To keep things simple we will just focus on the seven segments in this lesson.</p> <p>Clocks also usually have a colon that separates the hours and minutes and an AM/PM indicator for 12-hour displays.  We will be treating these and independant drawing components in this lab.  Many digital clocks have the colon flash on and off every second.</p>"},{"location":"lessons/07-drawing-digits/#the-segment-map","title":"The Segment Map","text":"<p>For any digit, is the segment on or off?</p> <p>We can create an array of the segments like this:</p> <pre><code>segmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n</code></pre>"},{"location":"lessons/07-drawing-digits/#drawing-horizontal-lines","title":"Drawing Horizontal Lines","text":"<pre><code># Horizontal segments\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): yOffset = 0 # top\n      if (i==3): yOffset = size*2 # bottom element\n      if (i==6): yOffset = size # middle\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      drawThickHorizLine(x - size, x + size, y+yOffset-size, width)\n</code></pre>"},{"location":"lessons/07-drawing-digits/#drawing-the-vertical-segments","title":"Drawing the Vertical Segments","text":"<pre><code>  # Vertical segments\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      if (i==1 or i==5):\n          startY = y-size\n          endY = y\n      if (i==2 or i==4):\n          startY = y\n          endY = y + size\n      if (i==4 or i==5): xOffset = -size\n      if (i==1 or i==2): xOffset = +size\n      xpos = x + xOffset\n      # oled.line(xpos, startY, xpos, endY, 1)\n      drawThickVertLine(startY, endY, xpos, width)```\n\n```py\n# clock digits\nimport machine\nimport utime\nimport ssd1306\nfrom utime import sleep, localtime\nled = machine.Pin(25, machine.Pin.OUT)\n\nSCL=machine.Pin(2) # SPI CLock\nSDA=machine.Pin(3) # SPI Data\nspi=machine.SPI(0, sck=SCL, mosi=SDA, baudrate=100000)\n\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\nsegmentMapping = [\n  #a, b, c, d, e, f, g\n  [1, 1, 1, 1, 1, 1, 0], # 0\n  [0, 1, 1, 0, 0, 0, 0], # 1\n  [1, 1, 0, 1, 1, 0, 1], # 2\n  [1, 1, 1, 1, 0, 0, 1], # 3\n  [0, 1, 1, 0, 0, 1, 1], # 4\n  [1, 0, 1, 1, 0, 1, 1], # 5\n  [1, 0, 1, 1, 1, 1, 1], # 6\n  [1, 1, 1, 0, 0, 0, 0], # 7\n  [1, 1, 1, 1, 1, 1, 1], # 8\n  [1, 1, 1, 1, 0, 1, 1]  # 9\n];\n\ndef drawThickHorizLine(x1, x2, y, width):\n# for portability with other MicroPython drawing libraries that use framebuf\ndef line(x1,y1,x2,y2,color):\n    oled.draw_line(x1,y1,x2,y2,color)\n\ndef fill(color):\n    oled.fill_rectangle(0, 0, WIDTH, HEIGHT, color)\n\ndef fill_rect(x,y,w,h,color):\n    oled.fill_rectangle(x, y, w, h, color)\n\ndef drawThickHorizLine(x1, x2, y, width, color):\n    fill_rect(x1, y, x2-x1, width, color)\n\ndef drawThickVertLine(y1, y2, x, width, color):\n    fill_rect(x, y1, width, y2-y1, color)\n\n# x and y are the center of the digit, size is the center to edge\ndef drawDigit(digit, x, y, size, width):\n  segmentOn = segmentMapping[digit];\n\n  # Horizontal segments\n  for i in [0, 3, 6]:\n    if (segmentOn[i]):\n      if (i==0): yOffset = 0 # top\n      if (i==3): yOffset = size*2 # bottom element\n      if (i==6): yOffset = size # middle\n      # oled.line(x - size, y+yOffset-size, x + size, y+yOffset-size, 1);\n      drawThickHorizLine(x - size, x + size, y+yOffset-size, width)\n\n  # Vertical segments\n  for i in [1, 2, 4, 5]:\n    if (segmentOn[i]) :\n      if (i==1 or i==5):\n          startY = y-size\n          endY = y\n      if (i==2 or i==4):\n          startY = y\n          endY = y + size\n      if (i==4 or i==5): xOffset = -size\n      if (i==1 or i==2): xOffset = +size\n      xpos = x + xOffset\n      # oled.line(xpos, startY, xpos, endY, 1)\n      drawThickVertLine(startY, endY, xpos, width)\n\ndef update_screen(digit_val):\n    oled.fill(0)\n    oled.text('Clock Digit Lab', 0, 0, 1)\n    dr = 10 # digit radius\n    dch = 26 # digit center hight\n    lm = 10 # left margin for all 4-digits\n    dw = 24 # digit width (2*dr + spacing between digits\n    cm = 8 # colon left margin\n    width = 3\n\n    # draw the hour digits\n    hour = localtime()[3]\n    if hour &gt; 12:\n        hour = hour - 12\n        am_pm = 'pm'\n    else:\n        am_pm = 'am'\n    if hour &lt; 10:\n        # just draw the second digit\n        drawDigit(hour, lm+dw, dch, dr, width)\n    else:\n        # we have 10, 11 or 12 so the first digit is 1\n        drawDigit(1, lm, dch, dr, width)\n        # subtract 10 from the second digit\n        drawDigit(hour-10, lm+dw, dch, dr, width)\n\n    # draw the colon\n    if localtime()[5] % 2:\n        draw_colon(lm+dw*2+cm-16,dch-5)\n\n    # draw the minutes\n    minutes = localtime()[4]\n    # value, x, y, size\n    # left minute digit after the colon\n    drawDigit(minutes // 10, lm+dw*2+cm, dch, dr, width)\n    # right minute digit\n    drawDigit(minutes % 10, lm+dw*3+cm+2, dch, dr, width)\n\n    # draw the AM/PM\n    oled.text(am_pm, lm+dw*4+cm-8, dch+3, 1)\n\n    #oled.text(timeStrFmt(), 0, 46, 1)\n    oled.text(str(localtime()[5]), 0, 54)\n    #oled.text(str(digit_val), 0, 54, 1)\n\n    oled.show()\n\ndef draw_colon(x,y):\n    oled.fill_rect(x, y, 2, 2,1)\n    oled.fill_rect(x, y+8, 2, 2,1)\n\ndef timeStrFmt():\n    hour = localtime()[3]\n    if hour &gt; 12:\n        hour = hour - 12\n        am_pm = ' pm'\n    else: am_pm = ' am'\n    # format minutes and seconds with leading zeros\n    minutes = \"{:02d}\".format(localtime()[4])\n    return str(hour) + ':' + minutes + am_pm\n\ncounter = 0\nwhile True:\n    update_screen(counter)\n    sleep(1)\n    counter += 1\n    if counter &gt; 9:\n        counter = 0\n</code></pre>"},{"location":"lessons/10-machine-info/","title":"Machine Info","text":""},{"location":"lessons/10-machine-info/#modules","title":"Modules","text":"<pre><code>help('modules')\n</code></pre>"},{"location":"lessons/10-machine-info/#clock-frequency","title":"Clock Frequency","text":"<pre><code>import machine\nprint('freq:', machine.freq())\n</code></pre>"},{"location":"lessons/10-machine-info/#operating-system","title":"Operating System","text":"<pre><code>os.uname()\n</code></pre> <pre><code>os.statvfs(path)\n</code></pre>"},{"location":"lessons/10-machine-info/#platform","title":"Platform","text":"<pre><code>platform.platform()\n</code></pre>"}]}