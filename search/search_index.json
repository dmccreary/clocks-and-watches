{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MicroPython Clocks and Watches","text":"<p>This website is dedicated to students who want to learn how to design their own digital clocks and watches using Python.  It contains instructions for finding low-cost parts and creating your own custom clock and watch displays.</p> <p>These projects have only recently been possible due to the following developments:</p> <ol> <li>The support of highly optimized drawing of complex ellipse and polygon shapes by the MicroPython runtime at version 19 was announced in early 2023.</li> <li>The ability of clocks to synchronize with centralized time services using standard WiFi networks using the $5 Raspberry Pi Pico W.</li> <li>The availability of low-cost high-contrast OLED and TFT displays for as low as $7 each.</li> </ol> <p>Our goal is to provide fun ways to teach computational thinking to a wide variety of students from 6th to 12th grade.  If you can type we have fun lesson plans from drawing simple shapes to complex clock and watch face designs.</p> <p>If you have any comments or feedback, please feel free to post these to our GitHub Issues.</p> <p>Good Luck! Dan McCreary on LinkedIn</p> <p>Demo code for the Waveshare RP2040 watch display.</p> <p>Waveshare RP2040-LCD-1.28</p> <p>Ebay Listing for $21</p>"},{"location":"contact/","title":"Contact","text":"<p>Dan McCreary on LinkedIn</p>"},{"location":"references/","title":"References","text":"<ol> <li>watchmaker</li> <li>Makerfabs GC9A01 1.28 Inch Round LCD Module </li> <li>Dronebotworksho Using GC9A01 Round LCD Modules</li> <li>DroneBot Workshop YouTube Video</li> <li>Mr. Volt YouTube Exotic Round Displays and How to Use Them  - this videos demonstrates some very new round displays up to 5 inches.  These would be ideal for robot faces but they cost up to $200 for the larger displays.</li> <li>NTP Pool Project</li> </ol>"},{"location":"kits/lilygo/","title":"LILYGO T-Display RP2040","text":"<p>LILYGO makes low-cost and high-quality microcontroller development boards that include small displays.  Although most of their boards run on C programs on ESP-32 processors, they do have one that runs MicroPython on an RP2040.  This \"kit\" is really just that development board placed on a breadboard.  The device has two buttons on it which can be used to adjust the time.</p> <p>This is a color 1.14 inch LCD display PS with 240*135 resolution. It uses the ST7789V chip that has an extreamly high quality driver created by Russ Hughes that allows for flicker-free drawing.</p> <p>I purchased mine on Ebay for $10.66 and three dollars for shipping.</p> <p>Although the display is too small for most robotic applications where the robot is on the floor and we are standing, it is a good example of how we can get both clocks and watches to look great.  My hope is that LILYGO comes out with a larger display in the future.</p> <p>Lilygo also sells their own \"wearable\" watch kits] for $35 to $45.  However, I have not purchased any of these that can be programmed with an RP2040 and MicroPython yet.  Here is a GitHub Page for the T-Watch that implies it might be on the way.  Note that using this requires extensive knowledge of the ESP32 development system.</p>"},{"location":"kits/lilygo/#getting-started","title":"Getting Started","text":"<p>To use the ST7789V driver we MUST use a custom image provide by Rull Hughes.  This is because the driver is written in low-level C code and the python driver requires it to be combiled into the firmware image.</p> <p>I downloaded the custom image here:</p> <p>T-DISPLAY RP2040 Firmware</p> <p>I then held the Boot button down while I powered up the device.</p> <p>I soldered my own header pins on the LILYGO and placed it on a breadboard.  Unfortunatly this makes it impossible to hold down the boot button with the device on the breadboard.</p>"},{"location":"kits/lilygo/#pinouts","title":"Pinouts","text":"<p>The pinouts are very different from the Raspberry Pi Pico.</p> <p></p>"},{"location":"kits/lilygo/#config-file","title":"Config File","text":"<p>This implementation puts the driver in a hidden C program, but it does have a configuration file that we must upload and place in the /lib directory.</p> <p>Here is a Link to the File for the T-Display RP2040</p> <pre><code>\"\"\"TTGO T-Display RP2040 display\"\"\"\n\nfrom machine import Pin, SPI\nfrom time import sleep\nimport st7789\n\nTFA = 40    # top free area when scrolling\nBFA = 40    # bottom free area when scrolling\n\ndef config(rotation=0, buffer_size=0, options=0):\n\n    Pin(22, Pin.OUT, value=1)\n\n    spi = SPI(0,\n        baudrate=62500000,\n        polarity=1,\n        phase=0,\n        sck=Pin(2, Pin.OUT),\n        mosi=Pin(3, Pin.OUT),\n        miso=None)\n\n    return st7789.ST7789(\n        spi,\n        135,\n        240,\n        cs=Pin(5, Pin.OUT),\n        dc=Pin(1, Pin.OUT),\n        backlight=Pin(4, Pin.OUT),\n        rotation=rotation,\n        options=options,\n        buffer_size=buffer_size)\n</code></pre>"},{"location":"kits/lilygo/#blink-the-onboard-led","title":"Blink The Onboard LED","text":"<p>This red LED is on the bottom of the board.</p> <p>Blink Timer example:</p> <pre><code>from machine import Pin, Timer\nled = Pin(25,Pin.OUT)\ntim = Timer()\ndef tick(timer):\n    global led\n    led.toggle()\ntim.init(freq=2.5, mode=Timer.PERIODIC, callback=tick)\n</code></pre>"},{"location":"kits/lilygo/#display-example","title":"Display Example","text":"<pre><code>\"\"\"\ndisplay-test.py\nFills the screen with red, green and blue\n\"\"\"\n\nfrom utime import sleep\nimport st7789\nimport tft_config\ntft = tft_config.config(1)\ntft.init()\n\nwhile True:\n    tft.fill(st7789.RED)\n    sleep(1)\n    tft.fill(st7789.GREEN)\n    sleep(1)\n    tft.fill(st7789.BLUE)\n    sleep(1)\n</code></pre>"},{"location":"kits/lilygo/#drawing-text","title":"Drawing Text","text":"<p>For this example to work, you will need to load a font library into the /lib directory.</p> <pre><code>import random\nimport utime\nimport st7789\nimport tft_config\nimport vga2_bold_16x32 as font\n\ntft = tft_config.config(1)\ntft.init()\n\n# draw text using a 16X32 font using blue text on a white background\ntft.text(\n        font,\n        'Hello World!',\n        tft.width()//2-100, # x position to start writing\n        tft.height()//2-50, # y position\n        st7789.BLUE, # font in blue\n        st7789.WHITE # background in white\n)\n</code></pre>"},{"location":"kits/lilygo/#referneces","title":"Referneces","text":"<p>Item on Aliexpress Sample GitHub repo: https://github.com/Xinyuan-LilyGO/LILYGO-T-display-RP2040</p> <p>ST7789V Submodule: Russ Hughes GitHub Repo</p> <p>Config: Sample Config File</p>"},{"location":"kits/waveshare/","title":"Waveshare RP2040","text":"<p>The Waveshare RP2040 1.28\" IPS LCD Board is a wonderful developent board with a build in RP2040 processor that currently sells for about $18.  The board has a USB-C connector, a place for a LiPo battery connection and built in Accelerometer &amp; Gyroscope.  It is a great value and a wonderful way to start to learn Python for smart watches!</p> <p>Link to Waveshare site</p>"},{"location":"kits/waveshare/#micropython-version","title":"MicroPython Version","text":"<p>To use these lessions you much use MicroPython runtime v1.19.1-854-g35524a6fd released on 2023-02-07 or later. This version supports all the native framebuf drawing libraries (ellipse and polygon)</p> <p>See the documentation here: MicroPython Framebuffer Functions</p>"},{"location":"kits/waveshare/#lessons","title":"Lessons","text":""},{"location":"kits/waveshare/#1-hello-world","title":"#1 Hello World","text":"<p>Hello world! Lesson</p>"},{"location":"kits/waveshare/#detailed-specifications","title":"Detailed Specifications","text":"Component Description USB Type-C connector USB 1.1 with device and host support ETA6096 high efficiency Lithium battery recharge manager Battery Header MX1.25 header, for 3.7V Lithium battery, allows recharging the battery and powering the board at the same time QMI8658C IMU, includes a 3-axis gyroscope and a 3-axis accelerometer 1.27mm pitch headers Adapting all GPIO and Debug pins W25Q16JVUXIQ 2MB NOR-Flash RP2040 Dual-core processor, up to 133MHz operating frequency RESET Button Reset the processor BOOT Button press it when resetting to enter download mode"},{"location":"kits/waveshare/#references","title":"References","text":"<p>Instructable by Tony Goodhew - note that this  version does not leverage the built-in drawing libraries that were made available in version 19 of the MicroPython release. See The MicroPython FrameBuf Library</p>"},{"location":"kits/waveshare/01-hello-world/","title":"Waveshare Hello World","text":""},{"location":"kits/waveshare/01-hello-world/#step-1-load-the-library","title":"Step 1: Load the Library","text":""},{"location":"kits/waveshare/01-hello-world/#step-2-load-a-test-program","title":"Step 2: Load a Test Program","text":"<pre><code>from LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \nLCD.set_bl_pwm(65535)\n\nLCD.fill(LCD.black)    \nLCD.text(\"Hello world!\", 50, 100, LCD.white)\nLCD.show()\n</code></pre> <p>You should see \"Hello world!\" in a small white font near the center of the screen.</p> <p>Challenges</p> <ol> <li>Can you move the text around the screen by changing the x and y starting position of the text?</li> <li>Can you change the background fill from black to another color?</li> <li>Can you change the color of the text from white to be another color?</li> <li>Can you change the font size? (hint: this is not easy!)</li> </ol>"},{"location":"kits/waveshare/02-color-test/","title":"Color Tests","text":"<p>Now let's try to make the background screen change colors:</p> <pre><code>from LCD_1inch28 import LCD_1inch28\nfrom utime import sleep\n\nLCD = LCD_1inch28()  \nLCD.set_bl_pwm(65535)\n\nLCD.fill(LCD.black)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.white)\nsleep(1)\nLCD.show()\nLCD.fill(LCD.red)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.green)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.blue)\nLCD.show()\nprint('done')\n</code></pre> <p>What happens when you change the color \"red\" to be \"orange\"?  You shouild see:</p> <pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 10, in &lt;module&gt;\nAttributeError: 'LCD_1inch28' object has no attribute 'orange'\n</code></pre> <p>This shows you that although the driver knows about some basic colors, (black, white, red, green and blue), it has no understanding of other colors.</p> <p>To draw these colors we need to add our own color lists.</p>"},{"location":"kits/waveshare/02-color-test/#custom-color-lists","title":"Custom Color Lists","text":"<p>In order to get more nuanced colors, we need to define them using the binary of their red, green and blue values.  With this display, we order the bits, blue, red and green.</p> <p>We can use the following binary notation to represent the colors:</p> <pre><code># binary representations of colors B=Blue bits, R=Red bits, G=Green bits\n# color = 0bBBBBBRRRRRGGGGGG\n# Cyan has all the blue and green bits on and the red bits off\ncyan = cyan = 0b1111100000111111\n</code></pre> <pre><code>from machine import Pin,I2C,SPI,PWM,ADC\nfrom time import sleep\nfrom LCD_1inch28 import LCD_1inch28, QMI8658\n\nCENTER = 120\nLCD = LCD_1inch28()\nLCD.set_bl_pwm(65535)\n\n# draw readability\nON = 1\nOFF = 0\nNO_FILL = 0\nFILL = 1\n# hex representation of colors\n# note that the bit order is blue, red, green\nblack = 0x0000\nred   = 0x07E0\ngreen = 0x001f\nblue  = 0xf800\nwhite = 0xffff\n\n# binary representations of colors\n# binary representations of colors B=5 Blue bits, R=5 Red bits, G=6 green bits\n# color = 0bBBBBBRRRRRGGGGGG\nyellow = 0b0000011111111111\norange = 0b0000001111000010\ncyan = 0b1111100000111111\nbrown = 0b0000000001000001\ngold = 0b0000001110011110\npurple = 0b1111111111000000\nmagenta = 0b0000001100011000\npink = 0b0000111111000010\nolive = 0b0000000001000010\ngray = 0b00001000010000100\nlightGreen = 0b0000100001111111\ndarkGreen  = 0b0000000000000001\n\nColorList =  (red,    green,   blue,   white,   yellow,  orange,\n              cyan, brown, gold, purple, magenta, pink, olive, gray, lightGreen, darkGreen)\nColorNames = ('red', 'green', 'blue', 'white', 'yellow', 'orange',\n              'cyan', 'brown', 'gold', 'purple', 'magenta', 'pink', 'olive', 'gray', 'lightGreen', 'darkGreen')\n\nradius = 120\nLCD.fill(LCD.black)\n\nfor i in range(0, len(ColorList)):\n    print(ColorNames[i])\n    # LCD.ellipse(CENTER, CENTER, radius, radius, ColorList[i], FILL)\n    LCD.fill(ColorList[i])\n    LCD.text(ColorNames[i], 100, 100, 1)\n    LCD.text(ColorNames[i], 100, 120, white)\n    LCD.show()\n    sleep(1)\n</code></pre> <p>Note that we are using the fill function to draw on all the pixels on the screen. We could have used the ellipse funtion to draw into the frame buffer, but the fill function is a bit easier.</p>"},{"location":"kits/waveshare/03-drawing-hands/","title":"Drawing Analog Hands","text":"<p>Drawing a analog hand requirs drawing a line from the center of the screen to a point on the edge of the circle.  The point positon varies periodically, just like the sine and cosine functions vary.  We can demonstrate this will a counter that goes from 0 to 360 degrees.</p> <p>Consider the following:</p> <ol> <li>Since the sine(0) = 0 we can use that function for the displacement from the center on the x-axis.</li> <li>Since the cosine(0) = 1, we can use that as the negative Y displacement from the center.  Remember in drawing pixels, (0,0) is in the upper-left corner of the screen.</li> </ol> <p>There is one other bit of math we need to review.  The sine() and cosine() function take in a number called <code>radians</code> which is usually a number between 0 and two times Pi.  They then return a value between 0 and 1.  We need multiple both of these values by the length of the watch hand to get to the right part of the watch face.</p> <pre><code>from utime import sleep\nfrom LCD_1inch28 import LCD_1inch28\nimport math\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nHAND_LENGTH = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nwhile True:\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    print(radians, x, y)\n    LCD.fill(LCD.black)\n    LCD.line(CENTER, CENTER, CENTER+x,CENTER+y, LCD.white)\n    LCD.show()\n    sleep(1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre> <p>You should now see a narrow white line moving much like a second hand on a watch!</p>"},{"location":"kits/waveshare/03-drawing-hands/#adding-bling-to-your-hands","title":"Adding bling to your hands","text":"<p>Although drawing a single white line is a clean efficent design, many people like to add other features such as an arrow head at the tip of the hand.  To do this we can use the poly function to draw the arrow.  To get this right, we also need to orient the arrow in the right direction.</p>"},{"location":"kits/waveshare/03-drawing-hands/#drawing-a-triangle","title":"Drawing a Triangle","text":"<p>We can use the MicroPython standard poly function to draw a triangle.  The poly </p> <p><code>`FrameBuffer.poly(x, y, coords, c[, f])</code></p> <p>This will draw an arbitrary polygon at the given x, y location using the given color (c).</p> <p>The coords must be specified as a array of integers, e.g. array('h', [x0, y0, x1, y1, ... xn, yn]).</p> <p>The optional f parameter can be set to True to fill the polygon. Otherwise just a one pixel outline is drawn.</p> <p>Let's start with drawing a basic triangle in the center of the screen like this:</p> <p>LCD.</p> <pre><code># draw a triangle on a blue background\nfrom utime import sleep\nfrom LCD_1inch28 import LCD_1inch28\nimport math\nfrom array import array\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n# draw a blue background\nLCD.fill(LCD.blue)\n\n# distance from the center to the tip of the traiangle\nd = 50\nmy_array = array('B', [CENTER-d,CENTER+d, CENTER,CENTER-d, CENTER+d,CENTER+d])\nLCD.poly(0,0, my_array, LCD.white, FILL)\nLCD.show()\nprint('done')\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/#drawing-a-triangle-rotating","title":"Drawing a Triangle Rotating","text":"<p>Now we will modify the draw triangle program to rotate each of the three points. We do this by passing the CENTER and either a positve or negative value of the x and y which varies as we move around the circle.</p> <p>Here is the line that is the most difficult to understand:</p> <pre><code>my_array = array('B', [CENTER-x,CENTER-y, CENTER+y,CENTER-x, CENTER+x,CENTER+y])\n</code></pre> <p>Note that the first point is in the lower left corner:</p> <pre><code>(CENTER-x, CENTER-y)\n</code></pre> <p>The second point is at the top of the trainagle and the X is initially zero (sine(0) = y)</p> <pre><code>(CENTER+y, CENTER-x)\n</code></pre> <p>The third point is to the lower right where we need to add to both the X and Y:</p> <pre><code>(CENTER+x, CENTER-y)\n</code></pre> <p>Here is the full program:</p> <pre><code># draw rotating triangle\nfrom utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\nfrom array import array\nimport math\nTWO_PI = 3.145175*2\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n\n# distance from the center to the tip of the traiangle\nd = 50\n\ncounter = 0\nwhile True:\n    LCD.fill(LCD.blue)\n    radians = (counter/60)*TWO_PI\n    x = int(math.cos(radians)*d)\n    y = int(math.sin(radians)*d)\n\n    # the three points of the triangle are rotated in a circle\n    my_array = array('B', [CENTER-x,CENTER-y, CENTER+y,CENTER-x, CENTER+x,CENTER+y])\n    print(CENTER-x, CENTER+y)\n\n    LCD.poly(0,0, my_array, LCD.white, FILL)\n    LCD.show()\n    sleep(.1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre> <p>You might have to stare at the code and the drawing for a while to get this figured out.</p>"},{"location":"kits/waveshare/03-drawing-hands/#create-a-draw-triangle-function","title":"Create a Draw Triangle Function","text":"<p>Now we are ready to package our triangle drawing experiment into a single function to make it easier to use.  We will pass in four parameters:</p> <ol> <li>The center of the triangle's X and Y coordinates</li> <li>The size of the triangle measured from the center to the tip</li> <li>The number of seconds on the clock (0 to 59) which we will convert to radians.  This becomes the agle of the triangle.</li> </ol> <pre><code>def drawTriangle(x, y, size, seconds):\n    radians = (seconds/60)*TWO_PI\n    # calculate the offsets\n    xo = int(math.cos(radians)*size)\n    yo = int(math.sin(radians)*size)\n    # build the array - use B if we have under 255 and h if over 255\n    arr = array('B', [x-xo,y-yo,  x+yo,y-xo,  x+xo,y+yo])\n    LCD.poly(0,0, arr, LCD.white, FILL)\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/#full-program","title":"Full Program","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\nfrom array import array\nimport math\nTWO_PI = 3.145175*2\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\nHAND_LENGTH = 100\nTRIANGLE_SIZE = 10\n\ndef drawTriangle(x, y, size, seconds):\n    radians = (seconds/60)*TWO_PI\n    # calculate the offsets\n    xo = int(math.cos(radians)*size)\n    yo = int(math.sin(radians)*size)\n    # build the array - use B if we have under 255 and h if over 255\n    arr = array('B', [x-xo,y-yo,  x+yo,y-xo,  x+xo,y+yo])\n    LCD.poly(0,0, arr, LCD.white, FILL)\n\ncounter = 0\nwhile True:\n    LCD.fill(LCD.blue)\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    LCD.line(CENTER, CENTER, CENTER+x,CENTER+y, LCD.white)\n    drawTriangle(CENTER+x, CENTER+y, TRIANGLE_SIZE, counter)\n    LCD.show()\n    sleep(.1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0```\n\n## Drawing X and Y Axis\n\n```py\n# draw thin blue axis lines through the center\n# vertical line\nLCD.line(CENTER, 0, CENTER, 2*CENTER, blue)\n# horizontal line\nLCD.line(0, CENTER, 2*CENTER, CENTER, blue)\n</code></pre>"},{"location":"lessons/01-get-local-time/","title":"Getting Local Time","text":""},{"location":"lessons/01-get-local-time/#lesson-overview","title":"Lesson Overview","text":"<p>In this lesson, we will learn how to get the local date and time from the MicroPython runtime.  We will learn the components of the list of numbers returned by these functions.</p> <p>MicroPython provides a very convenient function called <code>localtime()</code> that will get the time from the host computer that you connect to via your USB cable.  Your local computer has a clock and knows the time in the local timezone.  This information is sent to MicroPython runtime when the computer is connected to the USB cable.</p> <p>Note</p> <p>The <code>gmtime()</code> function returns the time in UTC (Coordinated Universal Time) time.  Use this if you want time stamps that are not dependent on time zone and daylight savings rules.  For example, log files should use this function.</p>"},{"location":"lessons/01-get-local-time/#sample-code","title":"Sample Code","text":"<pre><code>import time\n\nprint(time.localtime())\n</code></pre>"},{"location":"lessons/01-get-local-time/#result","title":"Result","text":"<pre><code>(2023, 2, 28, 18, 54, 7, 1, 59)\n</code></pre>"},{"location":"lessons/01-get-local-time/#format-of-the-localtime","title":"Format of the Localtime","text":"<p>The format is a \"8-tuple\" in the format (year, month, mday, hour, minute, second, weekday, yearday)</p>"},{"location":"lessons/01-get-local-time/#printing-formatted-dates","title":"Printing Formatted Dates","text":""},{"location":"lessons/01-get-local-time/#sample-code_1","title":"Sample Code","text":"<pre><code>import time\n\nnow = time.localtime()\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\nfor i in range(8):\n    print(label[i], ':', now[i])\n\nprint()\nprint(\"Date: {}/{}/{}\".format(now[1], now[2], now[0]))\nprint(\"Time: {}:{}\".format(now[3], now[4]))\n</code></pre>"},{"location":"lessons/01-get-local-time/#results","title":"Results","text":"<pre><code>year : 2023\nmonth : 2\nmday : 28\nhour : 19\nminute : 20\nsecond : 26\nweekday : 1\nyearday : 59\n\nDate: 2/28/2023\nTime: 19:20\n</code></pre>"},{"location":"lessons/01-get-local-time/#label-formatting","title":"Label Formatting","text":"<p>We can also add labels to make the date and time easier to read.</p> <pre><code>import time\n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\n\nnow = time.localtime()\n\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\nmonth_number = now[1]\nmonth_name = months[month_number]\nweekday_number = now[6]\nday_name = days[weekday_number]\nhour_number = now[3]\nif hour_number &lt; 13:\n    hour_12 = hour_number\n    am_pm = 'am'\nelse:\n    hour_12 = hour_number - 12\n    am_pm = 'pm'\n\nprint()\nprint(\"Date: {} {} {}, {}\".format(day_name, month_name, now[2], now[0]))\nprint(\"Time: {}:{} {}\".format(hour_12, now[4], am_pm))\n</code></pre>"},{"location":"lessons/01-get-local-time/#label-formatted-results","title":"Label Formatted Results","text":"<pre><code>Date: Tuesday March 28, 2023\nTime: 7:46 pm\n</code></pre>"},{"location":"lessons/01-get-local-time/#references","title":"References","text":"<ul> <li>MicroPython Time Documents</li> <li>Bhavesh Kakwani's blog Sync time in MicroPython using NTP - although the blog uses an ESP32, the concepts are the same on other processors such as the Raspberry Pi Pico.</li> </ul>"},{"location":"lessons/02-display-text/","title":"Display Time and Date in Text","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {} {}, {}\".format(day_name, month_name, now[2], now[0])\n\nwhile(True):\n    now = localtime()\n    # print(now)\n    LCD.fill(LCD.black)    \n    LCD.text(format_time(now), 77, 50, LCD.white)\n    LCD.text(format_date(now), 40, 80, LCD.white)\n    LCD.show()\n    sleep(1)\n</code></pre>"},{"location":"lessons/03-drawing-face/","title":"Drawing Watch Faces","text":"<p>We use the MicroPython poly() function to draw polygons on the screen.</p>"},{"location":"lessons/04-larger-fonts/","title":"Larger Fonts","text":"<p>Font to Py Command</p> <p>Sample Font Files</p>"},{"location":"lessons/04-larger-fonts/#references","title":"References","text":"<p>Peter Hinch's Font to Python Utility -  a utility takes input a font file in ttf or otf form together with a height in pixels and outputs a Python source file containing the font as a bitmap.</p> <p>Peter Hinch's Nano GUI</p> <p>Les' Lab: Designing your own Pico fonts - Raspberry Pi Pico display fonts in MicroPython: How to design fonts for your Pi Pico project.</p>"},{"location":"lessons/05-draw-performance/","title":"Drawing Performance","text":"<p>One of the challenges we face when updating the watch display is that refreshing an entire screen using a relatively slow SPI interface means that we need to be thoughtful about updating the displays.</p> <p>By default, many screen drivers update every pixel of the screen when the user does a <code>show()</code> operation.  For small monochrome screens this is not usually a problem.  But for larger color screens the draw times can lead to slow updates.</p> <p>Let's do a little math to see when drawing performance becomes a problem.  Remember that the human eye can's really see screen updates that occur faster than about 30 frames per second.  That is why most film movies were filled at 25 frames per second.</p> <p>To calculate the full-screen draw time we need to calculate the total number of bits we need to send and then calculate the time it takes to send these bits.  We can then check our math by looking at timestamps just before we draw and after we finish the drawing.</p> <p>Let's start out with our favorite clock screen: the 128X64 monochrome OLED screen.</p> <ol> <li>Width = 128</li> <li>Height = 64</li> <li>Bits per Pixel = 1</li> </ol> <p>Total bits = 128 * 64 * 1 = 8,192 bits = 1024 bytes</p> <p>Now we need to also know the transfer speed of our display interface.  Although there are both I2C and SPI versions of these displays, we usually prefer the SPI that should transfer data at about </p> <p>Pi Pico SPI LCD using a frame buffer to get 30fps animation - ILI9341 and ST7789 MicroPython drivers</p>"},{"location":"lessons/05-draw-performance/#sample-timer-code","title":"Sample Timer Code","text":"<p>We can calculate the time to draw the full screen by recording the number of clock ticks in microseconds before and after we do a screen update.</p> <pre><code>from utime import ticks_us\n\nstart = ticks_us()\nscreen_update()\nend = ticks_us()\nprint('Execution time in microseconds:', end - start)\n</code></pre> <p>On the OLED screen, we get a result that is around 10 milliseconds which is 100 screen updates per second.</p>"},{"location":"lessons/05-draw-performance/#references","title":"References","text":"<ol> <li>Notes on the very slow refresh rate for ST7735 </li> </ol>"},{"location":"setup/parts/","title":"Suggested Parts for a MicroPython Watch","text":"<p>These are sample links that may not work after the inventory is sold out.  Use the keywords in the product descriptions to find similar items.  The links were generated in September of 2023.</p>"},{"location":"setup/parts/#displays","title":"Displays","text":""},{"location":"setup/parts/#128-240x240-cg9a01-tft-displays","title":"1.28\" 240x240 CG9A01 TFT Displays","text":"<ol> <li>Round 1.28 inch TFT LCD Display Module RGB IPS HD 240x240 SPI GC9A01 $5.10 each when you buy 3 or more with $4 shipping.</li> <li>Amazon Teyleten Robot 1.28 Inch TFT LCD Display Module Round RGB 240 * 240 GC9A01 Driver 4 Wire SPI Interface 240x240 PCB - 3 displays for $18.99 - about $6.33 per display</li> <li>Amazon AITRIP 2PCS 1.28 Inch 1.28'' TFT LCD Display Module Round RGB 240 * 240 GC9A01 Driver 4 Wire SPI Interface 240x240 PCB - Two displays for $14.99 using the GC9A01 chip - about $7.50 per display</li> <li>Amazon D-FLIFE 3pcs 1.28 Inch TFT LCD Display Module Round RGB 240 * 240 GC9A01 Driver 4 Wire SPI Interface 240x240</li> <li>Amazon Waveshare 1.28inch Round LCD 240\u00d7240 Resolution 65K RGB IPS Display Module for Arduino Raspberry Pi Jetson Nano STM32,SPI Interface GC9A01 Driver Clear and Colorful Displaying Effect $21.00</li> <li>Ebay 1.28\" inch TFT LCD Round Display RGB 3-5V 240*240 GC9A01</li> <li>Teyleten Robot 1.28 Inch TFT LCD Display Module Round RGB 240*240 GC9A01 Driver $7.00 each</li> </ol>"},{"location":"setup/parts/#breadboards","title":"Breadboards","text":""},{"location":"setup/parts/#jumper-wires","title":"Jumper Wires","text":""},{"location":"setup/parts/#raspberry-pi-picos","title":"Raspberry Pi Picos","text":""},{"location":"setup/parts/#rp2040-watches","title":"RP2040 watches","text":"<p>1.28\" Round Watch Rp2040 Development Board TFT Display Module With Strap DIY</p>"}]}