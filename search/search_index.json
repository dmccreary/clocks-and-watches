{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MicroPython Clocks and Watches","text":"<p>Welcome to the MicroPython Clocks and Watchs website.</p>"},{"location":"#our-mission","title":"Our Mission","text":"<p>The mission of this website is to serve as a resource for teachers, mentors and students who want to learn how to us the popular MicroPython language to enable high-school students design their own digital clocks and watches using Python. It contains instructions for finding low-cost parts (under $20) and customizing your own custom clock and watch displays.</p> <p>These projects have only recently been possible due to the following developments:</p> <ol> <li>The availability of low-cost high-contrast OLED and TFT displays for as low as $7 each.  When we use the $4 Raspberry Pi Pico our classrooms can create a development systems for under $15.</li> <li>The support of highly optimized drawing of complex ellipse and polygon shapes into the Framebuf by the MicroPython runtime. This only became avaialbe in version 20 of the standard MicroPython runtime relaseed in April of 2023.  Before this every clock and watch project used custom math functions that slowed drawing times.</li> <li>The ability of WiFi enabled microcontrollers that can synchronize with centralized time services using standard WiFi networks. We use the $5 Raspberry Pi Pico W in many of our projects.</li> </ol> <p>Our goal is to provide fun ways to teach computational thinking to a wide variety of students from 6th to 12th grade.  If you can type we have fun lesson plans from drawing simple shapes to complex clock and watch face designs.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>I want to thank everyone in the MicroPython community for sharing their code.  Each of the displays require MicroPython drivers that require special features to keep drawing fast.  We could not have the high-quality lesson plans without your contributions.  If I have not referenced the cool features of your drivers, please let me know!</p>"},{"location":"#feedback-and-comments","title":"Feedback and Comments","text":"<p>If you have any comments or feedback, please feel free to post these to our GitHub Issues.  I don't check these issues every day, so please be patient and connect with others in the MicroPython community if you have urgent questions for a classroom.</p> <p>Good Luck! Dan McCreary on LinkedIn</p> <p>Demo code for the Waveshare RP2040 watch display.</p> <p>Waveshare RP2040-LCD-1.28</p> <p>Ebay Listing for $21</p>"},{"location":"about/","title":"About the Clock and Watches Project","text":""},{"location":"about/#early-arduino-beginnings","title":"Early Arduino Beginnings","text":"<p>I have been building clock and time related projects for the Twin Cities CoderDojo group since 2013.  We started building simple stopwatches using the $32 Arduino Uno microcontrollers that used seven-segment displays.  Our stopwatch lab was very popular.</p> <p>When we tried to use the graphic displays, we frequently ran into the framebuffer memory limitation of the Arduino at 2K.</p> <p>We also tried to use LCD displays to show the time and date.  These displays suffer from the fact that as the voltage of the battery drops, the screen contrast also needs to constantly be adjusted.</p> <p>These devices had to be programmed using \"C\".  Although C is popular among people with a strong computer science background, we found that most of our students wnated to learn Python.  That became the most popular computer language for students around 2017.</p> <p>It was truly difficult for us to adapt to this change back in 2018.  We tried many options to make C and Arduino more acceptable to our students.  But in 2020 we finally started to convert all our old Arduino lesson plans to use Python and MicroPython.</p>"},{"location":"about/#the-pico-revolution","title":"The Pico Revolution","text":"<p>All this changed radically when we started to use the Raspberry Pi Pico in March of 2021. The Pico had a wopping 264K or about 100x the memory of the Adruino Uno.  This allowed us to start to use low-cost OLED displays.  The $4 price point was also about 1/5th of what were were paying for the Arduino Uno.  Finally we had an easy-to-use Python environment that didn't require long compilation. The kids LOVED this new system.</p>"},{"location":"about/#the-thonny-ide","title":"The Thonny IDE","text":"<p>The Raspberry Pi Foundation also promoted (and funded) a simple Integrated Development Envionrment (IDE) called Thonny.  Thonny allows us to simply plug the board into a USB and it will \"almost\" automatilly download the right Raspberry Pi firmware to get students started quickly. We highly recommend Thonny in all our coding clubs.</p>"},{"location":"about/#syncronizing-clocks-with-the-pico-w-using-wifi","title":"Syncronizing Clocks with the Pico W using WiFi","text":"<p>Our clocks were wonderful to watch but the time had to be set manually when they were not hooked up to a USB port of a computer running Thonny.  This all changed with the Raspberry Pi Foundation released the Raspberry Pi Pico in the summer of 2022.</p> <p>The $6 Pico W board finally started to catch up with the incumbent ESP-32 series of microcontrollers that had supported WiFi.  The ESP-32 was the sucessor to the groundbreaking ESP8266 that was introduce way back in Auguest of 2014.  We have several advanced students that use these processors, but they do require you to use much more advanced toolchains.</p>"},{"location":"about/#progess-in-better-displays","title":"Progess in Better Displays","text":"<p>Unfortunatly, the under 1-inch OLED displays that were low-cost were often too small to read from more than a few feet away.  We started to purchase the 2.24\" OLEDs and we started to have lots of great feedback by these large, bright high-contrast displays.  As a rule, we now only include displays that are 2-inches or higher.</p> <p>In the past 10-years the Smart Watch industry pushed manufactures to build lower-cost displays that were over two inches and also included 16-bit color.  The key limitation with most of these displays is that they only run on slow SPI interfaces.  When the drivers required that every pixel on the screen is updated, to make even a small single pixel change we need to deal with slower drawing times and flicker.</p> <p>Now companies like Lilygo have figured out how to increase the speed of the slower SPI interfaces to provide great flicker-free draw times.  Draw times on the Liligo displays are well over our 30-frames-per second goal.</p> <p>Although we still struggle with some limitations of slower SPI, memory and buggy micropython drivers that don't take advantage of the chips that drive the displays, we are well on our way to allowing all students to customizd their own clocks and watches with MicroPython.</p>"},{"location":"about/#i2c-vs-spi","title":"I2C vs SPI","text":"<p>I should also mention that there are also displays that use I2C interfaces.  These interfaces are ideal when you don't have fast drawing requirements since they only use four wires.  These are easier for students to connect.  SPI interfaces requred up to 7-wires that make them harder for students with old breadboards where the wires come lose.  We overcame this by providing a small wire harness that uses a Dupont ribbon cable that is hot-glued on both ends to prevent the wires from coming lose.</p>"},{"location":"about/#where-we-are-today","title":"Where We Are Today","text":"<p>Althoug there are now some complete watches you can purchase that can be worn on your wrist, the Python tools are not yet easy to use.  We still lack a consitent way of manageing mutiple size fonts in the MicroPython runtime and there are many different drawing primitives in older display drivers that have not upgraded to the version 20 runtime. But I think we have made great progress over the last two years and I look forward to the day where many of our students are wearing watches that they can customize with Python!</p> <p>If you have any ideas on how we can get low-cost but fun projects into our MicroPython classrooms, please let us know!  My LinkedIn account is below:</p> <ul> <li>Dan McCreary on LinkedIn</li> </ul>"},{"location":"contact/","title":"Contact","text":"<p>Dan McCreary on LinkedIn</p>"},{"location":"references/","title":"References","text":"<ol> <li>watchmaker</li> <li>Makerfabs GC9A01 1.28 Inch Round LCD Module </li> <li>Dronebotworksho Using GC9A01 Round LCD Modules</li> <li>DroneBot Workshop YouTube Video</li> <li>Mr. Volt YouTube Exotic Round Displays and How to Use Them  - this videos demonstrates some very new round displays up to 5 inches.  These would be ideal for robot faces but they cost up to $200 for the larger displays.</li> <li>NTP Pool Project</li> </ol>"},{"location":"kits/","title":"Introduction to Clock and Watch Kits","text":""},{"location":"kits/#standard-oled","title":"Standard OLED","text":""},{"location":"kits/#raspberry-pi-and-monchorme-oled","title":"Raspberry Pi and Monchorme OLED","text":""},{"location":"kits/#raspberry-pi-w-and-monchorme-oled","title":"Raspberry Pi W and Monchorme OLED","text":""},{"location":"kits/#lilygo-rp240","title":"LilyGo RP240","text":""},{"location":"kits/gc9a01/","title":"GC9A01 Display","text":"<p>The gc9a01 is a chip that drives a 240x240 round display that is connected to a microcontroller by an SPI display.</p> <p>The current gc9a01 drivers are not compatable with the current release of framebuf in the standard MicroPython runtime.  Therefore the standard framebuf functions such as <code>ellipse()</code> and <code>poly()</code> functions do not work.  This limits the portability of many of or clock and watch example.</p> <p>The good news is that you can do some drawing operations faster and your code does not have to run the <code>show()</code> command.  Functions such as <code>line()</code> will draw directly to the display.</p> <p>To connect we need to either use a firmware version or load the driver into the /lib directory and we can then use the following code:</p> <pre><code>from machine import Pin, SPI\nimport gc9a01 as gc9a01\n\n# hardware config\nSCL_PIN = 2\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\nRST_PIN = 6\nspi = SPI(0, baudrate=60000000, sck=Pin(SCL_PIN), mosi=Pin(SDA_PIN))\n\n# initialize the display\ntft = gc9a01.GC9A01(\n    spi,\n    dc=Pin(DC_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT),\n    reset=Pin(RST_PIN, Pin.OUT),\n    rotation=0)\n\ntft.fill(gc9a01.BLACK)\n\n# x, y, width, height\n# red\ntft.fill_rect(50,  75, 50, 60, gc9a01.color565(255,0,0))\n# green\ntft.fill_rect(100, 75, 50, 60, gc9a01.color565(0,255,0))\n# blue\ntft.fill_rect(150, 75, 50, 60, gc9a01.color565(0,0,255))\n</code></pre>"},{"location":"kits/gc9a01/#references","title":"References","text":"<ol> <li>Russ Hughes - Russ provides firmware images that you can use for both the Pico and Pico W.<ol> <li>Raspberry Pi Pico</li> <li>Raspberry Pi Pico W</li> </ol> </li> </ol>"},{"location":"kits/gc9a01/01-hello-world/","title":"Hello World Test","text":"<p>We begin by carefully setting up the 7 wires that connect from the gc9a01 graphics controller to the breadboard that we have our Raspberry Pi Pico W connected.</p> <pre><code># 01-hello-world-firmware.py\n# \nfrom machine import Pin, SPI\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\ntft.init()\ntft.fill(0) # fill the screen with black\ntft.text(font, \"Hello world!\", 20, 100, gc9a01.color565(255,0,0), gc9a01.color565(0,0,255))\n</code></pre>"},{"location":"kits/gc9a01/02-display-time/","title":"Display Time and Date","text":"<p>Here is a program that will display the time and date including the day-of-the-week and the name of the month.</p> <p>We use the ``localtime()``` function to get the current time in an array of integers that looks like this:</p> <pre><code>(2023, 9, 30, 13, 18, 9, 5, 273)\n</code></pre> <p>The fields are:</p> <ol> <li>Year</li> <li>Month</li> <li>Day of Month</li> <li>Hour in 24-hour format</li> <li>Minutes</li> <li>Seconds</li> <li>Day of Week (Monday = 0, Sunday = 6)</li> <li>Day of the Year</li> </ol> <p>We could convert each of these numbers to strings and display them. However, most people like to do a bit of formatting such as displaing a 12-hour am/pm format and returning the name of the month and day of the week.  Here is the complete progam with the formatting.</p> <pre><code># 02-display-time.py\n# \nfrom machine import Pin, SPI\nfrom utime import sleep, localtime\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\n\ntft.init()\ntft.fill(0) # fill the screen with black\n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\n# I limit the month names to 5 characters max\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef day_of_week(now):\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    return day_name\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {}, {}\".format(month_name, now[2], now[0])\n\ntft.fill(0) # erase the screen to black\nwhite = gc9a01.color565(255, 255, 255)\nwhile(True):\n    # get the time from the local real-time clock\n    now = localtime()\n    print(now)    \n    tft.text(font, format_time(now), 35, 50, white)\n    tft.text(font, day_of_week(now), 50, 80, white)\n    tft.text(font, format_date(now), 5, 110, white)\n    #tft.show()\n    sleep(1)\n</code></pre>"},{"location":"kits/gc9a01/03-display-hand/","title":"Display Second Hand","text":"<p>In this lesson we will use a bit of trigonometry to display a second hand that ticks every second.</p> <pre><code>from machine import Pin, SPI\nfrom utime import sleep, localtime\nimport math\nimport gc9a01\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0\n)\ntft.init()\n\nCENTER = 120\nHAND_LENGTH = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nwhite = gc9a01.color565(255, 255, 255)\n\nwhile True:\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    print(radians, x, y)\n    tft.fill(0)\n    tft.line(CENTER, CENTER, CENTER+x,CENTER+y, white)\n    sleep(1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre>"},{"location":"kits/gc9a01/04-cycle-fonts/","title":"Cycle Through the Builtin Fonts","text":"<p>This program will cycle through the built-in fonts showing greetings in different fonts, langauges and colors.</p> <pre><code># Adapted from the hersey.py program\nfrom machine import Pin, SPI\nfrom utime import sleep, localtime\nimport random\nimport gc9a01\nimport vga1_bold_16x32 as font\n\n# this uses the standard Dupont ribbon cable spanning rows 4-9 on our breadboard\nSCK_PIN = 2 # row 4\nSDA_PIN = 3\nDC_PIN = 4\nCS_PIN = 5\n# GND is row 8\nRST_PIN = 6\n\n# define the SPI intrface\nspi = SPI(0, baudrate=60000000, sck=Pin(SCK_PIN), mosi=Pin(SDA_PIN))\ntft = gc9a01.GC9A01(spi, 240, 240, reset=Pin(RST_PIN, Pin.OUT),\n    cs=Pin(CS_PIN, Pin.OUT), dc=Pin(DC_PIN, Pin.OUT), rotation=0)\n\n# Load several frozen fonts from flash\n\nimport greeks\nimport italicc\nimport italiccs\nimport meteo\nimport romanc\nimport romancs\nimport romand\nimport romanp\nimport romans\nimport scriptc\nimport scripts\n\n\ndef cycle(p):\n'''\n    return the next item in a list\n    '''\n    try:\n        len(p)\n    except TypeError:\n        cache = []\n        for i in p:\n            yield i\n            cache.append(i)\n        p = cache\n    while p:\n        yield from p\n\n\nCOLORS = cycle([0xe000, 0xece0, 0xe7e0, 0x5e0, 0x00d3, 0x7030])\n\nFONTS = cycle([\n    greeks, italicc, italiccs, meteo, romanc, romancs,\n    romand, romanp, romans, scriptc, scripts])\n\nGREETINGS = cycle([\n    \"bonjour\", \"buenas noches\", \"buenos dias\",\n    \"good day\", \"good morning\", \"hey\",\n    \"hi-ya\", \"hi\", \"how are you\", \"how goes it\",\n    \"howdy-do\", \"howdy\", \"shalom\", \"welcome\",\n    \"what's happening\", \"what's up\"])\n\ntft.init()\nrow = 120\n\nwhile True:\n    color = next(COLORS)\n    tft.fill(gc9a01.BLACK)\n    tft.draw(next(FONTS), next(GREETINGS), 0, row, color)\n    sleep(0.5)\n</code></pre>"},{"location":"kits/gc9a01/04-cycle-fonts/#references","title":"References","text":"<ol> <li>Russ Hughes Example</li> </ol>"},{"location":"kits/lilygo/","title":"LILYGO T-Display RP2040","text":"<p>LILYGO makes low-cost and high-quality microcontroller development boards that include small displays.  Although most of their boards run on C programs on ESP-32 processors, they do have one that runs MicroPython on an RP2040.  This \"kit\" is really just that development board placed on a breadboard.  The device has two buttons on it which can be used to adjust the time.</p> <p>This is a color 1.14 inch LCD display PS with 240*135 resolution. It uses the ST7789V chip that has an extreamly high quality driver created by Russ Hughes that allows for flicker-free drawing.</p> <p>I purchased mine on Ebay for $10.66 and three dollars for shipping.</p> <p>Although the display is too small for most robotic applications where the robot is on the floor and we are standing, it is a good example of how we can get both clocks and watches to look great.  My hope is that LILYGO comes out with a larger display in the future.</p> <p>Lilygo also sells their own \"wearable\" watch kits] for $35 to $45.  However, I have not purchased any of these that can be programmed with an RP2040 and MicroPython yet.  Here is a GitHub Page for the T-Watch that implies it might be on the way.  Note that using this requires extensive knowledge of the ESP32 development system.</p>"},{"location":"kits/lilygo/#getting-started","title":"Getting Started","text":"<p>To use the ST7789V driver we MUST use a custom image provide by Rull Hughes.  This is because the driver is written in low-level C code and the python driver requires it to be combiled into the firmware image.</p> <p>I downloaded the custom image here:</p> <p>T-DISPLAY RP2040 Firmware</p> <p>I then held the Boot button down while I powered up the device.</p> <p>I soldered my own header pins on the LILYGO and placed it on a breadboard.  Unfortunatly this makes it impossible to hold down the boot button with the device on the breadboard.</p>"},{"location":"kits/lilygo/#pinouts","title":"Pinouts","text":"<p>The pinouts are very different from the Raspberry Pi Pico.</p> <p></p>"},{"location":"kits/lilygo/#config-file","title":"Config File","text":"<p>This implementation puts the driver in a hidden C program, but it does have a configuration file that we must upload and place in the /lib directory.</p> <p>Here is a Link to the File for the T-Display RP2040</p> <pre><code>\"\"\"TTGO T-Display RP2040 display\"\"\"\n\nfrom machine import Pin, SPI\nfrom time import sleep\nimport st7789\n\nTFA = 40    # top free area when scrolling\nBFA = 40    # bottom free area when scrolling\n\ndef config(rotation=0, buffer_size=0, options=0):\n\n    Pin(22, Pin.OUT, value=1)\n\n    spi = SPI(0,\n        baudrate=62500000,\n        polarity=1,\n        phase=0,\n        sck=Pin(2, Pin.OUT),\n        mosi=Pin(3, Pin.OUT),\n        miso=None)\n\n    return st7789.ST7789(\n        spi,\n        135,\n        240,\n        cs=Pin(5, Pin.OUT),\n        dc=Pin(1, Pin.OUT),\n        backlight=Pin(4, Pin.OUT),\n        rotation=rotation,\n        options=options,\n        buffer_size=buffer_size)\n</code></pre>"},{"location":"kits/lilygo/#blink-the-onboard-led","title":"Blink The Onboard LED","text":"<p>This red LED is on the bottom of the board.</p> <p>Blink Timer example:</p> <pre><code>from machine import Pin, Timer\nled = Pin(25,Pin.OUT)\ntim = Timer()\ndef tick(timer):\n    global led\n    led.toggle()\ntim.init(freq=2.5, mode=Timer.PERIODIC, callback=tick)\n</code></pre>"},{"location":"kits/lilygo/#display-example","title":"Display Example","text":"<pre><code>\"\"\"\ndisplay-test.py\nFills the screen with red, green and blue\n\"\"\"\n\nfrom utime import sleep\nimport st7789\nimport tft_config\ntft = tft_config.config(1)\ntft.init()\n\nwhile True:\n    tft.fill(st7789.RED)\n    sleep(1)\n    tft.fill(st7789.GREEN)\n    sleep(1)\n    tft.fill(st7789.BLUE)\n    sleep(1)\n</code></pre>"},{"location":"kits/lilygo/#drawing-text","title":"Drawing Text","text":"<p>For this example to work, you will need to load a font library into the /lib directory.</p> <pre><code>import random\nimport utime\nimport st7789\nimport tft_config\nimport vga2_bold_16x32 as font\n\ntft = tft_config.config(1)\ntft.init()\n\n# draw text using a 16X32 font using blue text on a white background\ntft.text(\n        font,\n        'Hello World!',\n        tft.width()//2-100, # x position to start writing\n        tft.height()//2-50, # y position\n        st7789.BLUE, # font in blue\n        st7789.WHITE # background in white\n)\n</code></pre>"},{"location":"kits/lilygo/#referneces","title":"Referneces","text":"<p>Item on Aliexpress Sample GitHub repo: https://github.com/Xinyuan-LilyGO/LILYGO-T-display-RP2040</p> <p>ST7789V Submodule: Russ Hughes GitHub Repo</p> <p>Config: Sample Config File</p>"},{"location":"kits/waveshare/","title":"Waveshare RP2040","text":"<p>The Waveshare RP2040 1.28\" IPS LCD Board is a wonderful developent board with a build in RP2040 processor that currently sells for about $18.  The board has a USB-C connector, a place for a LiPo battery connection and built in Accelerometer &amp; Gyroscope.  It is a great value and a wonderful way to start to learn Python for smart watches!</p> <ol> <li>Waveshare SKU: 22668</li> <li>Waveshare Part Number: RP2040-LCD-1.28</li> <li>Link to Waveshare site</li> </ol> <p>Note that this watch does not have a real-time clock and has no ability to connect to time syhronization using WiFi. However, it is an ideal development tool for learning to program watch displays and integrate sensors.</p>"},{"location":"kits/waveshare/#micropython-version","title":"MicroPython Version","text":"<p>To use these lessions you much use MicroPython runtime v1.19.1-854-g35524a6fd released on 2023-02-07 or later. This version supports all the native framebuf drawing libraries (ellipse and polygon)</p> <p>See the documentation here: MicroPython Framebuffer Functions</p>"},{"location":"kits/waveshare/#lessons","title":"Lessons","text":""},{"location":"kits/waveshare/#1-hello-world","title":"#1 Hello World","text":"<ol> <li>Hello world! Lesson</li> <li>Color Lab</li> <li>Drawing Analog Hands</li> </ol>"},{"location":"kits/waveshare/#detailed-components","title":"Detailed Components","text":"Component Description USB Type-C connector USB 1.1 with device and host support ETA6096 high efficiency Lithium battery recharge manager Battery Header MX1.25 header, for 3.7V Lithium battery, allows recharging the battery and powering the board at the same time QMI8658C IMU, includes a 3-axis gyroscope and a 3-axis accelerometer 1.27mm pitch headers Adapting all GPIO and Debug pins W25Q16JVUXIQ 2MB NOR-Flash RP2040 Dual-core processor, up to 133MHz operating frequency RESET Button Reset the processor BOOT Button press it when resetting to enter download mode"},{"location":"kits/waveshare/#references","title":"References","text":"<p>wiki</p> <p>Instructable by Tony Goodhew - note that this  version does not leverage the built-in drawing libraries that were made available in version 19 of the MicroPython release. See The MicroPython FrameBuf Library</p> <p>Github Gist by Alasdair Allan</p>"},{"location":"kits/waveshare/01-hello-world/","title":"Waveshare Hello World","text":""},{"location":"kits/waveshare/01-hello-world/#step-1-load-the-library","title":"Step 1: Load the Library","text":""},{"location":"kits/waveshare/01-hello-world/#step-2-load-a-test-program","title":"Step 2: Load a Test Program","text":"<pre><code>from LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \nLCD.set_bl_pwm(65535)\n\nLCD.fill(LCD.black)    \nLCD.text(\"Hello world!\", 50, 100, LCD.white)\nLCD.show()\n</code></pre> <p>You should see \"Hello world!\" in a small white font near the center of the screen.</p> <p>Challenges</p> <ol> <li>Can you move the text around the screen by changing the x and y starting position of the text?</li> <li>Can you change the background fill from black to another color?</li> <li>Can you change the color of the text from white to be another color?</li> <li>Can you change the font size? (hint: this is not easy!)</li> </ol>"},{"location":"kits/waveshare/02-color-test/","title":"Color Tests","text":"<p>Now let's try to make the background screen change colors:</p> <pre><code>from LCD_1inch28 import LCD_1inch28\nfrom utime import sleep\n\nLCD = LCD_1inch28()  \nLCD.set_bl_pwm(65535)\n\nLCD.fill(LCD.black)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.white)\nsleep(1)\nLCD.show()\nLCD.fill(LCD.red)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.green)\nLCD.show()\nsleep(1)\nLCD.fill(LCD.blue)\nLCD.show()\nprint('done')\n</code></pre> <p>What happens when you change the color \"red\" to be \"orange\"?  You shouild see:</p> <pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 10, in &lt;module&gt;\nAttributeError: 'LCD_1inch28' object has no attribute 'orange'\n</code></pre> <p>This shows you that although the driver knows about some basic colors, (black, white, red, green and blue), it has no understanding of other colors.</p> <p>To draw these colors we need to add our own color lists.</p>"},{"location":"kits/waveshare/02-color-test/#custom-color-lists","title":"Custom Color Lists","text":"<p>In order to get more nuanced colors, we need to define them using the binary of their red, green and blue values.  With this display, we order the bits, blue, red and green.</p> <p>We can use the following binary notation to represent the colors:</p> <pre><code># binary representations of colors B=Blue bits, R=Red bits, G=Green bits\n# color = 0bBBBBBRRRRRGGGGGG\n# Cyan has all the blue and green bits on and the red bits off\ncyan = cyan = 0b1111100000111111\n</code></pre> <pre><code>from machine import Pin,I2C,SPI,PWM,ADC\nfrom time import sleep\nfrom LCD_1inch28 import LCD_1inch28, QMI8658\n\nCENTER = 120\nLCD = LCD_1inch28()\nLCD.set_bl_pwm(65535)\n\n# draw readability\nON = 1\nOFF = 0\nNO_FILL = 0\nFILL = 1\n# hex representation of colors\n# note that the bit order is blue, red, green\nblack = 0x0000\nred   = 0x07E0\ngreen = 0x001f\nblue  = 0xf800\nwhite = 0xffff\n\n# binary representations of colors\n# binary representations of colors B=5 Blue bits, R=5 Red bits, G=6 green bits\n# color = 0bBBBBBRRRRRGGGGGG\nyellow = 0b0000011111111111\norange = 0b0000001111000010\ncyan = 0b1111100000111111\nbrown = 0b0000000001000001\ngold = 0b0000001110011110\npurple = 0b1111111111000000\nmagenta = 0b0000001100011000\npink = 0b0000111111000010\nolive = 0b0000000001000010\ngray = 0b00001000010000100\nlightGreen = 0b0000100001111111\ndarkGreen  = 0b0000000000000001\n\nColorList =  (red,    green,   blue,   white,   yellow,  orange,\n              cyan, brown, gold, purple, magenta, pink, olive, gray, lightGreen, darkGreen)\nColorNames = ('red', 'green', 'blue', 'white', 'yellow', 'orange',\n              'cyan', 'brown', 'gold', 'purple', 'magenta', 'pink', 'olive', 'gray', 'lightGreen', 'darkGreen')\n\nradius = 120\nLCD.fill(LCD.black)\n\nfor i in range(0, len(ColorList)):\n    print(ColorNames[i])\n    # LCD.ellipse(CENTER, CENTER, radius, radius, ColorList[i], FILL)\n    LCD.fill(ColorList[i])\n    LCD.text(ColorNames[i], 100, 100, 1)\n    LCD.text(ColorNames[i], 100, 120, white)\n    LCD.show()\n    sleep(1)\n</code></pre> <p>Note that we are using the fill function to draw on all the pixels on the screen. We could have used the ellipse funtion to draw into the frame buffer, but the fill function is a bit easier.</p>"},{"location":"kits/waveshare/02-color-test/#converting-rgb888-to-brg556","title":"Converting RGB888 to BRG556","text":"<pre><code>def convert_color_RGB888_RGB565(R,G,B): # Convert RGB888 to RGB565\n    return (((G&amp;0b00011100)&lt;&lt;3) +((B&amp;0b11111000)&gt;&gt;3)&lt;&lt;8) + (R&amp;0b11111000)+((G&amp;0b11100000)&gt;&gt;5)\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/","title":"Drawing Analog Hands","text":"<p>Drawing a analog hand requirs drawing a line from the center of the screen to a point on the edge of the circle.  The point positon varies periodically, just like the sine and cosine functions vary.  We can demonstrate this will a counter that goes from 0 to 360 degrees.</p> <p>Consider the following:</p> <ol> <li>Since the sine(0) = 0 we can use that function for the displacement from the center on the x-axis.</li> <li>Since the cosine(0) = 1, we can use that as the negative Y displacement from the center.  Remember in drawing pixels, (0,0) is in the upper-left corner of the screen.</li> </ol> <p>There is one other bit of math we need to review.  The sine() and cosine() function take in a number called <code>radians</code> which is usually a number between 0 and two times Pi.  They then return a value between 0 and 1.  We need multiple both of these values by the length of the watch hand to get to the right part of the watch face.</p> <pre><code>from utime import sleep\nfrom LCD_1inch28 import LCD_1inch28\nimport math\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nHAND_LENGTH = 100\n\n# our counter will range from 0 to 59\n# A full circle is 2*Pi radians\nTWO_PI = 3.145175*2\ncounter = 0\nwhile True:\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    print(radians, x, y)\n    LCD.fill(LCD.black)\n    LCD.line(CENTER, CENTER, CENTER+x,CENTER+y, LCD.white)\n    LCD.show()\n    sleep(1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre> <p>You should now see a narrow white line moving much like a second hand on a watch!</p>"},{"location":"kits/waveshare/03-drawing-hands/#adding-bling-to-your-hands","title":"Adding bling to your hands","text":"<p>Although drawing a single white line is a clean efficent design, many people like to add other features such as an arrow head at the tip of the hand.  To do this we can use the poly function to draw the arrow.  To get this right, we also need to orient the arrow in the right direction.</p>"},{"location":"kits/waveshare/03-drawing-hands/#drawing-a-triangle","title":"Drawing a Triangle","text":"<p>We can use the MicroPython standard poly function to draw a triangle.  The poly </p> <p><code>`FrameBuffer.poly(x, y, coords, c[, f])</code></p> <p>This will draw an arbitrary polygon at the given x, y location using the given color (c).</p> <p>The coords must be specified as a array of integers, e.g. array('h', [x0, y0, x1, y1, ... xn, yn]).</p> <p>The optional f parameter can be set to True to fill the polygon. Otherwise just a one pixel outline is drawn.</p> <p>Let's start with drawing a basic triangle in the center of the screen like this:</p> <p>LCD.</p> <pre><code># draw a triangle on a blue background\nfrom utime import sleep\nfrom LCD_1inch28 import LCD_1inch28\nimport math\nfrom array import array\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n# draw a blue background\nLCD.fill(LCD.blue)\n\n# distance from the center to the tip of the traiangle\nd = 50\nmy_array = array('B', [CENTER-d,CENTER+d, CENTER,CENTER-d, CENTER+d,CENTER+d])\nLCD.poly(0,0, my_array, LCD.white, FILL)\nLCD.show()\nprint('done')\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/#drawing-a-triangle-rotating","title":"Drawing a Triangle Rotating","text":"<p>Now we will modify the draw triangle program to rotate each of the three points. We do this by passing the CENTER and either a positve or negative value of the x and y which varies as we move around the circle.</p> <p>Here is the line that is the most difficult to understand:</p> <pre><code>my_array = array('B', [CENTER-x,CENTER-y, CENTER+y,CENTER-x, CENTER+x,CENTER+y])\n</code></pre> <p>Note that the first point is in the lower left corner:</p> <pre><code>(CENTER-x, CENTER-y)\n</code></pre> <p>The second point is at the top of the trainagle and the X is initially zero (sine(0) = y)</p> <pre><code>(CENTER+y, CENTER-x)\n</code></pre> <p>The third point is to the lower right where we need to add to both the X and Y:</p> <pre><code>(CENTER+x, CENTER-y)\n</code></pre> <p>Here is the full program:</p> <pre><code># draw rotating triangle\nfrom utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\nfrom array import array\nimport math\nTWO_PI = 3.145175*2\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n\n# distance from the center to the tip of the traiangle\nd = 50\n\ncounter = 0\nwhile True:\n    LCD.fill(LCD.blue)\n    radians = (counter/60)*TWO_PI\n    x = int(math.cos(radians)*d)\n    y = int(math.sin(radians)*d)\n\n    # the three points of the triangle are rotated in a circle\n    my_array = array('B', [CENTER-x,CENTER-y, CENTER+y,CENTER-x, CENTER+x,CENTER+y])\n    print(CENTER-x, CENTER+y)\n\n    LCD.poly(0,0, my_array, LCD.white, FILL)\n    LCD.show()\n    sleep(.1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0\n</code></pre> <p>You might have to stare at the code and the drawing for a while to get this figured out.</p>"},{"location":"kits/waveshare/03-drawing-hands/#create-a-draw-triangle-function","title":"Create a Draw Triangle Function","text":"<p>Now we are ready to package our triangle drawing experiment into a single function to make it easier to use.  We will pass in four parameters:</p> <ol> <li>The center of the triangle's X and Y coordinates</li> <li>The size of the triangle measured from the center to the tip</li> <li>The number of seconds on the clock (0 to 59) which we will convert to radians.  This becomes the agle of the triangle.</li> </ol> <pre><code>def drawTriangle(x, y, size, seconds):\n    radians = (seconds/60)*TWO_PI\n    # calculate the offsets\n    xo = int(math.cos(radians)*size)\n    yo = int(math.sin(radians)*size)\n    # build the array - use B if we have under 255 and h if over 255\n    arr = array('B', [x-xo,y-yo,  x+yo,y-xo,  x+xo,y+yo])\n    LCD.poly(0,0, arr, LCD.white, FILL)\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/#full-program","title":"Full Program","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\nfrom array import array\nimport math\nTWO_PI = 3.145175*2\n\nLCD = LCD_1inch28()\n\nCENTER = 120\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\nHAND_LENGTH = 100\nTRIANGLE_SIZE = 10\n\ndef drawTriangle(x, y, size, seconds):\n    radians = (seconds/60)*TWO_PI\n    # calculate the offsets\n    xo = int(math.cos(radians)*size)\n    yo = int(math.sin(radians)*size)\n    # build the array - use B if we have under 255 and h if over 255\n    arr = array('B', [x-xo,y-yo,  x+yo,y-xo,  x+xo,y+yo])\n    LCD.poly(0,0, arr, LCD.white, FILL)\n\ncounter = 0\nwhile True:\n    LCD.fill(LCD.blue)\n    radians = (counter/60)*TWO_PI\n    x = int(math.sin(radians)*HAND_LENGTH)\n    y = -int(math.cos(radians)*HAND_LENGTH)\n    LCD.line(CENTER, CENTER, CENTER+x,CENTER+y, LCD.white)\n    drawTriangle(CENTER+x, CENTER+y, TRIANGLE_SIZE, counter)\n    LCD.show()\n    sleep(.1)\n    counter += 1\n    # if we are at 60 we start over\n    if counter &gt; 59:\n        counter = 0```\n</code></pre>"},{"location":"kits/waveshare/03-drawing-hands/#drawing-x-and-y-axis","title":"Drawing X and Y Axis","text":"<pre><code># draw thin blue axis lines through the center\n# vertical line\nLCD.line(CENTER, 0, CENTER, 2*CENTER, blue)\n# horizontal line\nLCD.line(0, CENTER, 2*CENTER, CENTER, blue)\n</code></pre>"},{"location":"kits/waveshare/04-5x8-font/","title":"5x8 Font Test","text":"<p>We can create custom functions for drawing larger fonts.  Here we have a byte array of 5X8 fonts.  The function <code>character()</code> draws individual characters one at a time.</p> <pre><code>from LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\n# Standard ASCII 5x8 font\n# https://gist.github.com/tdicola/229b3eeddc12d58fb0bc724a9062aa05\nFONT_HEIGHT = 8\nFONT_WIDTH = 5\nFONT = bytes([\n    0x00, 0x00, 0x00, 0x00, 0x00, # &lt;space&gt;\n    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,\n    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,\n    0x1C, 0x3E, 0x7C, 0x3E, 0x1C,\n    0x18, 0x3C, 0x7E, 0x3C, 0x18,\n    0x1C, 0x57, 0x7D, 0x57, 0x1C,\n    0x1C, 0x5E, 0x7F, 0x5E, 0x1C,\n    0x00, 0x18, 0x3C, 0x18, 0x00,\n    0xFF, 0xE7, 0xC3, 0xE7, 0xFF,\n    0x00, 0x18, 0x24, 0x18, 0x00,\n    0xFF, 0xE7, 0xDB, 0xE7, 0xFF,\n    0x30, 0x48, 0x3A, 0x06, 0x0E,\n    0x26, 0x29, 0x79, 0x29, 0x26,\n    0x40, 0x7F, 0x05, 0x05, 0x07,\n    0x40, 0x7F, 0x05, 0x25, 0x3F,\n    0x5A, 0x3C, 0xE7, 0x3C, 0x5A,\n    0x7F, 0x3E, 0x1C, 0x1C, 0x08,\n    0x08, 0x1C, 0x1C, 0x3E, 0x7F,\n    0x14, 0x22, 0x7F, 0x22, 0x14,\n    0x5F, 0x5F, 0x00, 0x5F, 0x5F,\n    0x06, 0x09, 0x7F, 0x01, 0x7F,\n    0x00, 0x66, 0x89, 0x95, 0x6A,\n    0x60, 0x60, 0x60, 0x60, 0x60,\n    0x94, 0xA2, 0xFF, 0xA2, 0x94,\n    0x08, 0x04, 0x7E, 0x04, 0x08, # UP\n    0x10, 0x20, 0x7E, 0x20, 0x10, # Down\n    0x08, 0x08, 0x2A, 0x1C, 0x08, # Right\n    0x08, 0x1C, 0x2A, 0x08, 0x08, # Left\n    0x1E, 0x10, 0x10, 0x10, 0x10,\n    0x0C, 0x1E, 0x0C, 0x1E, 0x0C,\n    0x30, 0x38, 0x3E, 0x38, 0x30,\n    0x06, 0x0E, 0x3E, 0x0E, 0x06,\n    0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x5F, 0x00, 0x00,\n    0x00, 0x07, 0x00, 0x07, 0x00,\n    0x14, 0x7F, 0x14, 0x7F, 0x14,\n    0x24, 0x2A, 0x7F, 0x2A, 0x12,\n    0x23, 0x13, 0x08, 0x64, 0x62,\n    0x36, 0x49, 0x56, 0x20, 0x50,\n    0x00, 0x08, 0x07, 0x03, 0x00,\n    0x00, 0x1C, 0x22, 0x41, 0x00,\n    0x00, 0x41, 0x22, 0x1C, 0x00,\n    0x2A, 0x1C, 0x7F, 0x1C, 0x2A,\n    0x08, 0x08, 0x3E, 0x08, 0x08,\n    0x00, 0x80, 0x70, 0x30, 0x00,\n    0x08, 0x08, 0x08, 0x08, 0x08,\n    0x00, 0x00, 0x60, 0x60, 0x00,\n    0x20, 0x10, 0x08, 0x04, 0x02,\n    0x3E, 0x51, 0x49, 0x45, 0x3E,\n    0x00, 0x42, 0x7F, 0x40, 0x00,\n    0x72, 0x49, 0x49, 0x49, 0x46,\n    0x21, 0x41, 0x49, 0x4D, 0x33,\n    0x18, 0x14, 0x12, 0x7F, 0x10,\n    0x27, 0x45, 0x45, 0x45, 0x39,\n    0x3C, 0x4A, 0x49, 0x49, 0x31,\n    0x41, 0x21, 0x11, 0x09, 0x07,\n    0x36, 0x49, 0x49, 0x49, 0x36,\n    0x46, 0x49, 0x49, 0x29, 0x1E,\n    0x00, 0x00, 0x14, 0x00, 0x00,\n    0x00, 0x40, 0x34, 0x00, 0x00,\n    0x00, 0x08, 0x14, 0x22, 0x41,\n    0x14, 0x14, 0x14, 0x14, 0x14,\n    0x00, 0x41, 0x22, 0x14, 0x08,\n    0x02, 0x01, 0x59, 0x09, 0x06,\n    0x3E, 0x41, 0x5D, 0x59, 0x4E,\n    0x7C, 0x12, 0x11, 0x12, 0x7C, # A\n    0x7F, 0x49, 0x49, 0x49, 0x36,\n    0x3E, 0x41, 0x41, 0x41, 0x22,\n    0x7F, 0x41, 0x41, 0x41, 0x3E,\n    0x7F, 0x49, 0x49, 0x49, 0x41,\n    0x7F, 0x09, 0x09, 0x09, 0x01,\n    0x3E, 0x41, 0x41, 0x51, 0x73,\n    0x7F, 0x08, 0x08, 0x08, 0x7F,\n    0x00, 0x41, 0x7F, 0x41, 0x00,\n    0x20, 0x40, 0x41, 0x3F, 0x01,\n    0x7F, 0x08, 0x14, 0x22, 0x41,\n    0x7F, 0x40, 0x40, 0x40, 0x40,\n    0x7F, 0x02, 0x1C, 0x02, 0x7F,\n    0x7F, 0x04, 0x08, 0x10, 0x7F,\n    0x3E, 0x41, 0x41, 0x41, 0x3E,\n    0x7F, 0x09, 0x09, 0x09, 0x06,\n    0x3E, 0x41, 0x51, 0x21, 0x5E,\n    0x7F, 0x09, 0x19, 0x29, 0x46,\n    0x26, 0x49, 0x49, 0x49, 0x32,\n    0x03, 0x01, 0x7F, 0x01, 0x03,\n    0x3F, 0x40, 0x40, 0x40, 0x3F,\n    0x1F, 0x20, 0x40, 0x20, 0x1F,\n    0x3F, 0x40, 0x38, 0x40, 0x3F,\n    0x63, 0x14, 0x08, 0x14, 0x63,\n    0x03, 0x04, 0x78, 0x04, 0x03,\n    0x61, 0x59, 0x49, 0x4D, 0x43,\n    0x00, 0x7F, 0x41, 0x41, 0x41,\n    0x02, 0x04, 0x08, 0x10, 0x20,\n    0x00, 0x41, 0x41, 0x41, 0x7F,\n    0x04, 0x02, 0x01, 0x02, 0x04,\n    0x40, 0x40, 0x40, 0x40, 0x40,\n    0x00, 0x03, 0x07, 0x08, 0x00,\n    0x20, 0x54, 0x54, 0x78, 0x40,\n    0x7F, 0x28, 0x44, 0x44, 0x38,\n    0x38, 0x44, 0x44, 0x44, 0x28,\n    0x38, 0x44, 0x44, 0x28, 0x7F,\n    0x38, 0x54, 0x54, 0x54, 0x18,\n    0x00, 0x08, 0x7E, 0x09, 0x02,\n    0x18, 0xA4, 0xA4, 0x9C, 0x78,\n    0x7F, 0x08, 0x04, 0x04, 0x78,\n    0x00, 0x44, 0x7D, 0x40, 0x00,\n    0x20, 0x40, 0x40, 0x3D, 0x00,\n    0x7F, 0x10, 0x28, 0x44, 0x00,\n    0x00, 0x41, 0x7F, 0x40, 0x00,\n    0x7C, 0x04, 0x78, 0x04, 0x78,\n    0x7C, 0x08, 0x04, 0x04, 0x78,\n    0x38, 0x44, 0x44, 0x44, 0x38,\n    0xFC, 0x18, 0x24, 0x24, 0x18,\n    0x18, 0x24, 0x24, 0x18, 0xFC,\n    0x7C, 0x08, 0x04, 0x04, 0x08,\n    0x48, 0x54, 0x54, 0x54, 0x24,\n    0x04, 0x04, 0x3F, 0x44, 0x24,\n    0x3C, 0x40, 0x40, 0x20, 0x7C,\n    0x1C, 0x20, 0x40, 0x20, 0x1C,\n    0x3C, 0x40, 0x30, 0x40, 0x3C,\n    0x44, 0x28, 0x10, 0x28, 0x44,\n    0x4C, 0x90, 0x90, 0x90, 0x7C,\n    0x44, 0x64, 0x54, 0x4C, 0x44,\n    0x00, 0x08, 0x36, 0x41, 0x00,\n    0x00, 0x00, 0x77, 0x00, 0x00,\n    0x00, 0x41, 0x36, 0x08, 0x00,\n    0x02, 0x01, 0x02, 0x04, 0x02,\n    0x3C, 0x26, 0x23, 0x26, 0x3C,\n    0x1E, 0xA1, 0xA1, 0x61, 0x12, # Extension starts here\n    0x3A, 0x40, 0x40, 0x20, 0x7A,\n    0x38, 0x54, 0x54, 0x55, 0x59,\n    0x21, 0x55, 0x55, 0x79, 0x41,\n    0x22, 0x54, 0x54, 0x78, 0x42, # a-umlaut\n    0x21, 0x55, 0x54, 0x78, 0x40,\n    0x20, 0x54, 0x55, 0x79, 0x40,\n    0x0C, 0x1E, 0x52, 0x72, 0x12,\n    0x39, 0x55, 0x55, 0x55, 0x59,\n    0x39, 0x54, 0x54, 0x54, 0x59,\n    0x39, 0x55, 0x54, 0x54, 0x58,\n    0x00, 0x00, 0x45, 0x7C, 0x41,\n    0x00, 0x02, 0x45, 0x7D, 0x42,\n    0x00, 0x01, 0x45, 0x7C, 0x40,\n    0x7D, 0x12, 0x11, 0x12, 0x7D, # A-umlaut\n    0xF0, 0x28, 0x25, 0x28, 0xF0,\n    0x7C, 0x54, 0x55, 0x45, 0x00,\n    0x20, 0x54, 0x54, 0x7C, 0x54,\n    0x7C, 0x0A, 0x09, 0x7F, 0x49,\n    0x32, 0x49, 0x49, 0x49, 0x32,\n    0x3A, 0x44, 0x44, 0x44, 0x3A, # o-umlaut\n    0x32, 0x4A, 0x48, 0x48, 0x30,\n    0x3A, 0x41, 0x41, 0x21, 0x7A,\n    0x3A, 0x42, 0x40, 0x20, 0x78,\n    0x00, 0x9D, 0xA0, 0xA0, 0x7D,\n    0x3D, 0x42, 0x42, 0x42, 0x3D, # O-umlaut\n    0x3D, 0x40, 0x40, 0x40, 0x3D,\n    0x3C, 0x24, 0xFF, 0x24, 0x24,\n    0x48, 0x7E, 0x49, 0x43, 0x66,\n    0x2B, 0x2F, 0xFC, 0x2F, 0x2B,\n    0xFF, 0x09, 0x29, 0xF6, 0x20,\n    0xC0, 0x88, 0x7E, 0x09, 0x03,\n    0x20, 0x54, 0x54, 0x79, 0x41,\n    0x00, 0x00, 0x44, 0x7D, 0x41,\n    0x30, 0x48, 0x48, 0x4A, 0x32,\n    0x38, 0x40, 0x40, 0x22, 0x7A,\n    0x00, 0x7A, 0x0A, 0x0A, 0x72,\n    0x7D, 0x0D, 0x19, 0x31, 0x7D,\n    0x26, 0x29, 0x29, 0x2F, 0x28,\n    0x26, 0x29, 0x29, 0x29, 0x26,\n    0x30, 0x48, 0x4D, 0x40, 0x20,\n    0x38, 0x08, 0x08, 0x08, 0x08,\n    0x08, 0x08, 0x08, 0x08, 0x38,\n    0x2F, 0x10, 0xC8, 0xAC, 0xBA,\n    0x2F, 0x10, 0x28, 0x34, 0xFA,\n    0x00, 0x00, 0x7B, 0x00, 0x00,\n    0x08, 0x14, 0x2A, 0x14, 0x22,\n    0x22, 0x14, 0x2A, 0x14, 0x08,\n    0x55, 0x00, 0x55, 0x00, 0x55, # 176 (25% block) missing in old code\n    0xAA, 0x55, 0xAA, 0x55, 0xAA, # 50% block\n    0xFF, 0x55, 0xFF, 0x55, 0xFF, # 75% block\n    0x00, 0x00, 0x00, 0xFF, 0x00,\n    0x10, 0x10, 0x10, 0xFF, 0x00,\n    0x14, 0x14, 0x14, 0xFF, 0x00,\n    0x10, 0x10, 0xFF, 0x00, 0xFF,\n    0x10, 0x10, 0xF0, 0x10, 0xF0,\n    0x14, 0x14, 0x14, 0xFC, 0x00,\n    0x14, 0x14, 0xF7, 0x00, 0xFF,\n    0x00, 0x00, 0xFF, 0x00, 0xFF,\n    0x14, 0x14, 0xF4, 0x04, 0xFC,\n    0x14, 0x14, 0x17, 0x10, 0x1F,\n    0x10, 0x10, 0x1F, 0x10, 0x1F,\n    0x14, 0x14, 0x14, 0x1F, 0x00,\n    0x10, 0x10, 0x10, 0xF0, 0x00,\n    0x00, 0x00, 0x00, 0x1F, 0x10,\n    0x10, 0x10, 0x10, 0x1F, 0x10,\n    0x10, 0x10, 0x10, 0xF0, 0x10,\n    0x00, 0x00, 0x00, 0xFF, 0x10,\n    0x10, 0x10, 0x10, 0x10, 0x10,\n    0x10, 0x10, 0x10, 0xFF, 0x10,\n    0x00, 0x00, 0x00, 0xFF, 0x14,\n    0x00, 0x00, 0xFF, 0x00, 0xFF,\n    0x00, 0x00, 0x1F, 0x10, 0x17,\n    0x00, 0x00, 0xFC, 0x04, 0xF4,\n    0x14, 0x14, 0x17, 0x10, 0x17,\n    0x14, 0x14, 0xF4, 0x04, 0xF4,\n    0x00, 0x00, 0xFF, 0x00, 0xF7,\n    0x14, 0x14, 0x14, 0x14, 0x14,\n    0x14, 0x14, 0xF7, 0x00, 0xF7,\n    0x14, 0x14, 0x14, 0x17, 0x14,\n    0x10, 0x10, 0x1F, 0x10, 0x1F,\n    0x14, 0x14, 0x14, 0xF4, 0x14,\n    0x10, 0x10, 0xF0, 0x10, 0xF0, # ok\n    0x00, 0x00, 0x1F, 0x10, 0x1F,\n    0x00, 0x00, 0x00, 0x1F, 0x14,\n#   0x00, 0x00, 0x00, 0xFC, 0x14, # any new after this line breaks\n    0x00, 0x00, 0x00, 0x00, 0x00  # 255 also a &lt;space&gt;\n])\n\ndef convert_color_RGB888_RGB565(R,G,B): # Convert RGB888 to RGB565\n    return (((G&amp;0b00011100)&lt;&lt;3) + ((B&amp;0b11111000)&gt;&gt;3)&lt;&lt;8) + (R&amp;0b11111000) + ((G&amp;0b11100000)&gt;&gt;5)\n\ndef character(asc, xt, yt, sz, r, g, b):  # Single character sz is size: 1 or 2\n    cc = convert_color_RGB888_RGB565(r,g,b)\n    code = asc * 5    # 5 bytes per character\n    for ii in range(5):\n        line = FONT[code + ii]\n        for yy in range(8):\n            if (line &gt;&gt; yy) &amp; 0x1:\n                LCD.pixel(ii*sz+xt,yy*sz+yt,cc) \n                if sz &gt; 1:\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt,cc)\n                    LCD.pixel(ii*sz+xt,yy*sz+yt+1,cc)\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt+1,cc)\n                if sz == 3:\n                    LCD.pixel(ii*sz+xt,  yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+1,yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt+2,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt,cc)\n                    LCD.pixel(ii*sz+xt+2,yy*sz+yt+1,cc)\n\n# Print a string\ndef prnt_st(asci, xx, yy, sz,r,g,b):  # Text string\n    if sz == 1: move = 6\n    if sz == 2: move = 11\n    if sz == 3: move = 17 \n    for letter in(asci):\n        asci = ord(letter)\n        character(asci,xx,yy,sz,r,g,b)\n        xx = xx + move\n\n# Center text string\ndef cntr_st(s,y,sz,r,g,b): # Centres text on line y\n    if sz == 1: w = 6\n    if sz == 2: w = 11\n    if sz == 3: w = 17 \n    gap = int((width - len(s) * w)/2)\n    prnt_st(s,gap,y,sz,r,g,b)\n\nLCD.fill(LCD.black)    \nprnt_st(\"Hello world! Red\", 20, 80, 2, 255, 0, 0)\nprnt_st(\"Hello world! Green\", 20, 100, 2, 0, 255, 0)\nprnt_st(\"Hello world! Blue\", 20, 120, 2, 0, 0, 255)\nprnt_st(\"Hello world! White\", 20, 140, 2, 255, 255, 255)\nLCD.show()\n</code></pre>"},{"location":"lessons/01-get-local-time/","title":"Getting Local Time","text":""},{"location":"lessons/01-get-local-time/#lesson-overview","title":"Lesson Overview","text":"<p>In this lesson, we will learn how to get the local date and time from the MicroPython runtime.  We will learn the components of the list of numbers returned by these functions.</p> <p>MicroPython provides a very convenient function called <code>localtime()</code> that will get the time from the host computer that you connect to via your USB cable.  Your local computer has a clock and knows the time in the local timezone.  This information is sent to MicroPython runtime when the computer is connected to the USB cable.</p> <p>Note</p> <p>The <code>gmtime()</code> function returns the time in UTC (Coordinated Universal Time) time.  Use this if you want time stamps that are not dependent on time zone and daylight savings rules.  For example, log files should use this function.</p>"},{"location":"lessons/01-get-local-time/#sample-code","title":"Sample Code","text":"<pre><code>import time\n\nprint(time.localtime())\n</code></pre>"},{"location":"lessons/01-get-local-time/#result","title":"Result","text":"<pre><code>(2023, 2, 28, 18, 54, 7, 1, 59)\n</code></pre>"},{"location":"lessons/01-get-local-time/#format-of-the-localtime","title":"Format of the Localtime","text":"<p>The format is a \"8-tuple\" in the format (year, month, mday, hour, minute, second, weekday, yearday)</p>"},{"location":"lessons/01-get-local-time/#printing-formatted-dates","title":"Printing Formatted Dates","text":""},{"location":"lessons/01-get-local-time/#sample-code_1","title":"Sample Code","text":"<pre><code>import time\n\nnow = time.localtime()\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\nfor i in range(8):\n    print(label[i], ':', now[i])\n\nprint()\nprint(\"Date: {}/{}/{}\".format(now[1], now[2], now[0]))\nprint(\"Time: {}:{}\".format(now[3], now[4]))\n</code></pre>"},{"location":"lessons/01-get-local-time/#results","title":"Results","text":"<pre><code>year : 2023\nmonth : 2\nmday : 28\nhour : 19\nminute : 20\nsecond : 26\nweekday : 1\nyearday : 59\n\nDate: 2/28/2023\nTime: 19:20\n</code></pre>"},{"location":"lessons/01-get-local-time/#label-formatting","title":"Label Formatting","text":"<p>We can also add labels to make the date and time easier to read.</p> <pre><code>import time\n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\n\nnow = time.localtime()\n\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\nmonth_number = now[1]\nmonth_name = months[month_number]\nweekday_number = now[6]\nday_name = days[weekday_number]\nhour_number = now[3]\nif hour_number &lt; 13:\n    hour_12 = hour_number\n    am_pm = 'am'\nelse:\n    hour_12 = hour_number - 12\n    am_pm = 'pm'\n\nprint()\nprint(\"Date: {} {} {}, {}\".format(day_name, month_name, now[2], now[0]))\nprint(\"Time: {}:{} {}\".format(hour_12, now[4], am_pm))\n</code></pre>"},{"location":"lessons/01-get-local-time/#label-formatted-results","title":"Label Formatted Results","text":"<pre><code>Date: Tuesday March 28, 2023\nTime: 7:46 pm\n</code></pre>"},{"location":"lessons/01-get-local-time/#references","title":"References","text":"<ul> <li>MicroPython Time Documents</li> <li>Bhavesh Kakwani's blog Sync time in MicroPython using NTP - although the blog uses an ESP32, the concepts are the same on other processors such as the Raspberry Pi Pico.</li> </ul>"},{"location":"lessons/02-display-text/","title":"Display Time and Date in Text","text":"<pre><code>from utime import localtime, sleep\nfrom LCD_1inch28 import LCD_1inch28\n\nLCD = LCD_1inch28()  \n\ndays = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday')\nmonths = ('Jan', 'Feb', 'March', 'April', 'May', 'June', 'July',\n          'Aug', 'Sept', 'Oct', 'Nov', 'Dec')\nlabel = ('year', 'month', 'mday', 'hour', 'minute', 'second', 'weekday', 'yearday')\n\ndef format_time(now):\n    hour_number = now[3]\n    if hour_number &lt; 13:\n        hour_12 = hour_number\n        am_pm = 'am'\n    else:\n        hour_12 = hour_number - 12\n        am_pm = 'pm'\n    minutes_num = now[4]\n    if minutes_num &lt; 10:\n        min_leading_zero = '0'\n    else:\n        min_leading_zero = ''\n    seconds_num = now[5]\n    if seconds_num &lt; 10:\n        sec_leading_zero = '0'\n    else:\n        sec_leading_zero = ''\n    return \"{}:{}{}:{}{} {}\".format(hour_12, min_leading_zero, minutes_num, sec_leading_zero, seconds_num, am_pm)\n\ndef format_date(now):\n    month_number = now[1]\n    month_name = months[month_number - 1]\n    weekday_number = now[6]\n    day_name = days[weekday_number]\n    hour_number = now[3]\n    return \"{} {} {}, {}\".format(day_name, month_name, now[2], now[0])\n\nwhile(True):\n    now = localtime()\n    # print(now)\n    LCD.fill(LCD.black)    \n    LCD.text(format_time(now), 77, 50, LCD.white)\n    LCD.text(format_date(now), 40, 80, LCD.white)\n    LCD.show()\n    sleep(1)\n</code></pre>"},{"location":"lessons/03-drawing-face/","title":"Drawing Watch Faces","text":"<p>We use the MicroPython poly() function to draw polygons on the screen.</p>"},{"location":"lessons/04-larger-fonts/","title":"Larger Fonts","text":"<p>Font to Py Command</p> <p>Sample Font Files</p>"},{"location":"lessons/04-larger-fonts/#references","title":"References","text":"<p>Peter Hinch's Font to Python Utility -  a utility takes input a font file in ttf or otf form together with a height in pixels and outputs a Python source file containing the font as a bitmap.</p> <p>Peter Hinch's Nano GUI</p> <p>Les' Lab: Designing your own Pico fonts - Raspberry Pi Pico display fonts in MicroPython: How to design fonts for your Pi Pico project.</p>"},{"location":"lessons/05-draw-performance/","title":"Drawing Performance","text":"<p>One of the challenges we face when updating the watch display is that refreshing an entire screen using a relatively slow SPI interface means that we need to be thoughtful about updating the displays.</p> <p>By default, many screen drivers update every pixel of the screen when the user does a <code>show()</code> operation.  For small monochrome screens this is not usually a problem.  But for larger color screens the draw times can lead to slow updates.</p> <p>Let's do a little math to see when drawing performance becomes a problem.  Remember that the human eye can's really see screen updates that occur faster than about 30 frames per second.  That is why most film movies were filled at 25 frames per second.</p> <p>To calculate the full-screen draw time we need to calculate the total number of bits we need to send and then calculate the time it takes to send these bits.  We can then check our math by looking at timestamps just before we draw and after we finish the drawing.</p> <p>Let's start out with our favorite clock screen: the 128X64 monochrome OLED screen.</p> <ol> <li>Width = 128</li> <li>Height = 64</li> <li>Bits per Pixel = 1</li> </ol> <p>Total bits = 128 * 64 * 1 = 8,192 bits = 1024 bytes</p> <p>Now we need to also know the transfer speed of our display interface.  Although there are both I2C and SPI versions of these displays, we usually prefer the SPI that should transfer data at about </p> <p>Pi Pico SPI LCD using a frame buffer to get 30fps animation - ILI9341 and ST7789 MicroPython drivers</p>"},{"location":"lessons/05-draw-performance/#sample-timer-code","title":"Sample Timer Code","text":"<p>We can calculate the time to draw the full screen by recording the number of clock ticks in microseconds before and after we do a screen update.</p> <pre><code>from utime import ticks_us\n\nstart = ticks_us()\nscreen_update()\nend = ticks_us()\nprint('Execution time in microseconds:', end - start)\n</code></pre> <p>On the OLED screen, we get a result that is around 10 milliseconds which is 100 screen updates per second.</p>"},{"location":"lessons/05-draw-performance/#references","title":"References","text":"<ol> <li>Notes on the very slow refresh rate for ST7735 </li> </ol>"},{"location":"setup/display-cable/","title":"Display Cables","text":"<p>Please view the content here:</p> <p>MicroPython Display Wriing Harness</p>"},{"location":"setup/parts/","title":"Suggested Parts for a MicroPython Watch","text":"<p>These are sample links that may not work after the inventory is sold out.  Use the keywords in the product descriptions to find similar items.  The links were generated in September of 2023.</p>"},{"location":"setup/parts/#displays","title":"Displays","text":""},{"location":"setup/parts/#128-240x240-cg9a01-tft-displays","title":"1.28\" 240x240 CG9A01 TFT Displays","text":"<ol> <li>Round 1.28 inch TFT LCD Display Module RGB IPS HD 240x240 SPI GC9A01 $5.10 each when you buy 3 or more with $4 shipping.</li> <li>Amazon Teyleten Robot 1.28 Inch TFT LCD Display Module Round RGB 240 * 240 GC9A01 Driver 4 Wire SPI Interface 240x240 PCB - 3 displays for $18.99 - about $6.33 per display</li> <li>Amazon AITRIP 2PCS 1.28 Inch 1.28'' TFT LCD Display Module Round RGB 240 * 240 GC9A01 Driver 4 Wire SPI Interface 240x240 PCB - Two displays for $14.99 using the GC9A01 chip - about $7.50 per display</li> <li>Amazon D-FLIFE 3pcs 1.28 Inch TFT LCD Display Module Round RGB 240 * 240 GC9A01 Driver 4 Wire SPI Interface 240x240</li> <li>Amazon Waveshare 1.28inch Round LCD 240\u00d7240 Resolution 65K RGB IPS Display Module for Arduino Raspberry Pi Jetson Nano STM32,SPI Interface GC9A01 Driver Clear and Colorful Displaying Effect $21.00</li> <li>Ebay 1.28\" inch TFT LCD Round Display RGB 3-5V 240*240 GC9A01</li> <li>Teyleten Robot 1.28 Inch TFT LCD Display Module Round RGB 240*240 GC9A01 Driver $7.00 each</li> </ol>"},{"location":"setup/parts/#breadboards","title":"Breadboards","text":""},{"location":"setup/parts/#jumper-wires","title":"Jumper Wires","text":""},{"location":"setup/parts/#raspberry-pi-picos","title":"Raspberry Pi Picos","text":""},{"location":"setup/parts/#rp2040-watches","title":"RP2040 watches","text":"<p>1.28\" Round Watch Rp2040 Development Board TFT Display Module With Strap DIY</p>"}]}